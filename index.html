<!DOCTYPE html>

<html lang="en">
<head><style id="hide-color-ui-firstpaint">
/* Safety net: hide any color/palette UI at first paint */
#btnColorPlay, #colorPlayBtn, #colorPop, .color-pop,
[aria-label*="Color" i], [aria-label*="palette" i],
input[type="color"] { display: none !important; visibility: hidden !important; }
</style>
<meta charset="utf-8"/>
<title>WORKENBD</title>
<!-- CLEAN TRANSPARENT OVERRIDES -->
<style id="kill-all-backgrounds">
  /* 1) Kill every background, gradient, image, ribbon, shimmer */
  html, body, header, footer, main, section, article, aside, nav,
  .wrap, .card, .tableCard, .ai-analysis-modal, .modal,
  #reportArea, #chartCard, #chartWrapper, #generalNotesCard, #generalNotes,
  .nextAlert, .months-mini, .month-pill, .performance-heatmap, .heatmap-cell,
  .scenario-section, .scenario-controls, .heatmap-container,
  .progressBar, .progressWrap, .headerTop, .headerTopFull, #nextYearTargetContainer {
    background: none !important;
    background-image: none !important;
    box-shadow: none !important;
    border: none !important;
    outline: none !important;
  }

  /* 2) Remove fancy pseudo decorations and particles */
  header::before, header::after,
  .shimmer, .floating-particles, .particle,
  .sparkle, .light-beam,
  .needBadge, .needTag,
  .month-pill::before, .heatmap-cell::before {
    display: none !important;
    content: none !important;
    background: none !important;
  }

  /* 3) Neutralize gradients/colors defined as CSS variables */
  :root, body.dark {
    --bg: transparent !important;
    --card: transparent !important;
    --glass: transparent !important;
    --watercolor-bg: none !important;
  }

  /* 4) Stop animations that create shine/glow */
  * {
    animation: none !important;
    transition: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    filter: none !important;
    text-shadow: none !important;
    box-shadow: none !important;
  }

  /* 5) Make containers flat (no rounded corners) */
  .card, .tableCard, .modal, .ai-analysis-modal, .month-pill, table, th, td, input, textarea, select, button {
    border-radius: 0 !important;
  }

  /* 6) Ensure tables/headers stay readable on transparent bg */
  table, thead th, tfoot th, tbody td {
    background: none !important;
  }

  /* 7) Keep charts transparent */
  canvas { background: none !important; }

  /* 8) Print: force white paper background without decorations */
  @media print {
    html, body, #reportArea, * {
      background: none !important;
      box-shadow: none !important;
      text-shadow: none !important;
      filter: none !important;
    }
  }
</style>
<!-- === FIX: Hide loading flicker elements during page load === -->
<style id="hide-loading-flicker">
  /* Hide problematic elements that appear during page load */
body:not(.loaded) #chartCard,
body:not(.loaded) #aiAnalysisModal,
body:not(.loaded) #scenarioModal,
body:not(.loaded) #btnExportPDF,
body:not(.loaded) #btnPrint,
body:not(.loaded) #btnGenerateReport {
  display: none !important;
  visibility: hidden !important;
}  /* Ensure modals stay hidden until explicitly shown */
  .modal:not(.visible) {
    display: none !important;
  }
  
  /* Only show modals when they have the 'visible' class */
  .modal.visible {
    display: block !important;
    visibility: visible !important;
  }
</style>
<!-- END CLEAN TRANSPARENT OVERRIDES -->
<style id="page-background-image">
  html, body {
    min-height: 100%;
    height: auto;
    background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }
</style>
<style id="page-background-image-fixed">
  /* Strong override so the wallpaper wins even with kill-all !important rules */
  html, body {
    background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg') !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    background-attachment: fixed !important;
    min-height: 100% !important;
  }

  /* Make sure it also appears in print/PDF */
  @media print {
    html, body::before {
      -webkit-print-color-adjust: exact !important;
      print-color-adjust: exact !important;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
  }
</style>
<style id="page-wallpaper-override">
  :root { --page-wallpaper: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg'); }

  /* Ensure page itself is transparent and tall */
  html, body {
    height: 100% !important;
    min-height: 100% !important;
    background: transparent !important;
  }

  /* Primary method: a fixed pseudo-layer that always covers the viewport */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;            /* sits behind all content */
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Fallback layer in case some browsers ignore ::before due to stacking contexts */
  #page-wallpaper-layer {
    position: fixed;
    inset: 0;
    z-index: -2;
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Ensure print/PDF keeps the wallpaper */
  @media print {
    html, body::before { 
      -webkit-print-color-adjust: exact !important; 
      print-color-adjust: exact !important; 
    }
    body::before {
      position: fixed;
    }
  }
</style>
<style id="chart-background-restore">
  #chartCard,
  #chartWrapper,
  #chartWrapper canvas {
    background: #ffffff !important;
    border-radius: 8px;   /* rounded edges */
    box-shadow: 0 2px 6px rgba(0,0,0,0.1); /* subtle depth */
  }
</style>
<style id="branding-background-restore">
  .branding-text, #branding, .footer-note {
    display: inline-block;
    background: #ffffff !important;
    padding: 4px 8px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  }
</style>
<style id="custom-red-borders">
  #chartCard, #chartWrapper {
    border: 2px solid red !important;
    border-radius: 10px !important;
    padding: 8px !important;
  }
  #generalNotesCard, #generalNotes {
    border: 2px solid red !important;
    border-radius: 10px !important;
    padding: 8px !important;
  }
</style>
<style id="custom-gold-title">
  #chartCard h2, #chartWrapper h2 {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
  }
</style>
<style id="custom-branding-gold">
  .branding-text, #branding, .footer-note {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
    background: transparent !important;
  }
</style>
<style id="footer-gold-fix">
  footer, footer p, footer span, #branding, .footer-note {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
    background: transparent !important;
  }
</style>
<style id="kpi-gold-fix">
  .progressLabel {
    font-weight: 600;
  }
  .progressLabel:before {
    /* fallback pseudo for unsupported selectors */
  }
  /* Force gold for specific KPI labels */
  .progressLabel, .row .progressLabel {
    color: var(--muted);
  }
  .progressLabel:has-text("Inflow Achieved"),
  .progressLabel:has-text("Remaining to Target") {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
  }
</style>
<style id="header-footer-gold-fix">
  header h1, header p,
  footer, footer p, footer span,
  #branding, .footer-note {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
    background: transparent !important;
  }
</style>
<style id="header-footer-red-fix">
  header h1, header p,
  footer, footer p, footer span,
  #branding, .footer-note {
    color: red !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 0, 0, 0.6);
    background: transparent !important;
  }
</style>
<style id="month-pill-font-increase">
  .month-pill {
    font-size: 14px !important;
  }
</style>
<style id="month-pill-font-increase-2">
  .month-pill {
    font-size: 15px !important;
  }
</style>
<style id="month-pill-gold-names">
  .month-pill > div:first-child {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
  }
</style>
<style id="orange-outer-borders-strong">
  /* Ensure the card that wraps the table has an orange outer border */
  .tableCard {
    border: 3px solid orange !important;
    border-radius: 10px !important;
  }

  /* Ensure the table itself also has an orange outer border */
  .tableCard table {
    border: 2px solid orange !important;
    border-collapse: collapse !important;
  }

  /* Keep inner lines subtle so the outer border stands out */
  .tableCard table th, 
  .tableCard table td {
    border: 1px solid rgba(255,255,255,0.12) !important;
  }
</style>
<style id="kpi-pills-orange-borders">
  /* KPI summary cards */
  .summary {
    border: 3px solid orange !important;
    border-radius: 12px !important;
    padding: 12px !important;
  }

  /* Monthly pills container */
  .months-mini {
    border: 3px solid orange !important;
    border-radius: 12px !important;
    padding: 10px !important;
    margin-top: 10px !important;
  }
</style>
<style id="next-target-white-card">
  #nextYearTargetContainer, #nextYearTargetContainer * {
    background: #ffffff !important;
    color: #000000 !important;
    border-radius: 8px !important;
    padding: 4px 8px !important;
  }
</style>
<style id="toggle-view-big">
  button#toggleViewBtn {
    font-size: 17px !important;
    padding: 8px 12px !important;
  }
</style>
<style id="upper-cards-orange-borders">
  .card, .summary, .kpi-item {
    border: 3px solid orange !important;
    border-radius: 12px !important;
    padding: 10px !important;
  }
</style>
<style id="next-alert-border-fix">
  div.nextAlert, .nextAlert {
    border: 4px solid orange !important;
    border-radius: 12px !important;
    padding: 12px !important;
    background: rgba(255, 165, 0, 0.05) !important; /* subtle orange tint */
  }
</style>
<style id="upper-ribbon-border">
  .ribbon, .header, .top-bar {
    border: 4px solid orange !important;
    border-radius: 8px !important;
    padding: 6px 10px !important;
    background: rgba(255, 165, 0, 0.05) !important;
  }
</style>
<style id="upper-ribbon-strong-border">
  .ribbonCard, .summary-ribbon, .topRibbon, .summary:first-of-type, 
  .header-ribbon, .owner-year-selector {
    border: 4px solid orange !important;
    border-radius: 8px !important;
    padding: 8px 12px !important;
    background: rgba(255, 165, 0, 0.08) !important;
  }
</style>
<style id="next-needed-owner-year-borders">
  /* Next Needed ribbon */
  .neededRibbon, #nextNeededContainer {
    border: 3px solid orange !important;
    border-radius: 8px !important;
    padding: 8px 12px !important;
    background: rgba(255, 165, 0, 0.05) !important;
  }

  /* Owner & Year section */
  .owner-year, #ownerSelector, #yearSelector, .owner-year-selector, .ownerSelector, .yearSelector {
    border: 3px solid orange !important;
    border-radius: 8px !important;
    padding: 6px 10px !important;
    background: rgba(255, 165, 0, 0.05) !important;
  }
</style>
<style id="monthly-performance-red">
  #chartCard h2, #chartWrapper h2 {
    color: red !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 0, 0, 0.6);
  }
</style>
<style id="monthly-performance-red-fix">
  h2, .card-header h2 {
    color: red !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 0, 0, 0.6);
  }
</style>
<script id="monthly-performance-red-script">
  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll("h2, .card-header h2").forEach(function(el) {
      if (el.textContent.includes("Monthly Performance")) {
        el.style.color = "red";
        el.style.fontWeight = "400";
        el.style.
      }
    });
  });
</script>
<style id="toggle-view-size-fix-2">
  /* Generic boost so the Toggle View matches neighboring buttons */
  .chart-toolbar button, .chart-toolbar .ghost {
    line-height: 1 !important;
  }
</style>
<script id="toggle-view-size-fix-script">
document.addEventListener('DOMContentLoaded', function () {
  const candidates = Array.from(document.querySelectorAll('button, .ghost, .iconBtn, .toolbar button, .chart-toolbar button'));
  const btn = candidates.find(el => /toggle\s*view/i.test(el.textContent || ''));
  if (btn) {
    btn.style.fontSize = '16px';
    btn.style.padding = '8px 12px';
    btn.style.minHeight = '32px';
    btn.style.display = 'inline-flex';
    btn.style.alignItems = 'center';
    btn.style.gap = '6px';
  }
});
</script>
<style id="monthly-performance-strong-red">
  h2, .card-header h2, #chartCard h2, #chartWrapper h2 {
    color: red !important;
    font-weight: 900 !important;
    text-shadow: 0 0 8px rgba(255, 0, 0, 0.8) !important;
    opacity: 1 !important;
  }
</style>
<script id="monthly-performance-strong-red-script">
  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll("h2, .card-header h2, #chartCard h2, #chartWrapper h2").forEach(function(el) {
      if (el.textContent.includes("Monthly Performance")) {
        el.style.color = "red";
        el.style.fontWeight = "400";
        el.style.opacity = "1";
        el.style.
      }
    });
  });
</script>
<style id="monthly-performance-bold-fix">
  h2, .card-header h2, #chartCard h2, #chartWrapper h2 {
    font-size: 22px !important;
    font-weight: 1000 !important;
    color: red !important;
    opacity: 1 !important;
  }
</style>
<script id="monthly-performance-bold-fix-script">
  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll("h2, .card-header h2, #chartCard h2, #chartWrapper h2").forEach(function(el) {
      if (el.textContent.includes("Monthly Performance")) {
        el.style.fontSize = "12px";
        el.style.fontWeight = "400";
        el.style.color = "red";
        el.style.opacity = "1";
      }
    });
  });
</script>
<style id="monthly-performance-direct-fix">
  #chartCard > div:first-of-type {
    color: red !important;
    font-size: 24px !important;
    font-weight: 1000 !important;
    opacity: 1 !important;
    text-shadow: 0 0 8px rgba(255,0,0,0.8) !important;
  }
</style>
<style id="upper-section-border">
  .header, .header-container, .top-section, 
  #branding, #nextNeededContainer, .owner-year, .owner-year-selector {
    border: 4px solid orange !important;
    border-radius: 12px !important;
    padding: 12px !important;
    margin-bottom: 12px !important;
    background: rgba(255,165,0,0.05) !important;
  }
</style>
<script id="upper-section-auto-border">
document.addEventListener("DOMContentLoaded", function () {
  function findByText(text) {
    const xpath = `//*/text()[contains(normalize-space(.), "${text}")]`;
    const res = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    if (res.snapshotLength > 0) {
      return res.snapshotItem(0).parentNode;
    }
    return null;
  }
  function ancestors(el) {
    const arr = [];
    while (el && el !== document.body) { arr.push(el); el = el.parentElement; }
    return arr;
  }
  function commonAncestor(a, b) {
    if (!a || !b) return null;
    const A = new Set(ancestors(a));
    const bs = ancestors(b);
    for (const el of bs) if (A.has(el)) return el;
    return null;
  }
  // Try to locate key blocks by their visible text
  const titleEl = findByText("ENBD Performance Tracker");
  const nextNeededEl = findByText("Next needed");
  const nextDueEl = findByText("Next Due:");
  // Also try owner/year by looking for the year (2025/2026) label container
  let ownerYearEl = null;
  const years = ["2025","2026","2027","Owner","Owner 1","Owner 2"];
  for (const y of years) { const n = findByText(y); if (n) { ownerYearEl = n; break; } }
  // Compute a common ancestor that likely wraps the whole upper section
  let root = titleEl || nextNeededEl || nextDueEl || ownerYearEl;
  // progressively merge
  const nodes = [titleEl, nextNeededEl, nextDueEl, ownerYearEl].filter(Boolean);
  if (nodes.length > 1) {
    root = nodes[0];
    for (let i=1; i<nodes.length; i++) {
      const ca = commonAncestor(root, nodes[i]) || root.parentElement;
      if (ca) root = ca;
    }
  }
  // Fallback selectors if we couldn't find by text
  if (!root) {
    root = document.querySelector(".top-section, .header, .header-container, .hero, .banner, .ribbonCard");
  }
  if (root) {
    // Apply a strong orange border to the detected upper section container
    Object.assign(root.style, {
      border: "4px solid orange",
      borderRadius: "12px",
      padding: "12px",
      background: "rgba(255,165,0,0.05)",
      boxShadow: "0 0 0 1px rgba(255,165,0,0.2) inset"
    });
  }
});
</script>
<style id="branding-orange">
  #branding, .footer-note, footer, footer p, footer span,
  header h1, header p, .header h1, .header p {
    color: orange !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 165, 0, 0.6);
    background: transparent !important;
  }
</style>
<script id="robust-fixes">
(function(){
  function styleElByText(text, styleObj, opts){
    opts = opts || {};
    const xpath = `//text()[contains(normalize-space(.), "${text}")]`;
    const res = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = 0; i < res.snapshotLength; i++) {
      let node = res.snapshotItem(i).parentNode;
      if (opts.closestBlock !== false) {
        // Climb until we hit a block-level element so styles are visible
        while (node && node !== document.body && getComputedStyle(node).display === "inline") {
          node = node.parentElement;
        }
      }
      if (!node) continue;
      Object.assign(node.style, styleObj);
    }
  }

  function apply() {
    // Make "Monthly Performance" bold, red, visible
    styleElByText("Monthly Performance", {
      color: "red",
      fontWeight: "400",
      fontSize: "12px",
      opacity: "1",
      });

    // Branding header/footer to orange
    styleElByText("ENBD Performance Tracker", {
      color: "orange",
      fontWeight: "700",
      textShadow: "0 0 6px rgba(255,165,0,0.6)"
    });
    styleElByText("created by Fuad Al-Taher", {
      color: "orange",
      fontWeight: "700",
      textShadow: "0 0 6px rgba(255,165,0,0.6)"
    });

    // Find a common ancestor for upper section (title, next due, owner/year, next needed) and add border
    const texts = ["ENBD Performance Tracker", "Next Due:", "Next needed", "Owner", "Year"];
    const nodes = [];
    texts.forEach(t => {
      const x = document.evaluate(`//text()[contains(normalize-space(.), "${t}")]`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
      if (x && x.parentNode) nodes.push(x.parentNode);
    });

    function ancestors(el){
      const arr = [];
      while (el && el !== document.body) { arr.push(el); el = el.parentElement; }
      return arr;
    }
    function commonAncestor(a, b){
      if (!a || !b) return null;
      const A = new Set(ancestors(a));
      for (const el of ancestors(b)) if (A.has(el)) return el;
      return null;
    }

    if (nodes.length) {
      let root = nodes[0];
      for (let i = 1; i < nodes.length; i++) {
        root = commonAncestor(root, nodes[i]) || root;
      }
      if (root) {
        Object.assign(root.style, {
          border: "4px solid orange",
          borderRadius: "12px",
          padding: "12px",
          background: "rgba(255,165,0,0.05)"
        });
      }
    }
  }

  document.addEventListener("DOMContentLoaded", apply);
  // Re-apply if the DOM changes (dynamic content)
  new MutationObserver(() => apply()).observe(document.documentElement, { childList: true, subtree: true });
})();
</script>
<script id="monthly-performance-adjustment">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll("*").forEach(function(el) {
    if (el.textContent && el.textContent.includes("Monthly Performance")) {
      el.style.fontSize = "12px"; /* ~30% smaller than 22px */
      el.style.fontWeight = "400"; /* normal weight (un-bold) */
      el.style.color = "red";
      el.style.opacity = "1";
    }
  });
});
</script>
<script id="monthly-performance-final-enforce">
document.addEventListener("DOMContentLoaded", function() {
  function apply(){
    const xpath = '//text()[contains(normalize-space(.), "Monthly Performance")]';
    const res = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i=0; i<res.snapshotLength; i++) {
      let el = res.snapshotItem(i).parentNode;
      // climb to block
      while (el && el !== document.body && getComputedStyle(el).display === "inline") el = el.parentElement;
      if (!el) continue;
      el.style.fontSize = "12px";
      el.style.fontWeight = "400";
      el.style.color = "red";
      el.style.textShadow = "none";
      el.style.opacity = "1";
    }
  }
  apply();
  new MutationObserver(apply).observe(document.documentElement, {childList:true, subtree:true});
});
</script>
<style id="kpi-gold-resize">
  .progressLabel {
    font-size: 100% !important; /* reset */
  }
  /* Specifically target the two labels */
</style>
<style id="branding-gold-text">
  #branding, .branding-text, .footer-note,
  header h1, header p {
    color: gold !important;
    font-weight: 700 !important;
    text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
  }
</style>
<style id="hide-footer-branding">
#branding { display: none !important; visibility: hidden !important; }
</style>
<style id="brandingCard-no-bg-rich-gold">
#brandingCard { top: 24mm; 
  color: #FFD700 !important; /* rich gold */
  -webkit-text-fill-color: #FFD700 !important;
  font-weight: 700 !important;
  text-shadow: 
    0 0 6px rgba(255, 215, 0, 0.9),
    0 0 12px rgba(255, 215, 0, 0.6);
}
</style>
<style id="dark-mode-css-lock">
/* Minimal dark palette fallback */
html, body { background: #0f0f10 !important; color: #f2f2f2 !important; }
</style>
<style id="next-target-dark-fix">
/* Fix Next Target card visibility in dark mode (orange text) */
body.dark #nextTargetCard,
body.dark .next-target,
body.dark #nextYearTargetContainer {
  color: #FFA500 !important;
  -webkit-text-fill-color: #FFA500 !important;
  font-weight: 700 !important;
}
</style>
<style id="chart-red-border">
  #chartCard, #chartWrapper {
    border: 4px solid red !important;
    border-radius: 12px !important;
    padding: 10px !important;
  }
</style>
<style id="next-target-amount-green-2025-09-14">
/* Force green numbers for Next Target cards & popups */
.next-target-card .ntc-amt,
.ntw .ntc-row .amt,
.ntw-body .ntc-row .amt,
.ntw-panel .ntc-row .amt,
body.dark .next-target-card .ntc-amt,
body.dark .ntw .ntc-row .amt,
body.dark .ntw-body .ntc-row .amt,
body.dark .ntw-panel .ntc-row .amt {
  color: #16a34a !important; /* green */
}
/* If the number is wrapped in .amount inside these blocks, color it too */
.next-target-card .amount,
.ntw .amount,
.ntw-body .amount,
.ntw-panel .amount,
body.dark .next-target-card .amount,
body.dark .ntw .amount,
body.dark .ntw-body .amount,
body.dark .ntw-panel .amount {
  color: #16a34a !important;
}
</style><style id="next-targets-black-theme-2025-09-14">
/* === Black theme for Next Target (mini-card) & Next Targets (widget/panel) === */
/* Containers */
.next-target-card,
#nextTargets, .next-targets-card, #nextTargetsCard,
.ntw-panel, .ntc-row {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 16px 36px rgba(0,0,0,0.6) !important;
}
/* Ensure inner text/icons are white by default */
.next-target-card *, 
#nextTargets *, .next-targets-card *, #nextTargetsCard *,
.ntw-panel *, .ntc-row * {
  color: #fff !important;
  -webkit-text-fill-color: #fff !important;
  text-shadow: none !important;
}

/* Keep the amounts GREEN (overrides the white above) */
.next-target-card .ntc-amt,
.ntw .ntc-row .amt,
.ntw-body .ntc-row .amt,
.ntw-panel .ntc-row .amt,
.next-target-card .amount,
#nextTargets .amount,
#nextTargetsCard .amount {
  color: #16a34a !important; /* green */
  -webkit-text-fill-color: #16a34a !important;
}

/* Subtle row background for list items in the Next Targets panel */
.ntc-row {
  background: rgba(255,255,255,0.05) !important;
  border: 1px solid rgba(255,255,255,0.15) !important;
  border-radius: 10px !important;
}
</style><style id="target-balance-color-rules-2025-09-14">
/* === Target & Balance Colour Rules === */

/* A) Next Target amount (mini-card + panel): GOLD */
.next-target-card .ntc-amt,
.ntw .ntc-row .amt,
.ntw-body .ntc-row .amt,
.ntw-panel .ntc-row .amt,
.next-target-card .amount,
#nextTargets .amount,
#nextTargetsCard .amount {
  color: #FFD700 !important;                /* gold */
  -webkit-text-fill-color: #FFD700 !important;
}

/* B) Balance text inside Next Targets list (spans created via makeSpan('bal', ...)) */
.ntc-row .bal { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; }    /* default = positive */
.ntc-row .bal.neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; } /* negative */

/* C) KPI Target (Yearly Target) gold */
#kpiVal_target {
  color: #FFD700 !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: #FFD700 !important;
}

/* D) KPI Balance (kpiVal_rem): color by sign classes, override any earlier "always red" rule */
#kpiVal_rem {
  color: inherit !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: inherit !important;
}
#kpiVal_rem.kpi-pos { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; } /* green */
#kpiVal_rem.kpi-neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; } /* red */
#kpiVal_rem.kpi-zero{ color: #6b7a7a !important; -webkit-text-fill-color: #6b7a7a !important; } /* neutral */

/* Ensure small "surplus/shortage" status in Next Target stays consistent */
.next-target-card .ntc-status.surplus,
.ntw .ntc-row .status.surplus { color: #1a7f37 !important; }
.next-target-card .ntc-status.shortage,
.ntw .ntc-row .status.shortage { color: #c62828 !important; }
</style><style id="all-years-dropdown-width-2025-09-14">
/* === Widen the 'All Targets' dropdown panel (id=allYearsContent) === */
#allYearsContent {
  width: 420px !important;
  min-width: 420px !important;
}
/* Optional: give inner rows a little more room if they use grid/flex */
#allYearsContent .row, 
#allYearsContent .item, 
#allYearsContent .ntc-row {
  gap: 8px !important;
}
</style><style id="all-years-dropdown-dark-and-bigger-2025-09-14">
/* === All Targets dropdown: black bg + bigger numbers === */
#allYearsContent {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 12px 36px rgba(0,0,0,0.7) !important;
}

/* List rows inside the dropdown */
#allYearsContent > div {
  font-size: 14.4px !important; /* +20% over 12px */
  line-height: 1.35 !important;
  border-bottom: 1px solid rgba(255,255,255,0.08) !important;
}

/* Keep month numbers readable on dark */
#allYearsContent > div > div:first-child {
  color: #8fd6cc !important;
}

/* Maintain target gold if not already styled inline */
#allYearsContent > div > div:nth-child(2) {
  color: #FFD700 !important;
}

/* Balance color is already inline; we only ensure good contrast */
#allYearsContent > div > div:nth-child(3) {
  text-shadow: none !important;
}
</style><style id="all-years-divider-lines-2025-09-14">
/* === Light fine lines between All Targets rows === */
#allYearsContent > div {
  border-bottom: 1px solid rgba(255,255,255,0.18) !important; /* subtle light line on black */
  margin: 0 !important;
  padding-top: 6px !important;
  padding-bottom: 6px !important;
}
/* Remove border from the very last row to avoid double border with container */
#allYearsContent > div:last-child {
  border-bottom: none !important;
}
</style><style id="next-targets-style-match-alltargets-2025-09-14">
/* === Next Target (below) — match All Targets style === */
#nextTargetsWidget .ntw-panel {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 12px 36px rgba(0,0,0,0.7) !important;
}

/* +20% font size for list items */
#nextTargetsWidget li,
#nextTargetsWidget .ntw-panel .ntc-row {
  font-size: 14.4px !important;
  line-height: 1.35 !important;
}

/* Target in gold */
#nextTargetsWidget .amt {
  color: #FFD700 !important;
  -webkit-text-fill-color: #FFD700 !important;
}

/* Balance sign colours */
#nextTargetsWidget .bal { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; }
#nextTargetsWidget .bal.neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; }

/* Fine divider lines between rows */
#nextTargetsWidget li {
  border-bottom: 1px solid rgba(255,255,255,0.18) !important;
  margin: 0 !important;
  padding-top: 6px !important;
  padding-bottom: 6px !important;
}
#nextTargetsWidget li:last-child { border-bottom: none !important; }
</style><style id="next-target-widget-toggle-orange-2025-09-14">
/* === Make Next Target widget (the small header/toggle) text orange for visibility === */
#nextTargetsWidget .ntw-toggle,
#nextTargetsWidget .ntw-toggle *,
#nextTargetsWidget .ntw .label,
#nextTargetsWidget .label {
  color: #FFA500 !important;
  -webkit-text-fill-color: #FFA500 !important;
}

/* Keep the amounts inside the list untouched (gold) */
#nextTargetsWidget .amt {
  color: #FFD700 !important;
  -webkit-text-fill-color: #FFD700 !important;
}

/* Keep balances sign-coloured */
#nextTargetsWidget .bal { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; }
#nextTargetsWidget .bal.neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; }
</style><style id="popdown-font-shrink-2025-09-14">
/* === Popdown text 10% smaller === */
#nextTargetsWidget .ntw-panel li,
#nextTargetsWidget .ntw-panel .ntc-row {
  font-size: 90% !important; /* 10% smaller than current */
}
/* Also apply to the All Targets dropdown panel, if open */
#allYearsContent > div {
  font-size: 90% !important;
}
</style><style id="branding-owner-gap-override">
/* Increase distance between branding line and Owner/Year toggles */
.headerTop .owner-middle,
.headerTopFull .owner-middle,
.owner-year-selector,
#ownerSelector,
.ownerSelector,
.yearSelector,
#yearSelector,
.owner-year {
  margin-top: 12mm !important;
}
</style>
<style id="branding-enforce-orange-2025-09-14">
/* Enforce orange branding everywhere, override previous gold/red rules */
#branding,
.branding-text,
.footer-note,
header h1, header p,
.header h1, .header p,
#brandingCard, #brandingCard *,
footer, footer p, footer span {
  color: #FFA500 !important;
  -webkit-text-fill-color: #FFA500 !important;
  text-shadow: none !important;
  background: transparent !important;
}

/* Unhide #branding if hidden somewhere */
#branding { display: inline !important; visibility: visible !important; }

/* Remove any gold card background & heavy shadow from #brandingCard */
#brandingCard { background: transparent !important; box-shadow: none !important; }
</style>
<style id="chart-border-orange-2025-09-14">
#gaugeChart,
#chartWrapper,
#scn-chart,
#two-fine-borders-chart,
#chart-background-restore,
#performanceChart,
#chartCard,
#chart-red-border,
canvas#gaugeChart,
canvas#gaugeMonthsOverlay,
canvas#performanceChart,
canvas#scn-chart,
.chart-card,
.chart-container,
.chart,
.chartBox,
.chart-wrapper,
#chart,
#chartContainer {
  border: 2px solid #FFA500 !important;
  border-radius: 10px !important;
}
</style>
<style id="legend-css-25pct-v4">
/* Force ~25% smaller custom legend UI */
.legend-item { font-size: 10px !important; gap: 6px !important; }
.legend-color { width: 12px !important; height: 12px !important; border-radius: 3px !important; }
/* Chart.js HTML legend (if used) */
.chartjs-legend li { font-size: 9px !important; }
.chartjs-legend li span { width: 9px !important; height: 9px !important; }
</style>
<style id="show-toolbar-actions-only">
/* Show PDF / Report / Print ONLY inside the top toolbar */
#btnExportPDF, #btnGenerateReport, #btnPrint { display: none !important; }
#topToolbar #btnExportPDF,
#topToolbar #btnGenerateReport,
#topToolbar #btnPrint { display: inline-flex !important; }
</style><style id="actions-toolbar-only">
/* Show PDF / Report / Print ONLY inside the top toolbar */
#btnExportPDF, #btnGenerateReport, #btnPrint { display: none !important; }
#topToolbar #btnExportPDF,
#topToolbar #btnGenerateReport,
#topToolbar #btnPrint { display: inline-flex !important; }
</style><style id="instant-hide-nextcards">
/* Instantly hide legacy Next Target cards to avoid load blink */
#nextTargetCard,
#nextYearTargetCard,
.next-target-card { display:none !important; visibility:hidden !important; pointer-events:none !important; }
</style><style id="share-icon-color-fix">
/* Share icon color consistency */
.share-icon{
  color: var(--gold) !important;
  opacity: 1 !important;
  filter: none !important;
}
.share-icon:hover{ transform: translateY(-1px); }
</style><style id="refresh-stabilize-css">
/* Keep Refresh button pinned at far right of the toolbar and prevent jitter */
#topToolbar { display: flex; align-items: center; flex-wrap: wrap; }
#btnHardRefresh { order: 999; }
#btnHardRefresh, #topToolbar #btnHardRefresh {
  display: inline-flex; align-items: center; gap: 6px;
  white-space: nowrap; will-change: auto;
}
/* Avoid vertical jump on click/hover */
#btnHardRefresh:active, #btnHardRefresh:focus { transform: none !important; }
/* Normalize the ⟳ glyph size */
#btnHardRefresh { font-variant-ligatures: none; }
</style><style id="share-icon-contrast-fix">
/* Share icon contrast to match neighbors */
.share-icon {
  color: var(--text) !important;   /* inherits white in dark themes */
  opacity: 1 !important;
  filter: none !important;
  text-shadow: none !important;
  transition: none !important;
}
.share-icon:hover { transform: none !important; }
</style><style id="share-icon-white-style">
/* Force share icon to match neighbor icon color */
.share-icon {
  color: #fff !important;
  opacity: 1 !important;
  filter: none !important;
  text-shadow: none !important;
  font-weight: 600;
  font-size: 14px; /* tune if needed */
  line-height: 1;
}
</style><style id="share-style-robust">
/* Toolbar Share color (white) */
#topToolbar #btnShare,
#topToolbar .btn-share,
#topToolbar [aria-label*="Share" i],
#topToolbar [title*="Share" i] {
  color: #fff !important;
  opacity: 1 !important;
}
#topToolbar #btnShare svg,
#topToolbar .btn-share svg,
#topToolbar [aria-label*="Share" i] svg,
#topToolbar [title*="Share" i] svg {
  fill: currentColor !important;
  stroke: currentColor !important;
}

/* Generic share menus: black background */
.shareMenuWrapper, .shareMenu, .share-menu, .share-menu-wrapper,
#shareActionPicker, #shareActionPicker > div,
.popover-share, .menu-share {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.2) !important;
}
.shareMenuWrapper .shareAction, .shareMenu .shareAction, .share-menu .shareAction,
#shareActionPicker .ghost, .popover-share .shareAction {
  color: #fff !important;
  background: transparent !important;
  border-color: rgba(255,255,255,0.25) !important;
}
.shareMenuWrapper .shareAction:hover, .shareMenu .shareAction:hover, .share-menu .shareAction:hover,
#shareActionPicker .ghost:hover, .popover-share .shareAction:hover {
  background: rgba(255,255,255,0.08) !important;
}
</style></head>
<body class='\"dark\"'>
<script>
// Immediately add 'loaded' class to prevent flicker
document.body.classList.add('loaded');
</script>
<style id="brandingCard-style">
#brandingCard {
  display: inline-block;
  background: #FFD700;           /* yellow card */
  color: #000 !important; -webkit-text-fill-color: #000 !important; text-shadow: none !important;                   /* black text */
  font-weight: 700;
  padding: 2px 41px;
  border-radius: 8px;
  font-size: 16px;
  line-height: 1.2;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  position: absolute;
  top: 29mm;                     /* distance from top */
  left: 50%;                     /* center horizontally */
  transform: translateX(-50%);   /* adjust centering */
  z-index: 1000;                 /* stay above ribbons */
  text-align: center;
}
</style>
<div id='\"page-wallpaper-layer\"'></div>
<!-- partial:index.partial.html -->
<!DOCTYPE html>

<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&amp;display=swap" rel="stylesheet"/>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>ENBD Performance Tracker</title>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<!-- XLSX for Excel export -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<!-- html2canvas + jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style class="next-needed-frame">

/* --- Force "Next Year Target" line to right side --- */
#nextYearTargetContainer{
  display: flex !important;
  justify-content: flex-end !important;
  align-items: center !important;
  width: 100% !important;
  text-align: right !important;
  gap: 8px;
}
#nextYearTargetContainer *{
  text-align: right !important;
  white-space: nowrap;
}


/* removed wrong selector */

    :root {
      --bg: #f4f6f5;
      --card: rgba(255,255,255,0.85);
      --muted: #6b7785;
      --accent: #4a8d85;
      --accent-2: #8db3af;
      --green: #6fae75;
      --red: #d46b6b;
      --gold: #e3b04b;
      --purple: #9f7fbf;
      --glass: rgba(255,255,255,0.6);
      --card-shadow: 0 8px 30px rgba(15,30,40,0.06);
      --radius: 12px;
      --text: #102027;
      --text-bold: #072027;
      --light-gray: #e0e0e0;
      --very-light-green: #f0f8f0;
      --very-light-blue: #e6f0fa;
      --watercolor-bg: linear-gradient(135deg, rgba(245,245,220,0.3), rgba(240,248,255,0.3));
      --orange-red-flag: #ff6200;
    }
    html, body { height:100%; }
    body {
      margin: 18px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--watercolor-bg), linear-gradient(180deg,#f6f8f7 0%, #f4f6f5 100%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }
    body.dark {
      --bg: #121416;
      --card: rgba(40,45,50,0.85);
      --muted: #909ba8;
      --accent: #5aa096;
      --accent-2: #8db3af;
      --green: #82b989;
      --red: #d98080;
      --gold: #e6b865;
      --purple: #b490d1;
      --glass: rgba(200,200,200,0.1);
      --card-shadow: 0 8px 30px rgba(0,0,0,0.3);
      --text: #d0d5db;
      --text-bold: #e0e5eb;
      --light-gray: #2e2e2e;
      --very-light-green: #2e3d2e;
      --very-light-blue: #2e3a4a;
      --orange-red-flag: #ff8c00;
      background: var(--watercolor-bg), linear-gradient(180deg, #1c1f23 0%, #16191d 100%);
      color: var(--text);
    }
    .wrap { max-width:1240px; margin:0 auto; }
    header { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:20px; }
    .title-left { text-align:left; display:flex; align-items:center; gap:8px; }
    .owner-middle { flex:1; display:flex; justify-content:center; align-items:center; }
    .right { display:flex; align-items:center; gap:10px; }
    header h1 { font-size: 22px; margin:0; color:var(--accent); }
    header p { margin:0; color:var(--muted); font-size: 14px; }
    /* new input styling for year selector */
    /* enlarge and color year selector */
    #yearInput {
      width: 80px;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid var(--accent);
      background: var(--card);
      color: var(--accent);
      font-size: 17px;
      font-weight: 600;
      text-align: center;
    }
    #yearInput:focus { outline:2px solid var(--accent-2); }
    .owner-container {
      display: flex;
      align-items: center;
      gap: 4px;
      justify-content: center;
    }
    .top {
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:14px;
      align-items:start;
    }
    .card {
      background:var(--card);
      border-radius:var(--radius);
      padding:18px;
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(74,141,133,0.06);
      backdrop-filter: blur(6px);
      transition: box-shadow .25s cubic-bezier(.4,0,.2,1), transform .18s;
    }
    .card:hover {
      box-shadow: 0 12px 36px rgba(74,141,133,0.13);
      transform: translateY(-2px) scale(1.01);
    }
    .summary { display:flex; flex-direction:column; gap:12px; }
    .row { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .big { font-weight:700; font-size: 19px; color:var(--text-bold); }
    .small { font-size: 13px; color:var(--muted); }
    .progressWrap.modern-progress {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: stretch;
      margin-top: 0px;
      position: relative;
    }
    .progressRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }
    .progressLabel {
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    .progressValue {
      font-size: 1.125rem;
      font-weight: 700;
      color: var(--accent);
      background: rgba(74,141,133,0.07);
      padding: 2px 6px;
      border-radius: 6px;
      min-width: 30px;
      text-align: right;
      box-shadow: 0 1px 3px rgba(74,141,133,0.04);
      transition: transform 0.2s ease, background 0.2s ease;
    }
    .progressValue:hover {
      transform: scale(1.05);
      background: rgba(74,141,133,0.1);
    }
    .progressBar.bar {
      height: 10px;
      margin-bottom: 4px;
      background: linear-gradient(180deg,#f0f3f2,#f8faf9);
      border-radius: 999px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(74,141,133,0.04);
      position: relative;
    }
    .fillGreen { height:100%; width:0; background:linear-gradient(90deg,var(--green),#8dd39a); transition:width .45s ease; }
    .fillRed { height:100%; width:0; background:linear-gradient(90deg,var(--red),#d98080); transition:width .45s ease; }
    .tooltip {
      position: absolute;
      background: var(--card);
      color: var(--text);
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 11px;
      display: none;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .progressBar:hover .tooltip { display: block; }
    .months-mini { display:flex; gap:8px; margin-top:-2px; justify-content:space-between; flex-wrap:wrap; }
    .month-pill { text-align:center; font-size: 13px; padding:8px 8px; border-radius:8px; min-width:44px; background:rgba(255,255,255,0.9); color:var(--muted); cursor:pointer; border:1px solid rgba(15,48,40,0.04); box-shadow:0 6px 14px rgba(10,20,20,0.02); transition: box-shadow .18s, background .18s, color .18s;}
    .month-pill.active { box-shadow:0 8px 20px rgba(74,141,133,0.12); transform:translateY(-2px); border-color:rgba(74,141,133,0.12); }
    .month-pill.met { background:linear-gradient(90deg,#eaf6ee,#f3fbf6); color:var(--green); border-color:rgba(111,174,117,0.12);}    
    .month-pill.unmet { background:linear-gradient(90deg,#fff6f6,#fff1f1); color:var(--red); border-color:rgba(212,107,107,0.08);}    
    .month-pill.equal { background:linear-gradient(90deg,#f3eef9,#efe7f6); color:var(--purple); border-color:rgba(159,127,191,0.08); }
    .month-pill.next { background:linear-gradient(90deg,#e8f6f5,#f0faf9); color:#2a6c66; font-weight:400; border-color:rgba(74,141,133,0.2); box-shadow:0 6px 18px rgba(74,141,133,0.15); }
    .month-pill.next > div:first-child { font-style:italic; text-decoration:underline; }
    .month-pill:focus {
      outline: 2px solid var(--accent-2);
      outline-offset: 2px;
    }
    .month-pill:hover:not(.active) {
      background: var(--very-light-green);
      color: var(--accent);
    }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    button { padding:8px 10px; border-radius:8px; border:none; cursor:pointer; font-weight:600; color:white; background:var(--accent); box-shadow:0 6px 14px rgba(74,141,133,0.08); transition: transform 0.2s ease, box-shadow 0.2s ease; }
    button:hover { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(74,141,133,0.12); }
    button.ghost { background:transparent; color:var(--accent); border:1px solid rgba(74,141,133,0.12); box-shadow:none; }
    button.warn { background:var(--red); }
    button.green { background:var(--green); }
    button.small { padding:6px 8px; font-size: 14px; }
    button#btnExportExcel, button#btnImportExcel { background: var(--very-light-green); color: var(--text-bold); border: 1px solid rgba(111,174,117,0.2); }
    button:focus {
      outline: 2px solid var(--accent-2);
      outline-offset: 2px;
    }

    /* Star icon next to the year input */
    .title-star {
      font-size: 22px;
      margin-left: 4px;
      color: var(--accent);
      user-select: none;
      display: inline-flex;
      align-items: center;
    
  margin-top: -12px;
  vertical-align: middle;
}
    /* Raise the year input slightly to align with the title */
    #yearInput {
      margin-top: -8px;
    }
    #chartCard { padding:12px; }
    #chartWrapper { width:100%; height:360px; }
    .tableCard { margin-top:4px; padding:12px; }
    table { width:100%; border-collapse:collapse; margin-top: 6px; font-size: 14px; border-radius:8px; overflow:hidden; }
    thead th { text-align:center; background:linear-gradient(180deg,#fbfdfc,#f1f7f6); padding:10px; color:var(--text-bold); font-weight:700; border-bottom:1px solid rgba(15,48,40,0.06); border-right: 1px solid var(--light-gray); position: sticky; top: 0; z-index: 2;}
    th.notesCol { width:250px; }
    th.projectCol { width:150px; }
    th.smallCol { width:92px; }
    th.tinyCol { width:60px; }
    th.monthCol { width:100px; }
    tbody td { text-align:center; padding:10px; border-bottom:1px dashed rgba(15,48,40,0.04); vertical-align:middle; border-right: 1px solid var(--light-gray); }
    td.editable { background:#fbfdff; border-radius:6px; cursor:text; min-width:120px; }
    td.expected { background: var(--very-light-blue); }
    td.expected::before { content: "✨ "; }
    td.gray { color:var(--muted); font-size: 14px; }
    td.project { background:#fbfdff; border-radius:6px; cursor:text; min-width:120px; }
    tfoot th { text-align:center; padding:10px; background:#fbfdff; }
    tfoot td { text-align:center; border-right: 1px solid var(--light-gray); }
    .iconBtn { background:transparent; color:var(--muted); border:1px solid rgba(0,0,0,0.04); padding:6px 8px; border-radius:8px; cursor:pointer; font-size: 14px; }
    .tableCard tbody tr:hover {
      background: var(--very-light-green);
      transition: background .18s;
    }
    tbody td.variance-pos { color: var(--green); font-weight: 600; }
    tbody td.variance-neg { color: var(--red); font-weight: 600; }
    tbody td.variance-zero { color: var(--muted); }
    tbody td.accum-pos { background: #eaf6ee; color: var(--green); font-weight: 600; }
    tbody td.accum-neg { background: #fff6f6; color: var(--red); font-weight: 600; }
    tbody td.accum-zero { background: #f3eef9; color: var(--purple); font-weight: 600; }
    .heatmapRow { display:flex; gap:6px; margin-top:-2px; align-items:center; }
    .heatCell { flex:1; height:10px; border-radius:6px; }
  .modal { display:none; position:fixed; left:50%; top:50%; transform:translate(-50%,-46%); background:white; padding:14px; z-index:9999; border-radius:10px; box-shadow:0 18px 50px rgba(10,40,80,0.14); width:380px; }
    /* Override: keep modals constrained and use box-sizing so padding doesn't increase visual width */
    #dateModal, #notesModal, #projectModal {
      box-sizing: border-box !important;
      max-width: 420px !important;
      width: 92vw !important;
      padding: 12px !important;
      max-height: 80vh !important;
      overflow: auto !important;
    }
    .modal.visible { display:block; }
  .modal::before { content: ''; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.22); z-index: -1; }
    .close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      font-size: 26px;
      cursor: pointer;
      color: var(--muted);
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s, color 0.2s;
    }
    .close-btn:hover {
      background-color: rgba(0,0,0,0.1);
      color: var(--text);
    }
    .ai-analysis-modal { width: 700px; max-width: 90vw; max-height: 80vh; }
    .ai-analysis-modal pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; }

    /* Enhanced modal inner styling */
    .ai-modal-inner {
      padding: 20px;
      border-radius: 12px;
      background: #ffffff;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    }

    /* AI modal header layout: title left, timestamp right */
    .ai-modal-header { display:flex; align-items:flex-start; justify-content:space-between; gap:12px; width:100%; margin-bottom: 16px; }
    .ai-modal-header h3 { margin:0; font-size: 19px; font-weight:600; color: #2c3e50; }
    .ai-modal-header .ts { color:var(--muted); font-size: 14px; text-align:right; white-space:nowrap; }

    /* Enhanced content area */
    .ai-analysis-modal pre {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #e9ecef;
      font-family: 'Poppins', sans-serif;
      font-size: 15px;
      line-height: 1.5;
      color: #495057;
      max-height: 50vh;
      overflow-y: auto;
    }

    /* Enhanced sharing buttons layout - Ultra Compact & Plain */
  .sharing-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
  align-items: center;
  margin-top: 29mm;
  padding: 10px 12px;
  background: rgba(255,255,255,0.96);
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,0.06);
  box-shadow: 0 10px 30px rgba(10,40,80,0.10);
  backdrop-filter: blur(3px);
  max-width: 420px;
  margin-left: auto;
  margin-right: auto;
  flex-wrap: nowrap;
  overflow-x: auto;
    }

    /* Premium button styles for sharing - Ultra Small & Plain */
  .ai-analysis-modal .ghost {
  transition: color 0.18s ease, transform 0.18s ease;
  position: relative;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 15px;
  font-weight: 400;
  background: transparent;
  border: none;
  color: #2b3b3b;
  cursor: pointer;
  overflow: visible;
  text-transform: none;
  letter-spacing: 0.1px;
  min-width: 56px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
    }



    .ai-analysis-modal .ghost:hover {
      transform: translateY(-2px);
      color: #0b66a3;
      text-decoration: none;
      text-shadow: 0 1px 6px rgba(11,102,163,0.08);
      filter: drop-shadow(0 6px 18px rgba(10,40,80,0.06));
    }

    .ai-analysis-modal .ghost:active {
      transform: translateY(0px);
      color: #064a73;
    }

    .ai-analysis-modal .ghost:focus {
      outline: 3px solid rgba(11,102,163,0.12);
      outline-offset: 2px;
      border-radius: 6px;
    }

    /* All buttons now use the same plain styling */



    /* Scenario Planning Styles */
    .scenario-controls {
      padding: 16px 0;
    }
    .scenario-section {
      margin-bottom: 24px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e9ecef;
    }
    .scenario-section h4 {
      margin: 0 0 16px 0;
      color: #495057;
      font-size: 17px;
      font-weight: 600;
    }
    .scenario-metrics, .scenario-results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .metric-item, .result-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: white;
      border-radius: 6px;
      border: 1px solid #dee2e6;
    }
    .metric-item label, .result-item label {
      font-weight: 500;
      color: #6c757d;
    }
    .scenario-inputs {
      display: grid;
      gap: 16px;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .input-group label {
      font-weight: 500;
      color: #495057;
    }
    .input-group input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #dee2e6;
      outline: none;
    }
    .input-group input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
    }
    .input-group span {
      font-weight: 600;
      color: #007bff;
      text-align: center;
    }

    /* Heat Map Styles */
    .heatmap-container {
      padding: 16px 0;
    }
    .heatmap-legend {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #6c757d;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }
    .performance-heatmap {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      gap: 8px;
      max-width: 600px;
      margin: 20px auto;
      padding: 10px;
    }
    .heatmap-cell {
      min-height: 60px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      user-select: none;
      overflow: hidden;
      animation: heatmapCellFadeIn 0.6s ease-out both;
    }
    .heatmap-cell::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }
    .heatmap-cell:hover::before {
      left: 100%;
    }
    .heatmap-cell:hover {
      transform: translateY(-4px) scale(1.08);
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .heatmap-cell:active {
      transform: translateY(-2px) scale(1.05);
    }
    .heatmap-cell .cell-month {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 2px;
      transition: all 0.2s ease;
    }
    .heatmap-cell .cell-value {
      font-size: 15px;
      font-weight: 700;
      transition: all 0.2s ease;
    }
    .heatmap-cell:hover .cell-month {
      opacity: 1;
      transform: scale(1.1);
    }
    .heatmap-cell:hover .cell-value {
      transform: scale(1.15);
    }

    @keyframes heatmapCellFadeIn {
      0% {
        opacity: 0;
        transform: translateY(20px) scale(0.8);
      }
      50% {
        opacity: 0.7;
        transform: translateY(-5px) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    .heatmap-cell .cell-tooltip {
      position: fixed;
      background: rgba(28, 33, 38, 0.96);
      color: #f5f8fb;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      font-size: 14px;
      line-height: 1.4;
      white-space: nowrap;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(8px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: none;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .heatmap-cell .cell-tooltip::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid rgba(28, 33, 38, 0.96);
    }
    .heatmap-cell .tooltip-header {
      font-weight: 700;
      font-size: 15px;
      margin-bottom: 8px;
      color: #ffd700;
      text-align: center;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 6px;
    }
    .heatmap-cell .tooltip-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .heatmap-cell .tooltip-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .heatmap-cell .tooltip-label {
      color: #ccc;
      font-weight: 500;
      min-width: 60px;
    }
    .heatmap-cell .tooltip-value {
      font-weight: 600;
      text-align: right;
    }
    .heatmap-cell .tooltip-value.positive {
      color: #4CAF50;
    }
    .heatmap-cell .tooltip-value.negative {
      color: #F44336;
    }
    .heatmap-cell .tooltip-status {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
      text-align: center;
      font-weight: 600;
    }
    .heatmap-cell .status-text.excellent {
      color: #4CAF50;
    }
    .heatmap-cell .status-text.good {
      color: #8BC34A;
    }
    .heatmap-cell .status-text.moderate {
      color: #FFC107;
    }
    .heatmap-cell .status-text.concern {
      color: #FF9800;
    }
    .heatmap-cell .status-text.critical {
      color: #F44336;
    }

    /* Toast notification styles */
    .toast-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      font-size: 15px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      max-width: 300px;
      word-wrap: break-word;
    }
    .toast-notification.show {
      opacity: 1;
      transform: translateY(0);
    }
    .toast-notification.error {
      background: #dc3545;
    }
    .toast-notification.info {
      background: #17a2b8;
    }
    input[type="date"], textarea, input[type="text"] { width:100%; padding:8px; border-radius:8px; border:1px solid #dfe7e4; margin-top:-2px; font-size: 15px; }
    select#ownerSelect {
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(74,141,133,0.3);
  background: var(--card);
  color: var(--text);
  font-size: 13px;
  width: auto;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  appearance: auto;
  cursor: pointer;
}
    select#ownerSelect:focus { outline:2px solid var(--accent-2); }
    .nextAlert { margin-top:-2px; padding:10px; border-radius:8px; display:flex; justify-content:space-between; align-items:center; gap:12px; background: var(--light-gray); border:1px solid rgba(74,141,133,0.06); }
    .nextAlert #nextText { font-size: 15px; font-weight: normal; color: var(--orange-red-flag); }
    .nextAlert #nextMonthPill { font-size: 15px; font-weight: normal; color: var(--orange-red-flag); }
    .nextAlert #nextDays { font-size: 15px; font-weight: normal; color: var(--orange-red-flag); }
    .nextAlert #nextText::before { content: "🚩 "; }
    /* When there is a shortage, emphasise the alert with a subtle red tint */
    .nextAlert.shortage {
      background: linear-gradient(180deg,#fff7f7,#fff2f2);
      border: 1px solid rgba(212,107,107,0.18);
    }
    .gaugeWrapper {
      position: relative;
      width: 135px;
      height: 120px;
      margin-bottom: 0;
    }
    .gaugeText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-58%, -28%);
      text-align: center;
      font-size: 10.705px;
      color: var(--text-bold);
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .gaugeText .month {
      font-size: 10.5px; margin-bottom: 8px;
     margin-bottom:-3px;}
    .gaugeText .arrow {
      font-size: 6.000px;
      line-height: 1;
      margin: 2px 0;
     display:none;}
    .gaugeText .amount {
      font-size: 22.0px;
      color: var(--orange-red-flag);
    }
    @media (max-width:980px){
      .top { grid-template-columns: 1fr; }
      #chartWrapper { height:300px; }
    }
    @media (max-width:700px){
      .card, .tableCard { padding: 8px; }
      .top { gap: 6px; }
      .months-mini { gap: 4px; }
      select#ownerSelect {
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(74,141,133,0.3);
  background: var(--card);
  color: var(--text);
  font-size: 13px;
  width: auto;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  appearance: auto;
  cursor: pointer;
}
      .gaugeWrapper { width: 112.5px; height: 90px; margin-bottom: 0; }
      .gaugeText { font-size: 10.89px; transform: translate(-58%, -28%); }
      .gaugeText .month { font-size: 10.7px; margin-bottom: 8px;  margin-bottom:-3px;}
      .gaugeText .arrow { font-size: 7px;  display:none;}
      .gaugeText .amount { font-size: 22.0px; }
    }
    .muted { color:var(--muted); }
    .center { text-align:center; }
    .tiny { font-size: 13px; color:var(--muted); }
    .pill { padding:6px 8px; border-radius:999px; background:rgba(0,0,0,0.03); font-weight:700; }
    .trendUp { color:var(--green); }
    .trendDown { color:var(--red); }
    body.dark thead th { background: linear-gradient(180deg, #202428, #1a1e22); }
    body.dark tfoot th { background: #1a1e22; }
    body.dark .progressBar.bar { background: linear-gradient(180deg, #202428, #1a1e22); }
    body.dark .month-pill { background: rgba(30,35,40,0.9); border-color: rgba(255,255,255,0.04); box-shadow:0 6px 14px rgba(0,0,0,0.1); }
    body.dark .month-pill.met { background: linear-gradient(90deg, #1e2a22, #242f28); }
    body.dark .month-pill.unmet { background: linear-gradient(90deg, #2a1e1e, #2f2424); }
    body.dark .month-pill.equal { background: linear-gradient(90deg, #261e2a, #2c242f); }
    body.dark .month-pill.next { background: linear-gradient(90deg, #1e2a28, #242f2d); }
    body.dark .nextAlert { background: #2e2e2e; }
    body.dark .nextAlert #nextText { color: var(--orange-red-flag); }
    body.dark .nextAlert #nextMonthPill { color: var(--orange-red-flag); }
    body.dark .nextAlert #nextDays { color: var(--orange-red-flag); }
    body.dark .nextAlert.shortage {
      background: linear-gradient(180deg,#2c1e1e,#271a1a);
      border: 1px solid rgba(212,107,107,0.3);
    }

    body.dark .editable { background: #1e2226; }
    body.dark .project { background: #1e2226; }
    body.dark select#ownerSelect {
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(74,141,133,0.3);
  background: var(--card);
  color: var(--text);
  font-size: 13px;
  width: auto;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  appearance: auto;
  cursor: pointer;
}
    body.dark .progressValue { background: rgba(90,160,150,0.1); }
    body.dark .tooltip { background: var(--card); color: var(--text); }

    body.dark .fillRed { background: linear-gradient(90deg, var(--red), #e58a8a); }
    body.dark .gaugeText { color: var(--text-bold); }
    body.dark .gaugeText .amount { color: var(--orange-red-flag); }
    .editable-bf { background:#fbfdff; border-radius:6px; cursor:text; padding:2px 4px; }
    body.dark .editable-bf { background: #1e2226; }
  
  /* === Styled hover tooltip === */
  .__tip {
    position: fixed;
    z-index: 99999;
    max-width: 360px;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(0,0,0,0.12);
    background: rgba(28, 33, 38, 0.96);
    color: #f5f8fb;
    box-shadow: 0 8px 24px rgba(0,0,0,0.18);
    pointer-events: none;
    font-size: 13px;
    line-height: 1.4;
    white-space: pre-wrap;
    opacity: 0;
    transform: translateY(4px);
    transition: opacity .12s ease, transform .12s ease;
  }
.__tip {
  color: #fff !important;
}
.__tip .__label {
  color: #ffd700 !important;
}

  .__tip.__on {
    opacity: 1;
    transform: translateY(0);
  }
  .__tip .__label {
    display: block;
    font-weight: 700;
    margin-bottom: 4px;
    opacity: .9;
  }



#ownerNameDisplay {
  font-family: "Poppins", sans-serif;
  font-weight: 700;
  font-size: 41px;
  background: linear-gradient(270deg, #4a8d85, #9f7fbf, #e3b04b, #6fae75);
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: gradientShift 8s ease infinite;
  text-shadow: 0 0 10px rgba(74, 141, 133, 0.4), 0 0 20px rgba(159, 127, 191, 0.3);
  letter-spacing: 1px;
  transition: transform 0.6s ease, text-shadow 0.6s ease;
}
#ownerNameDisplay:hover {
  transform: scale(1.08);
  text-shadow: 0 0 15px rgba(74, 141, 133, 0.6), 0 0 30px rgba(159, 127, 191, 0.5);
}
@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}



/* === Owner-specific name themes === */
.owner-name {
  display: inline-block;
  transition: transform 0.6s ease, filter 0.6s ease;
}
.owner-name:hover { transform: translateY(-1px) scale(1.03); }

/* Theme 1: Emerald → Gold */
.owner-theme-1.owner-name {
  font-family: "Poppins", sans-serif;
  background: linear-gradient(270deg, #49c09c, #e3b04b);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 8s ease infinite;
  text-shadow: 0 0 14px rgba(73, 192, 156, 0.35);
}

/* Theme 2: Azure → Purple */
.owner-theme-2.owner-name {
  font-family: "Rubik", sans-serif;
  background: linear-gradient(270deg, #4da3ff, #9f7fbf);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 9s ease infinite;
  text-shadow: 0 0 14px rgba(77, 163, 255, 0.35);
}

/* Theme 3: Sunset (Orange → Pink) */
.owner-theme-3.owner-name {
  font-family: "Quicksand", sans-serif;
  background: linear-gradient(270deg, #ff7a18, #ff3c7b);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 7s ease infinite;
  text-shadow: 0 0 14px rgba(255, 122, 24, 0.35);
}

/* Theme 4: Royal (Blue → Indigo) */
.owner-theme-4.owner-name {
  font-family: "Playfair Display", serif;
  letter-spacing: 0.5px;
  background: linear-gradient(270deg, #2653ff, #4000a3);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 10s ease infinite;
  text-shadow: 0 0 14px rgba(38, 83, 255, 0.35);
}

/* Theme 5: Mint → Teal */
.owner-theme-5.owner-name {
  font-family: "Poppins", sans-serif;
  background: linear-gradient(270deg, #b3ffd6, #3bc8a2);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 8s ease-in-out infinite;
  text-shadow: 0 0 14px rgba(59, 200, 162, 0.35);
}

/* Theme 6: Rose → Plum */
.owner-theme-6.owner-name {
  font-family: "Rubik", sans-serif;
  background: linear-gradient(270deg, #ff98c6, #7a2e98);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 9s ease-in-out infinite;
  text-shadow: 0 0 14px rgba(122, 46, 152, 0.35);
}

/* Theme 7: Lime → Forest */
.owner-theme-7.owner-name {
  font-family: "Quicksand", sans-serif;
  background: linear-gradient(270deg, #c6ff6b, #0f834d);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 7.5s ease infinite;
  text-shadow: 0 0 14px rgba(15, 131, 77, 0.35);
}

/* Theme 8: Gold → Amber */
.owner-theme-8.owner-name {
  font-family: "Poppins", sans-serif;
  background: linear-gradient(270deg, #ffd36e, #ff9f0a);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 8.5s ease infinite;
  text-shadow: 0 0 14px rgba(255, 159, 10, 0.35);
}

/* Theme 9: Ice (Cyan → Blue) */
.owner-theme-9.owner-name {
  font-family: "Rubik", sans-serif;
  background: linear-gradient(270deg, #7de3ff, #2a72ff);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 8.5s ease infinite;
  text-shadow: 0 0 14px rgba(42, 114, 255, 0.35);
}

/* Theme 10: Fire (Red → Orange) */
.owner-theme-10.owner-name {
  font-family: "Quicksand", sans-serif;
  background: linear-gradient(270deg, #ff4d4f, #ff8f1f);
  background-size: 200% 200%;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  animation: gradientShift 7.5s ease infinite;
  text-shadow: 0 0 14px rgba(255, 79, 79, 0.35);
}


/* --- Force readable Owner dropdown --- */
select#ownerSelect {
  padding: 6px 10px !important;
  border-radius: 10px !important;
  border: 1px solid rgba(74,141,133,0.35) !important;
  background: var(--card) !important;
  color: var(--text) !important;
  font-size: 15px !important;
  width: auto !important;
  height: 30px !important;
  appearance: auto !important;
  cursor: pointer !important;
}


/* === Tiny faint owner toggle icon + dropdown popup behavior === */
.owner-container { position: relative; } /* ensure popup positions under icon */
.ownerToggleBtn {
  font-size: 14px;
  line-height: 1;
  padding: 2px 4px;
  border: 0;
  background: transparent;
  cursor: pointer;
  opacity: 0.9;              /* faint by default */
  transition: opacity .2s, transform .2s;
  color: var(--accent);
}
.ownerToggleBtn:hover { opacity: 0.9; transform: translateY(-1px); }

/* Hide the native select until icon is pressed */
#ownerSelect.owner-hidden{
  position: absolute;
  right: 0;
  top: calc(100% + 6px);
  opacity: 0;
  pointer-events: none;
  transform: translateY(-6px);
  transition: opacity .15s ease, transform .15s ease;
}
#ownerSelect.owner-show{
  position: absolute;
  right: 0;
  top: calc(100% + 6px);
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
  z-index: 1000;
}


#localDate {
  font-weight: normal !important;
  font-size: 11px !important;
}


/* Added spacing between month name and number in month cells */
.month-cell > div:first-child {
  margin-bottom: 4px; /* space under month name */
}
.month-cell > div:last-child {
  margin-top: 4px; /* space above the number */
}


/* Ensure clear gap between month name and value within .month-pill */
.month-pill > div:first-child { margin-bottom: 6px; }


/* === Hover fix for gaugeText === */
#gaugeChart { position: relative; z-index: 1; }
#gaugeText  { z-index: 2; pointer-events: auto; }




/* === Column title color "dot" (tiny faint style) === */
.colColorDot {
  width: 8px;
  height: 8px;
  padding: 0;
  margin: 0 4px 0 0;
  border: none;
  background: transparent;
  cursor: pointer;
  vertical-align: middle;
  appearance: none;
  -webkit-appearance: none;
  border-radius: 50%;
  outline: none;
  opacity: 0.9;
  transition: opacity .2s ease, transform .2s ease;
}
.colColorDot:hover {
  opacity: 0.9;
  transform: scale(1.3);
}
.colColorDot::-webkit-color-swatch-wrapper { padding: 0; }
.colColorDot::-webkit-color-swatch {
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 50%;
}
.colColorDot::-moz-color-swatch {
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 50%;
}
body.dark .colColorDot::-webkit-color-swatch,
body.dark .colColorDot::-moz-color-swatch {
  border-color: rgba(255,255,255,0.25);
}





/* === Combined shortage indicators (flag + corner badge) === */
.needTag {
  display: block;
  margin-top: 2px;
  font-size: 9px;
  color: #d9534f;   /* soft red */
  font-weight: 600;
}
body.dark .needTag { color: #ff8c66; }
.needBadge {
  position: absolute;
  top: 2px;
  right: 4px;
  background: #d9534f;
  color: white;
  font-size: 9px;
  font-weight: 600;
  padding: 1px 4px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}
body.dark .needBadge { background: #ff8c66; }


/* === Next Needed Target Flag (Clean Highlight) — override === */
.needTag, .needBadge {
  display: none !important;     /* hide old tag + badge */
}


td.next-needed-target {
  background: transparent;
  font-weight: 700;
  color: #d9534f;
  position: relative;
}
td.next-needed-target::after {
  content: "🚩";
  position: absolute;
  right: -18px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 15px;
}


/* === Header Next Needed Badge === */
.nextBadge{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  background: linear-gradient(90deg,#fff6f6,#fff1f1);
  border:1px solid rgba(212,107,107,0.25);
  box-shadow: 0 6px 14px rgba(212,107,107,0.12);
  font-size: 13px;
  margin-left:8px;
}
.nextBadge .label{ color:#a94442; font-weight:700; }
.nextBadge .pill{
  background:#fff;
  border:1px solid rgba(212,107,107,0.3);
  border-radius:999px;
  padding:2px 8px;
  font-weight:700;
  color:#a94442;
}
.nextBadge .amount{ font-weight:700; color:#d9534f; }
.nextBadge .days{ color:#a94442; font-weight:600; }
body.dark .nextBadge{
  background: linear-gradient(90deg,#2a1e1e,#2f2424);
  border-color: rgba(255,140,102,0.35);
  box-shadow: 0 6px 14px rgba(0,0,0,0.24);
}
td.next-needed-target {
  background: transparent;
  font-weight: 700;
  color: #d9534f;
  position: relative;
}
td.next-needed-target::after {
  content: "🚩";
  position: absolute;
  right: -18px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 15px;
}
@media print {
  .kpi-item + .kpi-item::after { background: linear-gradient(transparent 42%, rgba(0,0,0,0.18) 42%, rgba(0,0,0,0.18) 46%, transparent 46%, transparent 54%, rgba(0,0,0,0.18) 54%, rgba(0,0,0,0.18) 58%, transparent 58%); }
}
}
body.dark .nextBadge .label,
body.dark .nextBadge .pill,
body.dark .nextBadge .days{ color:#ff8c66; }
body.dark .nextBadge .amount{ color:#ff8c66; }


/* === Small controls under Next Needed badge === */
.smallControls{
  display:flex;
  gap:4px;
  margin-left:12px;
}
.smallControls button{
  font-size: 12px !important;
  padding:2px 4px !important;
  height:auto !important;
}


/* === Small Local/Saved under controls === */
.smallDate{
  font-size: 11px !important;
  opacity:0.9;
  margin-left:12px;
}


/* === Header top title section (moved up) === */
.headerTop{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.headerTop .title-left h1{
  font-size: 24px;
  margin:0;
  color:var(--accent);
}
.headerTop .title-left p{
  margin:0;
  font-size: 9px;
  color:var(--muted);
}
.headerTop #yearInput{
  margin-left:8px;
}
.headerTop .owner-middle{
  margin-left:auto;
}


/* === Full header reflow === */
.headerTopFull{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px;
  margin-bottom:8px;
}
.headerTopFull .title-left{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
}
.headerTopFull .title-left h1{
  font-size: 24px;
  margin:0;
  color:var(--accent);
}
.headerTopFull .title-left p{
  margin:0;
  font-size: 9px;
  color:var(--muted);
}
.headerTopFull .owner-middle{
  display:flex;
  justify-content:flex-start;
  align-items:center;
  gap:8px;
}


/* === Enhanced upper header ribbon with premium effects & animations === */
header{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:6px;
  background: 
    linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(248,252,255,0.95) 50%, rgba(245,250,255,0.97) 100%),
    radial-gradient(circle at 20% 50%, rgba(74,141,133,0.04) 0%, transparent 50%),
    radial-gradient(circle at 80% 30%, rgba(111,174,117,0.03) 0%, transparent 50%);
  backdrop-filter: blur(25px) saturate(1.2);
  border-radius: 0 0 28px 28px;
  box-shadow: 
    0 12px 40px rgba(74,141,133,0.12),
    0 4px 16px rgba(0,0,0,0.06),
    0 1px 4px rgba(0,0,0,0.04),
    inset 0 2px 0 rgba(255,255,255,0.8),
    inset 0 -1px 0 rgba(74,141,133,0.08);
  border: 1px solid rgba(255,255,255,0.4);
  border-top: none;
  margin: 0 -20px 20px -20px;
  padding: 20px 20px 24px 20px;
  position: relative;
  overflow: hidden;
  transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  animation: headerFloat 8s ease-in-out infinite;
}

header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, 
    var(--accent) 0%, 
    var(--green) 25%, 
    var(--gold) 50%, 
    var(--purple) 75%, 
    var(--accent) 100%);
  background-size: 200% 100%;
  animation: gradientShift 4s ease-in-out infinite;
}

header::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 5px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    var(--accent) 20%, 
    var(--green) 40%, 
    var(--gold) 60%, 
    var(--accent) 80%, 
    transparent 100%);
  border-radius: 3px;
  opacity: 0.9;
  animation: pulseGlow 3s ease-in-out infinite;
}

/* Floating particles effect */
header .floating-particles {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 1;
}

header .particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: radial-gradient(circle, var(--accent) 0%, transparent 70%);
  border-radius: 50%;
  opacity: 0;
  animation: floatParticle 6s ease-in-out infinite;
}

header .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
header .particle:nth-child(2) { left: 30%; animation-delay: 1s; }
header .particle:nth-child(3) { left: 50%; animation-delay: 2s; }
header .particle:nth-child(4) { left: 70%; animation-delay: 3s; }
header .particle:nth-child(5) { left: 90%; animation-delay: 4s; }

.headerTopFull{
  display:flex;
  flex-direction:column;
  align-items:center;
  text-align:center;
  gap:4px;
  position: relative;
  z-index: 2;
}

/* === Premium Header Animations === */
@keyframes headerFloat {
  0%, 100% { 
    transform: translateY(0) scale(1);
    box-shadow: 
      0 12px 40px rgba(74,141,133,0.12),
      0 4px 16px rgba(0,0,0,0.06),
      0 1px 4px rgba(0,0,0,0.04),
      inset 0 2px 0 rgba(255,255,255,0.8),
      inset 0 -1px 0 rgba(74,141,133,0.08);
  }
  50% { 
    transform: translateY(-2px) scale(1.005);
    box-shadow: 
      0 20px 50px rgba(74,141,133,0.15),
      0 8px 20px rgba(0,0,0,0.08),
      0 2px 8px rgba(0,0,0,0.06),
      inset 0 3px 0 rgba(255,255,255,0.9),
      inset 0 -2px 0 rgba(74,141,133,0.12);
  }
}

// Inline Poppins fonts (fetch Google Fonts CSS, fetch woff2, embed as base64 @font-face)
async function inlinePoppinsFonts(){
  try{
    if (window._poppinsInlined) return;
    // find the Poppins Google Fonts link on the page
    var link = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).find(l=>/fonts.googleapis.com\/css2.*Poppins/.test(l.href));
    if (!link) return;
    var cssText = await fetch(link.href, {cache: 'no-store'}).then(r=>r.text());
    // extract @font-face blocks
    var faces = cssText.match(/@font-face\s*\{[^}]*\}/g) || [];
    var out = '';
    for (var i=0;i<faces.length;i++){
      var b = faces[i];
      var mW = b.match(/font-weight:\s*(\d+)/);
      var mUrl = b.match(/url\((https?:\\/\\/[^)]+)\)/);
      if (!mUrl) continue;
      var w = mW ? mW[1] : '400';
      var url = mUrl[1];
      try{
        var resp = await fetch(url, {cache: 'no-store'});
        var buf = await resp.arrayBuffer();
        // convert to base64
        var bytes = new Uint8Array(buf);
        var chunk = 65536;
        var bin = '';
        for (var j=0; j<bytes.length; j+=chunk){
          bin += String.fromCharCode.apply(null, bytes.subarray(j, j+chunk));
        }
        var b64 = btoa(bin);
        out += "@font-face{font-family:'Poppins';font-style:normal;font-weight:"+w+";src:url(data:font/woff2;base64,"+b64+") format('woff2');font-display:swap;}\n";
      }catch(e){ console.warn('inlinePoppinsFonts: fetch failed for', url, e); }
    }
    if (out){
      var s = document.createElement('style');
      s.id = 'poppins-inlined';
      s.innerText = out;
      document.head.appendChild(s);
      // small delay to let browser register the fonts
      await new Promise(r=>setTimeout(r, 200));
      window._poppinsInlined = true;
    }
  }catch(e){ console.warn('inlinePoppinsFonts error', e); }
}

@keyframes gradientShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

@keyframes pulseGlow {
  0%, 100% { 
    opacity: 0.9; 
    transform: translateX(-50%) scale(1);
    filter: blur(0px);
  }
  50% { 
    opacity: 1; 
    transform: translateX(-50%) scale(1.1);
    filter: blur(1px);
  }
}

@keyframes floatParticle {
  0% { 
    opacity: 0; 
    transform: translateY(20px) scale(0);
  }
  20% { 
    opacity: 1; 
    transform: translateY(0px) scale(1);
  }
  80% { 
    opacity: 1; 
    transform: translateY(-20px) scale(1);
  }
  100% { 
    opacity: 0; 
    transform: translateY(-40px) scale(0);
  }
}

/* Header hover effects */
header:hover {
  transform: translateY(-3px) scale(1.01);
  box-shadow: 
    0 24px 60px rgba(74,141,133,0.18),
    0 12px 24px rgba(0,0,0,0.1),
    0 4px 12px rgba(0,0,0,0.08),
    inset 0 3px 0 rgba(255,255,255,0.95),
    inset 0 -2px 0 rgba(74,141,133,0.15);
}

header:hover::before {
  height: 5px;
  animation-duration: 2s;
}

header:hover::after {
  width: 120px;
  height: 6px;
  opacity: 1;
}

/* Shimmer effect overlay */
header .shimmer {
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255,255,255,0.4) 20%, 
    rgba(255,255,255,0.8) 50%, 
    rgba(255,255,255,0.4) 80%, 
    transparent 100%);
  transform: skewX(-25deg);
  animation: shimmerSweep 8s ease-in-out infinite;
  pointer-events: none;
}

@keyframes shimmerSweep {
  0% { left: -100%; }
  20% { left: 100%; }
  100% { left: 100%; }
}

/* Sparkling stars effect */
header .sparkle {
  position: absolute;
  width: 2px;
  height: 2px;
  background: linear-gradient(45deg, var(--gold), var(--accent));
  border-radius: 50%;
  opacity: 0;
  animation: sparkle 4s ease-in-out infinite;
  pointer-events: none;
}

header .sparkle:nth-child(1) { top: 20%; left: 15%; animation-delay: 0s; }
header .sparkle:nth-child(2) { top: 40%; left: 35%; animation-delay: 0.8s; }
header .sparkle:nth-child(3) { top: 60%; left: 65%; animation-delay: 1.6s; }
header .sparkle:nth-child(4) { top: 30%; left: 85%; animation-delay: 2.4s; }
header .sparkle:nth-child(5) { top: 70%; left: 25%; animation-delay: 3.2s; }

@keyframes sparkle {
  0%, 100% { 
    opacity: 0; 
    transform: scale(0) rotate(0deg);
  }
  50% { 
    opacity: 1; 
    transform: scale(1) rotate(180deg);
  }
}

/* Premium light beam effect */
header .light-beam {
  position: absolute;
  top: -50%;
  left: 50%;
  width: 2px;
  height: 200%;
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(255,255,255,0.8) 40%, 
    rgba(255,255,255,0.4) 60%, 
    transparent 100%);
  transform: translateX(-50%) rotate(15deg);
  opacity: 0;
  animation: lightBeam 6s ease-in-out infinite;
  pointer-events: none;
}

@keyframes lightBeam {
  0%, 90%, 100% { opacity: 0; }
  10%, 80% { opacity: 0.9; }
}
.headerTopFull .title-left{
  display:flex;
  flex-direction:column;
  align-items:center;
  text-align:center;
}
.headerTopFull .title-left h1{
  font-size: 28px;
  font-weight:700;
  margin:0;
  color: transparent;
  background: linear-gradient(135deg, var(--accent) 0%, var(--green) 50%, var(--gold) 100%);
  -webkit-background-clip: text;
  background-clip: text;
  text-shadow: 0 2px 4px rgba(74,141,133,0.1);
  letter-spacing: -0.5px;
}
.headerTopFull .title-left p{
  margin:8px 0 0 0;
  font-size: 13px;
  color:var(--muted);
  font-style: italic;
  opacity: 0.9;
  background: linear-gradient(90deg, var(--muted) 0%, var(--accent) 100%);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.headerTopFull .owner-middle{
  display:flex !important;
  justify-content:center !important;
  align-items:center !important;
  gap:8px !important;
  width:100%;
}
.right{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:6px;
}
.nextBadge{
  margin-left:0 !important;
}
.smallControls{
  margin-left:0 !important;
}
.smallDate{
  margin-left:0 !important;
  text-align:center;
  display:block;
}
/* tighten Year input next to star and owner */
#yearInput{ margin-top:0 !important; }
.title-star{ margin-top:0 !important; }


/* === Year beside Owner selector === */
.headerTopFull .owner-middle{
  display:flex !important;
  justify-content:center !important;
  align-items:center !important;
  gap:10px !important;
}
#yearInput{
  width:70px !important;
  padding:3px 4px !important;
  font-size: 14px !important;
}


/* === Align star beside Year + Owner === */
.headerTopFull .owner-middle .title-star{
  margin:0;
  font-size: 17px;
  color:var(--accent);
}


/* === Local/Saved above controls === */
.smallDate{
  margin:0 !important;
  text-align:center;
  display:block;
}


/* === Fix: General Notes width/overflow (keep within card) === */
#generalNotesCard, #generalNotes{ max-width:100%; }
#generalNotes{ box-sizing:border-box; width:100%; overflow-x:auto; }
.card, .card * { box-sizing:border-box; }
.wrap { overflow-x:hidden; }
/* === End Fix === */

/* Force-hide any remaining next-year preview bits inside the ribbon */
#nextYearPreview, .next-year-preview, #nextYearPreviewText { display:none !important; }

/* Force-hide any ribbon preview/note text area to avoid confusion */
#dashNextText { display:none !important; }

/* === Report styles (print-friendly) === */
#reportArea {
  display:none;
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  color: var(--text);
  padding: 16px;
  width: 800px; /* approx A4 width at 96dpi */
  background: white;
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.06);
}
#reportArea h2 { margin: 0 0 6px; font-size: 22px; }
#reportArea h3 { margin: 12px 0 6px; font-size: 17px; }
#reportArea .meta { font-size: 13px; color: #555; margin-bottom: 10px; }
#reportArea table { width: 100%; border-collapse: collapse; font-size: 13px; }
#reportArea th, #reportArea td { border: 1px solid #ddd; padding: 6px 8px; text-align: right; }
#reportArea th:first-child, #reportArea td:first-child { text-align: left; }
#reportArea tfoot td { font-weight: 700; }

/* Subtle subtitle under Monthly Performance */
#chartCard .subtitle, #chartCard div[style*="Target (line) vs Actual"] { opacity:0.95; }

/* Add comfortable spacing between Monthly Performance title and subtitle */
#chartCard > div:first-of-type > div:first-of-type {
  margin-bottom: 6px !important;
}

/* Make the subtitle under Monthly Performance as small as possible */
#chartCard div[style*="Target (line) vs Actual"] {
  font-size: 11px !important;
  opacity:0.95 !important;
  font-weight:400 !important;
}

/* === Print-friendly tweaks (injected) === */
@media print {
  button, .iconBtn, .smallControls, #ownerToggleBtn, #btnToggleView,
  #btnToggleFuture, #btnToggleAll, #btnImportExcel, #btnExportExcel {
    display: none !important;
  }
  * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
  body { margin: 0.5in !important; background: #fff !important; font-size: 13px !important; line-height: 1.4 !important; }
  .wrap { max-width: 100% !important; }
  .card { box-shadow: none !important; }
  #chartCard, .tableCard, #generalNotesCard, #reportArea { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
  #repAIAnalysis, #repGeneralNotes { font-size: 13px !important; line-height: 1.4 !important; margin: 8px 0 !important; }
  .report-page { padding: 15px !important; margin: 0 !important; }
}
#reportArea { page-break-before: always; }


/* === Toolbar & Report focus enhancements (injected) === */
.topToolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}
.topToolbar .spacer {
  flex: 1 1 auto;
  min-width: 12px;
}
@media (max-width: 700px){
  .topToolbar { gap: 6px; }
}
/* Focused Report mode: give more room to report */
body.reportOpen .top { display: none !important; }
body.reportOpen .tableCard { display: none !important; }
body.reportOpen #generalNotesCard { display: none !important; }
body.reportOpen #reportArea {
  display: block !important;
  max-width: 960px;
  width: calc(100% - 32px);
  margin: 12px auto !important;
  box-shadow: 0 8px 24px rgba(0,0,0,0.08);
}


/* === Style PDF/Print/Report buttons to match Import/Export (green with black font) === */
#btnExportPDF, #btnPrint, #btnGenerateReport {
  background: var(--very-light-green) !important;
  color: var(--text-bold) !important;
  border: 1px solid rgba(111,174,117,0.2) !important;
}


/* === Export mode: ensure form values render in PDF (inputs sometimes render blank) === */
body.__exporting input,
body.__exporting textarea,
body.__exporting select {
  visibility: hidden !important;
}
.exportClone {
  display: inline-block;
  white-space: pre-wrap;
  vertical-align: middle;
}


/* === Force Early Target number color (safe override) === */
#dashYearlyTarget { color: #00008B !important; }


.gaugeWrapper{position:relative;}
#gaugeMonthsOverlay{position:absolute;inset:0;pointer-events:none;}




/* === Year Progress label refined === */
.gaugeWrapper > .small {
  font-size: 9px;      /* smaller caption */
  margin-bottom: 2px;  /* keep gap */
  margin-top: -10px;   /* lift higher above circle */
  opacity: 0.9;       /* lighter */
  transform: translateX(-39px);
}


/* Keep big amounts tidy inside the inner circle */
.gaugeText .amount {
  display: inline-block;
  max-width: 75%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}


/* Hide legacy financial progress Chart.js gauge to prevent mixing */
#gaugeChart { display: none !important; opacity: 0 !important; }


/* Shift inner content inside circle upwards */
.inner-circle-content {
  position: relative;
  top: -20px; /* move up by 20px */
}


/* Shift inner written content (month/target/flag) upward by 20% relative to center */
.gaugeText {
  transform: translate(-50%, calc(-50% - 20%)) !important;
  top: 50% !important; /* keep centered baseline positioning */
  left: 50% !important;
}
/* Remove previous pixel-based shift if present */
.inner-circle-content { top: auto !important; }


/* Shift inner written content (month/target/flag) upward by 10% relative to center */
.gaugeText {
  transform: translate(-50%, calc(-50% - 10%)) !important;
  top: 50% !important;
  left: 50% !important;
}
.inner-circle-content { top: auto !important; }


/* Shift inner written content (month/target/flag) upward 10% and left 1mm */
.gaugeText {
  transform: translate(calc(-50% - 3.8px), calc(-50% - 10%)) !important;
  top: 50% !important;
  left: 50% !important;
}
.inner-circle-content { top: auto !important; }


/* Shift inner written content (month/target/flag) upward 10% and left 2mm */
.gaugeText {
  transform: translate(calc(-50% - 7.6px), calc(-50% - 10%)) !important;
  top: 50% !important;
  left: 50% !important;
}
.inner-circle-content { top: auto !important; }


/* === Month items with external Acc. Variance label === */
.months-mini, #monthsMini, [data-months-mini] { 
  display: grid; 
  grid-template-columns: repeat(6, 1fr); 
  gap: 8px; 
  justify-items: center; 
}
.month-item { display: flex; flex-direction: column; align-items: center; width: 64px; }
.month-item .month-pill { width: 100%; }
.acc-var-label { display: block; text-align: center; font-size: 11px; margin-top: 4px; line-height: 1.1; }
.acc-var-label.acc-neg { color: var(--orange-red-flag, #c0392b); }
.acc-var-label.acc-pos { color: var(--green, #2e7d32); }
.acc-var-label.acc-zero{ color: var(--muted, #6c757d); }


/* removed old margin rule */


/* Position ONLY the Next Target card lower without shifting layout */
#mainSection { position: relative !important; }
#nextTargetCard {
  position: absolute !important;
  top: 4cm !important;   /* down by exactly 1cm */
  left: 3cm !important;  /* shifted right by 2cm (total 3cm) */
  margin-top: 0 !important;
  z-index: 5;
}


/* ===== Next Target Card – subtle effects ===== */
#nextTargetCard {
  /* visual polish */
  background: rgba(255,255,255,0.92) !important;
  border-radius: 14px !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.10), 0 2px 8px rgba(0,0,0,0.06) !important;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);

  /* motion */
  transition: transform .22s ease, box-shadow .22s ease, filter .22s ease, opacity .22s ease;
  animation: ntc-entry .55s cubic-bezier(.17,.67,.3,1) both, ntc-float 6s ease-in-out infinite;
}

/* Hover lift + stronger shadow */
#nextTargetCard:hover {
  transform: translateY(-3px) scale(1.015);
  box-shadow: 0 16px 36px rgba(0,0,0,0.14), 0 4px 12px rgba(0,0,0,0.08) !important;
}

/* Soft highlight ring */
#nextTargetCard::before {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 16px;
  pointer-events: none;
  background: radial-gradient(120px 60px at 20% 10%, rgba(74,141,133,0.18), transparent 60%),
              radial-gradient(100px 60px at 80% 90%, rgba(227,176,75,0.18), transparent 60%);
  opacity: .65;
  filter: blur(0.2px);
}

/* Light shimmer pass every ~12s */
#nextTargetCard::after {
  content: "";
  position: absolute;
  top: 0; left: -150%;
  width: 120%;
  height: 100%;
  border-radius: 14px;
  background: linear-gradient(100deg, transparent 30%, rgba(255,255,255,0.22) 50%, transparent 70%);
  transform: skewX(-15deg);
  animation: ntc-shimmer 12s ease-in-out infinite;
  pointer-events: none;
}

/* Keyframes */
@keyframes ntc-entry {
  0%   { opacity: 0; transform: translateY(8px) scale(0.985); }
  100% { opacity: 1; transform: translateY(0)   scale(1); }
}
@keyframes ntc-float {
  0%,100% { transform: translateY(0); }
  50%     { transform: translateY(-2px); }
}
@keyframes ntc-shimmer {
  0%   { left: -150%; opacity: 0; }
  8%   { left: 120%;  opacity: .55; }
  16%  { left: 120%;  opacity: 0; }
  100% { left: 120%;  opacity: 0; }
}

/* Dark mode tuning */
body.dark #nextTargetCard {
  background: rgba(28,32,36,0.88) !important;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45), 0 2px 8px rgba(0,0,0,0.35) !important;
}
body.dark #nextTargetCard::before {
  background: radial-gradient(120px 60px at 20% 10%, rgba(90,160,150,0.25), transparent 60%),
              radial-gradient(100px 60px at 80% 90%, rgba(255,140,0,0.22), transparent 60%);
}


/* first item emphasis + toggle */
#nextYearTargetCard .topline { font-weight: 700; }
#nextYearTargetCard .toggle { display:inline-block; margin-top:6px; font-size: 12px; opacity:.8; cursor:pointer; text-decoration:underline; }
#nextYearTargetCard .countchip { font-size: 12px; opacity:.75; margin-left:6px; }

.neg { color: red; font-weight: 600; }
</style>
<style id="repAI-hider">
  /* prevent any inline <hr> from showing inside the AI analysis area */
  #repAIAnalysis hr { display: none !important; }
</style>
<style id="repAI-pseudo-hide">
  /* Hide decorative pseudo-elements and accidental borders/shadows inside the analysis area */
  #repAIAnalysis *::before, #repAIAnalysis *::after { display: none !important; content: none !important; }
  #repAIAnalysis * { border-top: none !important; box-shadow: none !important; background-image: none !important; }
</style>
<script>
(function(){
  try {
    if (!window.currentYear) window.currentYear = (new Date()).getFullYear();
    if (typeof window.getStorageKey === 'function') {
      window.storageKey = window.getStorageKey(window.currentYear);
    }
  } catch(e){ console.warn('per-year header confirm:', e); }
})();
</script>
<!-- Robust General Notes Share (fallback) -->
<script>
(function(){
  // Prevent the default attachGeneralNotesShare from running later
  // by marking __attachGeneralNotesShare as true early.  The later injected
  // handler checks this flag and aborts when present, so setting it here
  // ensures only this robust implementation is used.
  try {
    if (typeof window !== 'undefined') {
      window.__attachGeneralNotesShare = true;
    }
  } catch(_){ /* ignore */ }
  function initRobustGeneralNotesShare(){
    try {
      var card = document.getElementById('generalNotesCard');
      if (!card) return;
      var header = card.querySelector(':scope > div:first-child') || card;
      if (!header) return;
      // Remove any pre-existing share icons on general notes to avoid duplicates
      header.querySelectorAll('.share-icon').forEach(function(ic){ ic.remove(); });
      // Create share icon
      var icon = document.createElement('span');
      icon.className = 'share-icon';
      icon.setAttribute('data-role','gn-share-robust');
      icon.title = 'Share general notes';
      icon.textContent = '↗';
      icon.style.cursor = 'pointer';
      header.appendChild(icon);
      icon.addEventListener('click', function(ev){
        ev.stopPropagation();
        try { document.querySelectorAll('.month-pop').forEach(function(n){ n.remove(); }); } catch(_){}
        // Determine owner using multiple fallbacks
        var owner = '';
        var ownerNameEl = document.getElementById('ownerNameDisplay');
        if (ownerNameEl && ownerNameEl.textContent && ownerNameEl.textContent.trim()) {
          owner = ownerNameEl.textContent.trim();
        } else {
          var ownerSel = document.getElementById('ownerSelect');
          if (ownerSel) {
            var selIdx = ownerSel.selectedIndex;
            owner = (selIdx >= 0 && ownerSel.options[selIdx]) ? ownerSel.options[selIdx].text : ownerSel.value;
          } else if (window.currentOwner && window.owners && window.owners[window.currentOwner]) {
            owner = window.owners[window.currentOwner].name || window.currentOwner;
          } else {
            owner = 'Owner';
          }
        }
        // Determine year
        var year = '';
        var yearFancy = document.getElementById('yearFancy');
        var yearInput = document.getElementById('yearInput');
        var ytxt = '';
        if (yearFancy && yearFancy.textContent) {
          ytxt = yearFancy.textContent.trim();
        } else if (yearInput && yearInput.value) {
          ytxt = yearInput.value.trim();
        }
        year = ytxt.replace(/\D+/g,'') || ('' + new Date().getFullYear());
        var title = owner + ' — ' + year + ' • General Notes';
        var notesEl = document.getElementById('generalNotes');
        var note = notesEl ? (notesEl.value || '').trim() : '';
        var kv = [[ 'Notes', note || '—' ]];
        var pop;
        if (typeof buildCard === 'function') {
          pop = buildCard(title, kv);
        } else {
          pop = document.createElement('div');
          pop.className = 'month-pop';
          pop.style.position = 'fixed';
          pop.style.zIndex = 9999;
          pop.style.background = 'var(--card-bg, #fff)';
          pop.style.border = '1px solid rgba(0,0,0,0.1)';
          pop.style.borderRadius = '10px';
          pop.style.boxShadow = '0 6px 24px rgba(0,0,0,0.15)';
          pop.style.padding = '12px';
          var h = document.createElement('h4'); h.textContent = title; pop.appendChild(h);
          var d = document.createElement('div'); d.textContent = note || '—'; pop.appendChild(d);
        }
        document.body.appendChild(pop);
        if (typeof positionPopover === 'function') positionPopover(pop, icon);
        if (typeof wireActions === 'function') wireActions(pop, title, kv);
        // PNG export: capture minimal card
        var btnPNG = pop.querySelector('.png');
        if (btnPNG && window.html2canvas) {
          btnPNG.addEventListener('click', async function() {
            try {
              var temp = document.createElement('div');
              temp.style.cssText = 'padding:16px;background:#fff;color:#000;max-width:520px;border:1px solid #eee;border-radius:8px;white-space:pre-wrap;';
              temp.innerHTML = '<div style="font-weight:700;margin-bottom:8px;">' + title + '</div><div>' + (note || '—').replace(/\n/g,'<br>') + '</div>';
              document.body.appendChild(temp);
              var canvas = await window.html2canvas(temp, { backgroundColor:'#ffffff', scale:2 });
              document.body.removeChild(temp);
              var a = document.createElement('a');
              a.download = (owner + '_' + year + '_General_Notes.png').replace(/\s+/g,'_');
              a.href = canvas.toDataURL('image/png');
              a.click();
            } catch(e) {}
          }, { once:true });
        }
      });

      // Observe mutations on the general notes card to re-attach the share icon if content changes
      if (window.MutationObserver) {
        var mo = new MutationObserver(function(){
          try { initRobustGeneralNotesShare(); } catch(_){}
        });
        mo.observe(card, { childList:true, subtree:true });
      }
    } catch(e){}
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initRobustGeneralNotesShare);
  } else {
    initRobustGeneralNotesShare();
  }
})();
</script>
<!-- Monthly Notes Logic -->
<script>
/*
 * Dynamic Monthly Notes widget
 *
 * This script adds a modal with a text area for each month. Notes are stored in
 * localStorage keyed by owner and year to avoid cross-owner leakage. A small
 * header displays the generation timestamp and there are Copy/Export/Close
 * buttons. Copy writes a plain-text summary to the clipboard, Export saves
 * notes back to localStorage.
 */
(function(){
  const notesMonthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  function getNotesStorageKey() {
    // Determine owner identifier
    const owner = (typeof currentOwner !== 'undefined' ? currentOwner : (window.currentOwner || 'OWNER'));
    const yearInputEl = document.getElementById('yearInput');
    const year = (yearInputEl && yearInputEl.value) || window.currentYear || new Date().getFullYear();
    return `monthlyNotes:${owner}:${year}`;
  }

  function loadMonthlyNotes() {
    try {
      const key = getNotesStorageKey();
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : {};
    } catch(e) {
      console.warn('Error loading monthly notes', e);
      return {};
    }
  }

  function saveMonthlyNotes(data) {
    try {
      const key = getNotesStorageKey();
      localStorage.setItem(key, JSON.stringify(data));
    } catch(e) {
      console.warn('Error saving monthly notes', e);
    }
  }

  // Expose the modal opener globally so other scripts can call it
  window.openMonthlyNotesModal = function() {
    const modal = document.getElementById('monthlyNotesModal');
    if (!modal) return;
    const grid = modal.querySelector('#notesGrid');
    const ts   = modal.querySelector('#notesTs');
    const stored = loadMonthlyNotes();
    // Build month note cards with per-month share arrows
    grid.innerHTML = notesMonthNames.map((m,i) => {
      const val = stored[i] || '';
      return `<div class="card" style="padding:10px;">
        <div style="font-weight:700; color:#2c3e50; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center;">
          <span>${m}</span>
          <span class="note-share" data-idx="${i}" title="Share ${m} note" style="cursor:pointer; user-select:none;">↗</span>
        </div>
        <textarea data-month="${i}" rows="6" placeholder="Write your note for ${m}…" style="width:100%; resize:vertical; border:1px solid #e1e6ea; border-radius:6px; padding:8px; background:white;">${val}</textarea>
      </div>`;
    }).join('');
    if (ts) ts.textContent = new Date().toLocaleString('en-GB');
    modal.classList.add('visible');
    
    // Set up handlers
    const closeBtn = document.getElementById('notesClose');
    if (closeBtn) closeBtn.onclick = () => modal.classList.remove('visible');
    const copyBtn  = document.getElementById('notesCopy');
    if (copyBtn) copyBtn.onclick = () => {
      const values = Array.from(grid.querySelectorAll('textarea')).map(t => t.value.trim());
      const text = values.map((v,i) => `${notesMonthNames[i]}: ${v || '-'}`).join('\n');
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => { try { showToast('Notes copied.', 'info'); } catch(e){} });
      }
    };
    const exportBtn = document.getElementById('notesExport');
    if (exportBtn) exportBtn.onclick = () => {
      const data = {};
      grid.querySelectorAll('textarea').forEach(t => {
        data[t.getAttribute('data-month')] = t.value.trim();
      });
      saveMonthlyNotes(data);
      try { showToast('Notes saved.', 'success'); } catch(e){}
    };

    // Attach per-month share icons once the grid is rendered
    const shareIcons = grid.querySelectorAll('.note-share');
    shareIcons.forEach((icon) => {
      icon.addEventListener('click', function(ev) {
        ev.stopPropagation();
        try { document.querySelectorAll('.month-pop').forEach(n => n.remove()); } catch (_){}
        // Determine index either from data-idx or position in NodeList
        const idxAttr = icon.getAttribute('data-idx');
        const idx = idxAttr ? parseInt(idxAttr,10) : Array.from(shareIcons).indexOf(icon);
        const monthName = notesMonthNames[idx] || '';
        const textArea = grid.querySelector(`textarea[data-month="${idx}"]`);
        const noteText = textArea ? textArea.value.trim() : '';
        // Determine owner using multiple fallbacks
        let owner = '';
        const ownerNameEl = document.getElementById('ownerNameDisplay');
        if (ownerNameEl && ownerNameEl.textContent && ownerNameEl.textContent.trim()) {
          owner = ownerNameEl.textContent.trim();
        } else {
          const ownerSel = document.getElementById('ownerSelect');
          if (ownerSel) {
            const selIdx = ownerSel.selectedIndex;
            owner = (selIdx >= 0 && ownerSel.options[selIdx]) ? ownerSel.options[selIdx].text : ownerSel.value;
          } else if (window.currentOwner && window.owners && window.owners[window.currentOwner]) {
            owner = window.owners[window.currentOwner].name || window.currentOwner;
          } else {
            owner = 'Owner';
          }
        }
        // Determine year using display or input
        let year = '';
        const yearFancy = document.getElementById('yearFancy');
        const yearInput = document.getElementById('yearInput');
        let ytxt = '';
        if (yearFancy && yearFancy.textContent) {
          ytxt = yearFancy.textContent.trim();
        } else if (yearInput && yearInput.value) {
          ytxt = yearInput.value.trim();
        }
        year = ytxt.replace(/\D+/g,'') || ('' + new Date().getFullYear());
        const title = `${owner} — ${year} • ${monthName} Note`;
        const kv = [["Month", monthName], ["Note", noteText || '—']];
        let pop = null;
        if (typeof buildCard === 'function') {
          pop = buildCard(title, kv);
        } else {
          // Minimal fallback popover
          pop = document.createElement('div');
          pop.className = 'month-pop';
          pop.style.position = 'fixed';
          pop.style.zIndex = 9999;
          pop.style.background = 'var(--card-bg, #fff)';
          pop.style.border = '1px solid rgba(0,0,0,0.1)';
          pop.style.borderRadius = '10px';
          pop.style.boxShadow = '0 6px 24px rgba(0,0,0,0.15)';
          pop.style.padding = '12px';
          const h = document.createElement('h4'); h.textContent = title; pop.appendChild(h);
          const d = document.createElement('div'); d.textContent = (monthName + ': ' + (noteText || '—')); pop.appendChild(d);
        }
        document.body.appendChild(pop);
        if (typeof positionPopover === 'function') positionPopover(pop, icon);
        if (typeof wireActions === 'function') wireActions(pop, title, kv);
        // Monthly-note: keep only WhatsApp + Copy actions (remove PNG/system/share and other export buttons)
        try {
          // remove common unwanted action buttons if buildCard injected them
          var unwanted = pop.querySelectorAll('.png, .share, .pdf, .print, .export, .btn-export');
          unwanted.forEach(function(n){ try{ n.remove(); }catch(_){}});

          // Ensure there's an actions container
          var actions = pop.querySelector('.actions');
          if (!actions) {
            actions = document.createElement('div');
            actions.className = 'actions';
            pop.appendChild(actions);
          }

          // Ensure WhatsApp button exists
          var btnWA = pop.querySelector('.wa');
          if (!btnWA) {
            btnWA = document.createElement('button');
            btnWA.type = 'button';
            btnWA.className = 'wa';
            btnWA.textContent = 'WhatsApp';
            actions.appendChild(btnWA);
          }

          // Ensure Copy button exists
          var btnCopy = pop.querySelector('.copy');
          if (!btnCopy) {
            btnCopy = document.createElement('button');
            btnCopy.type = 'button';
            btnCopy.className = 'copy';
            btnCopy.textContent = 'Copy';
            actions.appendChild(btnCopy);
          }

          // Wire WhatsApp and Copy handlers defensively
          (function(bwa, bcopy, theTitle, theNote){
            if (bwa) {
              bwa.addEventListener('click', function(){
                try{
                  var summary = theTitle + "\n\n" + (theNote || '—');
                  var url = 'https://wa.me/?text=' + encodeURIComponent(summary);
                  window.open(url, '_blank');
                }catch(_){ }
              }, { passive:true });
            }
            if (bcopy) {
              bcopy.addEventListener('click', async function(){
                try{
                  var summary = theTitle + "\n\n" + (theNote || '—');
                  if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(summary);
                  } else {
                    var ta = document.createElement('textarea'); ta.value = summary; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
                  }
                  var old = bcopy.textContent; bcopy.textContent = 'Copied';
                  setTimeout(function(){ try{ bcopy.textContent = old; }catch(_){ } }, 1200);
                }catch(_){ }
              }, { passive:true });
            }
          })(btnWA, btnCopy, title, noteText);
        } catch(e){ /* no-op */ }
      });
    });
    // Autosave on blur
    grid.addEventListener('blur', function(e){
      if (e.target && e.target.matches('textarea[data-month]')) {
        const data = {};
        grid.querySelectorAll('textarea').forEach(t => {
          data[t.getAttribute('data-month')] = t.value.trim();
        });
        saveMonthlyNotes(data);
      }
    }, true);
  };

  // Attach button listener once DOM is ready
  function attachMonthlyNotesButton() {
    const btn = document.getElementById('btnMonthlyNotes');
    if (btn) {
      btn.addEventListener('click', function(){
        if (typeof openMonthlyNotesModal === 'function') openMonthlyNotesModal();
      });
    }
    // Also wire the inline reset button for scenario planner
    const inlineReset = document.getElementById('scn-reset-inline');
    if (inlineReset) {
      inlineReset.addEventListener('click', function(){
        const ids = ['scn-monthly-inc','scn-oneoff','scn-newtarget','scn-growth'];
        ids.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = (id === 'scn-newtarget') ? '' : 0;
        });
        if (typeof updateScenarioUI === 'function') updateScenarioUI();
      });
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachMonthlyNotesButton);
  } else {
    attachMonthlyNotesButton();
  }
})();
</script>
<script>
// Adjust page title dynamically: plain for print/export, fancy for normal browsing
(function(){
  const plain = "ENBD Performance Tracker";
  const fancy = "ENBD Performance Tracker — Enhanced 🌟";
  document.title = fancy;
  // When entering print mode, set to plain
  window.matchMedia('print').addListener(mq => {
    if (mq.matches) {
      document.title = plain;
    } else {
      document.title = fancy;
    }
  });
})();
</script>
<style>
/* Remove slice/arc overlay around month numbers */
#gaugeMonthsOverlay { display: none !important; }
</style>
<style>
/* Ensure overlay canvas is visible (numbers only, no ticks) */
#gaugeMonthsOverlay { display: block !important; }
</style>
<style>
/* Slightly reduce only the gauge circle size (keep month numbers unchanged) */
#gaugeChart {
  transform-origin: center center;
}
</style>
<script>
(function(){
  var nop=function(){};
  ['drawProgress','progressArc','drawFinancialProgress','renderProgress','renderProgressArc'].forEach(function(k){
    try { window[k]=nop; } catch(e){}
  });
})();
</script>
<style id="fixedGaugeTextSizing">
/* Lock the inner gauge text to fixed sizes (disable any dynamic sizing) */
.gaugeText .month  { font-size: 15px !important; margin-bottom: 8px; }
.gaugeText .amount { font-size: 17px !important; line-height: 1 !important; }
.gaugeText .arrow  { font-size: 11px !important; }
</style>
<style>
  /* Fancy colored Year label that mirrors owner styling */
  #yearFancy { 
    vertical-align: middle; 
    user-select: none;
  }
  @media (max-width:700px){
    #yearFancy { font-size: 22px; }
  }
</style>
<style>
  /* Hide the old numeric year input, keep only the fancy year label + star visible */
  #yearInput {
    display: none !important;
  }
</style>
<style>
  #yearPrevBtn, #yearToggleBtn {
    margin-left: 4px;
    vertical-align: middle;
  }
</style>
<style>
.ny-month { color: #4a90e2; font-weight:600; }
.ny-amount { color: #27ae60; font-weight:600; }
</style>
<style>
/* Keep inner circle text centered for PDF/print */
body.pdf-mode .gaugeText,
@media print {
  body .gaugeText {
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    line-height: 1.05 !important;
    word-break: break-word;
    white-space: normal;
  }
  body .gaugeText .month { margin-bottom: 4px !important; }
  body .gaugeText .amount { font-size: 0.95em !important; }
}
/* In PDF mode, make sure any alternative overrides don't fight */
body.pdf-mode .inner-circle-content { top: auto !important; }
</style>
<style>
/* --- Strong PDF centering & clipping for inner circle text --- */
body.pdf-mode .gaugeWrapper { 
  position: relative !important; 
  overflow: hidden !important; /* clip any overshoot */
}
body.pdf-mode .gaugeText {
  position: absolute !important;
  top: 50% !important;
  left: 50% !important;
  transform: translate(-50%, -52%) !important; /* slight upward bias */
  width: 62% !important;         /* lock a fixed box within the circle */
  max-width: 62% !important;
  text-align: center !important;
  line-height: 1.05 !important;
  white-space: normal !important;
  overflow-wrap: anywhere !important;
}
body.pdf-mode .gaugeText .month  { font-size: 0.95em !important; margin-bottom: 4px !important; }
body.pdf-mode .gaugeText .amount { font-size: 0.90em !important; line-height: 1.05 !important; }
body.pdf-mode .gaugeText .arrow  { display: none !important; }

/* Extra safety for print dialog exports */
@media print {
  .gaugeWrapper { overflow: hidden !important; }
  .gaugeText {
    position: absolute !important;
    top: 50% !important; left: 50% !important;
    transform: translate(-50%, -52%) !important;
    width: 62% !important; max-width: 62% !important;
    text-align: center !important;
    white-space: normal !important; overflow-wrap: anywhere !important;
  }
  .gaugeText .month  { font-size: 0.95em !important; margin-bottom: 4px !important; }
  .gaugeText .amount { font-size: 0.90em !important; line-height: 1.05 !important; }
  .gaugeText .arrow  { display: none !important; }
}
</style>
<style>
REMOVED
.gaugeText {
  transform: translate(calc(-50% + 15px), calc(-50% - 10%)) !important;
}
/* Keep the same right shift in PDF/export mode */
body.pdf-mode .gaugeText {
  transform: translate(calc(-50% + 15px), -52%) !important;
}
/* And when printing */
@media print {
  .gaugeText {
    transform: translate(calc(-50% + 15px), -52%) !important;
  }
}
</style>
<style>
/* Revert normal screen shift, apply right shift (~15px) ONLY in PDF/export mode */
body.pdf-mode .gaugeText {
  transform: translate(calc(-50% + 15px), -52%) !important;
}
@media print {
  .gaugeText {
    transform: translate(calc(-50% + 15px), -52%) !important;
  }
}
</style>
<style>
.shareMenuWrapper .shareAction:hover { background: rgba(0,0,0,0.05); border-radius:8px; }
body.dark .shareMenuWrapper #shareDropdown { background: #1e1f22; border-color: rgba(255,255,255,0.08); }
body.dark .shareMenuWrapper .shareAction:hover { background: rgba(255,255,255,0.06); }
</style>
<style>
/* Share menu polish */
.shareMenuWrapper .shareAction:hover { background: rgba(0,0,0,0.05); border-radius:8px; }
body.dark .shareMenuWrapper #shareDropdown { background: #1e1f22; border-color: rgba(255,255,255,0.08); }
body.dark .shareMenuWrapper .shareAction:hover { background: rgba(255,255,255,0.06); }
</style>
<style>

/* === Month quick-share (icon + popover) [AUTO-INSERTED] === */
.month-pill{position:relative;}
.month-share-icon{
  position:absolute;top:4px;right:4px;font-size: 13px;line-height:1;
  opacity:.55;cursor:pointer;user-select:none;
  transition:transform .12s ease, opacity .12s ease;
}
.month-share-icon:hover{opacity:.95;transform:scale(1.08);}
.month-pop{
  position:absolute;z-index:1000;top:28px;right:0;min-width:220px;max-width:260px;
  padding:10px;border-radius:10px;background:var(--card);
  border:1px solid rgba(0,0,0,.08);box-shadow:0 12px 30px rgba(10,20,30,.12);
}
body.dark .month-pop{background:#1e1f22;border-color:rgba(255,255,255,.08);}
.month-pop h4{margin:0 0 6px 0;font-size: 13px;color:var(--text-bold);}
.month-pop .kv{display:grid;grid-template-columns:1fr auto;gap:4px 8px;font-size: 13px;margin-bottom:8px;}
.month-pop .kv div:nth-child(odd){color:var(--muted);}
.month-pop .kv div:nth-child(even){font-weight:700;color:var(--text-bold);}
.month-pop .actions{display:flex;gap:6px;flex-wrap:wrap;}
.month-pop .actions button{
  background:var(--very-light-green);color:var(--text-bold);border:1px solid rgba(111,174,117,.2);
  padding:4px 6px;border-radius:8px;font-size: 12px;
}
.month-pop .actions button.ghost{background:transparent;border:1px solid rgba(74,141,133,.2);}

</style>
<style>
/* === FixPack v3: popover to BODY, viewport-aware === */
.month-share-icon{ z-index: 4000; }
.month-pop.is-fixed{
  position: fixed !important;
  top: 0; left: 0;
  transform: translate(var(--pop-x,0px), var(--pop-y,0px));
}
</style>
<style>
/* === PNG Export Contrast Fix (v5) === */
body.__exporting .month-pop,
body.__exporting .month-pop #month-pop-content {
  background: #ffffff !important;
  color: #000000 !important;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body.__exporting .month-pop .kv div:nth-child(odd),
body.__exporting .month-pop .kv div:nth-child(even),
body.__exporting .month-pop h4,
body.__exporting .month-pop .actions button {
  color: #000000 !important;
  border-color: rgba(0,0,0,.2) !important;
  background: #ffffff !important;
}
</style>
<style>
/* === Global Export Theme (v6) === */
@media print {
  html, body { background: #ffffff !important; color: #000000 !important; }
}
body.__exporting, body.__exporting * {
  -webkit-print-color-adjust: exact !important;
  print-color-adjust: exact !important;
}
body.__exporting {
  background: #ffffff !important;
  color: #000000 !important;
}
/* Common containers to force white bg + dark text during export */
body.__exporting :where(.card, .modal, .ribbon, .overview, .stats, .toolbar, .table-wrap, table, thead, tbody, tr, th, td, canvas, #chartsModal, #reportModal){
  background: #ffffff !important;
  color: #000000 !important;
  border-color: rgba(0,0,0,.2) !important;
}
/* Ensure links and buttons readable */
body.__exporting button, 
body.__exporting a { 
  color: #000 !important; 
  background: #fff !important; 
  border-color: rgba(0,0,0,.2) !important;
}
</style>
<style>
/* === Share Everywhere (v7) === */
.share-icon{
  display:inline-block; margin-left:8px; cursor:pointer; user-select:none;
  font-size: 14px; opacity:.85; line-height:1;
  padding:2px 6px; border-radius:8px; border:1px solid rgba(0,0,0,.12);
}
.share-icon:hover{ opacity:1; transform: translateY(-1px); }
.table-row-share{
  font-size: 13px; opacity:.8; border:none; background:transparent; cursor:pointer;
}
.table-row-share:hover{ opacity:1; }
td.share-cell{ width:28px; text-align:center; }
.month-pop.share-card{ min-width:240px; }
</style>
<style>
/* === Share Everywhere (v8 - robust selectors) === */
th.share-col{ width:32px; text-align:center; }
</style>
<style>
/* === v9: Share on numbering (first column) === */
td.number-cell{ position: relative; }
td.number-cell .num-share{ 
  position:absolute; top:4px; right:4px; 
  font-size: 13px; line-height:1; opacity:.85; cursor:pointer; user-select:none;
  border:1px solid rgba(0,0,0,.15); border-radius:6px; padding:1px 4px; background:rgba(255,255,255,.8);
}
body.dark td.number-cell .num-share{ background:rgba(0,0,0,.35); border-color:rgba(255,255,255,.25); }
td.number-cell .num-share:hover{ opacity:1; transform:translateY(-1px); }
</style>
<style>
/* === v9.2: number-click share === */
td.number-cell{ position: relative; cursor: pointer; }
td.number-cell .num-share{ 
  position:absolute; top:4px; right:4px; 
  font-size: 13px; line-height:1; opacity:.85; user-select:none;
  border:1px solid rgba(0,0,0,.15); border-radius:6px; padding:1px 4px; background:rgba(255,255,255,.8);
}
body.dark td.number-cell .num-share{ background:rgba(0,0,0,.35); border-color:rgba(255,255,255,.25); }
td.number-cell:hover .num-share{ opacity:1; transform:translateY(-1px); }
</style>
<style>
/* === v9.4: Fine row separators === */
table { border-collapse: separate; border-spacing: 0; }
table tbody tr:not(:first-child) > td {
  border-top: 1px solid rgba(0,0,0,.08);
}
body.dark table tbody tr:not(:first-child) > td {
  border-top-color: rgba(255,255,255,.12);
}
/* Optional: soften header-bottom for clarity */
table thead tr:last-child > th {
  border-bottom: 1px solid rgba(0,0,0,.10);
}
body.dark table thead tr:last-child > th {
  border-bottom-color: rgba(255,255,255,.16);
}
</style>
<style>
/* === v9.5: Popover visibility & sizing === */
.month-pop{ z-index: 2147483647 !important; } /* stay above any section */
.month-pop.is-fixed{
  position: fixed !important;
  top: 0; left: 0;
  transform: translate(var(--pop-x,0px), var(--pop-y,0px));
  max-width: 320px;
  max-height: min(60vh, 360px);
  overflow: auto;
  overscroll-behavior: contain;
  pointer-events: auto;
}
/* small arrow for context */
.month-pop::after{
  content: "";
  position: absolute;
  width: 10px; height: 10px;
  background: inherit;
  border: inherit;
  border-left: none; border-top: none;
  transform: rotate(45deg);
  right: 16px; top: -6px;
}
/* when flipped above, move arrow to bottom */
.month-pop[data-pos="above"]::after{
  top: auto; bottom: -6px;
}
</style>
<style>
/* === v9.6: Compact popover sizing === */
.month-pop.is-fixed {
  max-width: 220px !important;
  min-width: 180px !important;
  max-height: 240px !important;
}
.month-pop #month-pop-content{ padding: 8px !important; }
.month-pop h4{ font-size: 12px !important; margin: 0 0 4px 0 !important; }
.month-pop .kv{ grid-template-columns: 1fr auto !important; gap: 2px 6px !important; font-size: 12px !important; margin-bottom: 6px !important; }
.month-pop .actions{ gap: 4px !important; }
.month-pop .actions button{ padding: 3px 5px !important; font-size: 11px !important; border-radius: 6px !important; }
.month-pop::after{ right: 12px !important; }
</style>
<style>
/* --- Next Year Target area styling --- */
#nextYearTargetContainer .ny-month{ color:#4a90e2; font-weight:700; }
#nextYearTargetContainer .ny-amount{ color:#27ae60; font-weight:700; }
</style>
<style>
/* Hide legacy inline "Next Year Target" note to prevent duplicate display */
#nextYearTargetNote { display: none !important; }
</style>
<style>
/* flags above months */
.month-item { position: relative; }
.month-flag { position: absolute; top: -8px; left: 50%; transform: translateX(-50%); font-size: 14px; line-height:1; pointer-events:none; }
</style>
<style>
/* Clean, minimal footnote for Adjusted Target explanation */
#dashTargetNote {
  display: block !important;
  font-size: 8px !important;       /* very small */
  line-height: 1.15 !important;    /* tight spacing */
  color: var(--muted) !important;   /* faint */
  opacity: 0.9 !important;
  margin-top: 2px !important;
  max-width: 120px !important;      /* force 2 short lines */
  white-space: normal !important;   /* allow wrapping */
  word-break: break-word !important;
  text-align: left !important;
}
</style>
<style>
/* Reset previous shifts */
#dashYearlyTarget, #dashTargetNote {
  top: auto !important;
}

/* Move the entire Early Target block (label + number + note) upward ~4mm (~15px) */
.summary .row > div:first-child {
  position: relative;
  top: -15px;
}
</style>
<style>
/* --- Gauge status hint (circle) --- */
#gaugeText .status {
  font-size: 12px;
  line-height: 1.2;
  margin-top: 2px;
  opacity: 0.9;
}
#gaugeText .status-surplus  { color: #1a7f37; }  /* green */
#gaugeText .status-shortage { color: #c62828; }  /* red */
#gaugeText .status-balanced { color: #666; }

/* --- Ribbon status hint --- */
.ribbon-status { font-weight: 600; opacity: 0.95; }
.ribbon-surplus  { color: #1a7f37; }  /* green */
.ribbon-shortage { color: #c62828; }  /* red */
.ribbon-balanced { color: #666; }
</style>
<style>
/* Hard-hide the legacy Next Year Target placeholder + its container */
#nextYearTargetNote,
#nextYearTargetContainer,
#nextYearTargetContainer:has(#nextYearTargetNote),
#nextYearTargetCard {
  display: none !important;
  visibility: hidden !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  overflow: hidden !important;
}
</style>
<style>
/* ===== Toolbar Compact Mode ===== */
.topToolbar {
  display: flex;
  flex-wrap: nowrap !important;     /* keep one line */
  align-items: center;
  gap: 6px !important;              /* tighter spacing */
  row-gap: 0 !important;
  column-gap: 6px !important;
  white-space: nowrap;
}
.topToolbar .spacer { display: none !important; } /* reclaim space */

/* Make all toolbar controls smaller */
.topToolbar button,
.topToolbar .iconBtn,
.topToolbar select,
.topToolbar .btn-refresh,
#btnExportExcel, #btnImportExcel,
#btnExportPDF, #btnPrint, #btnGenerateReport,
#btnToggleView, #btnToggleFuture, #btnToggleAll {
  font-size: 12px !important;
  padding: 4px 6px !important;
  height: 26px !important;
  line-height: 1 !important;
  border-radius: 6px !important;
}

/* If there are labels/spans used as pills */
.topToolbar .pill, .topToolbar .label, .topToolbar span {
  font-size: 12px !important;
}

/* Prevent wrapping within the button text (keeps emojis tight) */
.topToolbar button > * { white-space: nowrap !important; }

/* Slightly tighten owner/year controls if they sit in toolbar */
.topToolbar #ownerSelect,
.topToolbar #yearInput, 
.topToolbar #yearFancy {
  font-size: 12px !important;
  height: 24px !important;
}

/* When viewport is small, allow slight scale to keep on one line */
@media (max-width: 1100px){
  .topToolbar { gap: 4px !important; }
  .topToolbar button, .topToolbar .iconBtn, .topToolbar select {
    font-size: 11px !important;
    padding: 3px 5px !important;
    height: 24px !important;
  }
}
</style>
<style>
/* Resize Soft Refresh button */
  font-size: 12px !important;
  padding: 2px 6px !important;
  border-radius: 6px !important;
}
</style>
<style id="tiny-note-style">
/* Ensure the footer target total cell can hold stacked content */
#monthlyTarget {
  position: relative !important;
  text-align: right !important; /* keep the number aligned right */
  vertical-align: top !important;
  padding-bottom: 6px !important;
}

/* Clamp to 1–2 lines, align LEFT under the number */
#totalTargetNote.tiny-note {
  display: -webkit-box !important;
  -webkit-box-orient: vertical !important;
  -webkit-line-clamp: 2 !important;  /* limit to 2 lines */
  overflow: hidden !important;
  text-overflow: ellipsis !important;

  font-size: 9px !important;
  line-height: 1.2 !important;
  color: var(--muted) !important;

  margin-top: 2px !important;
  margin-left: 0 !important;
  margin-right: auto !important;
  max-width: 260px !important;

  word-break: keep-all !important;
  white-space: normal !important;

  text-align: left !important;      /* <-- left beside/under the number */
}

/* Fallback for non-WebKit browsers: single-line ellipsis, left-aligned */
@supports not (-webkit-line-clamp: 2) {
  #totalTargetNote.tiny-note {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 260px !important;
    text-align: left !important;
  }
}
</style>
<!-- OVERRIDE STYLE: negative acc-var number red -->
<style>
  .month-pill .acc-var-label .neg { color: #c62828; font-weight: 600; }
</style>
<!-- RIBBON: display-only (keep values visible) -->
<style>
  #creditRibbon, #greenRibbon, .credit-ribbon, .green-ribbon, .ribbon, .ribbon-strip, .ribbonRow, .ribbon-container{
    cursor: default;
  }
  /* Do NOT hide inputs; just block interactions */
  #creditRibbon :is(button,[role="button"],a){ pointer-events: none; }
  #greenRibbon  :is(button,[role="button"],a){ pointer-events: none; }
  .ribbon       :is(button,[role="button"],a){ pointer-events: none; }
  .ribbon-strip :is(button,[role="button"],a){ pointer-events: none; }
  .ribbonRow    :is(button,[role="button"],a){ pointer-events: none; }
  .ribbon-container :is(button,[role="button"],a){ pointer-events: none; }
  #creditRibbon .draggable, #greenRibbon .draggable, .ribbon .draggable, .ribbon-strip .draggable, .ribbonRow .draggable, .ribbon-container .draggable{
    pointer-events: none !important;
  }
</style>
<!-- RIBBON: All Targets chip styles -->
<style>
  #ribbonAllTargets {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }
  .ribbon-all-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(74,141,133,0.18);
    background: rgba(74,141,133,0.06);
    font-size: 13px;
    white-space: nowrap;
  }
  .ribbon-all-chip .m { font-weight: 600; opacity: 0.9; }
  .ribbon-all-chip .t { opacity: 0.95; }
  .ribbon-all-chip .a { opacity: 0.95; }
  .ribbon-all-chip .acc { font-weight: 600; }
  .ribbon-all-chip.shortage .acc { color: #c62828; }
  .ribbon-all-chip.surplus  .acc { color: #2e7d32; }
  .ribbon-all-chip.equal    .acc { opacity: 0.95; }
  /* keep display-only behavior (no clicks) */
  #ribbonAllTargets a, #ribbonAllTargets button { pointer-events: none; }
</style>
<!-- KILL OLD MINI CARD (style) -->
<style id="killOldNextTargetCardCSS">
  .next-target-card { 
    display: none !important; 
    visibility: hidden !important; 
    pointer-events: none !important;
  }
</style>
<!-- Background image injection (Blue/White Freepik) -->
<style id="bg-image-injected-bluewhite">
  html, body { height: 100%; }
  /* Fallback color while image loads */
  body { background: #eaf3ff; }
  /* Full-viewport background with a soft overlay for contrast */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;
    background:
      linear-gradient(180deg, rgba(255,255,255,0.65), rgba(240,248,255,0.55)),
      url('https://img.freepik.com/free-photo/nice-blue-white-background-backdrop-purpose_1017-46757.jpg') center center / cover no-repeat fixed;
    box-shadow: inset 0 0 140px rgba(0,0,0,0.12);
    pointer-events: none;
  }
  /* Disable decorative background in export/print */
  body.__exporting::before { display: none !important; }
  @media print {
    body::before { display: none !important; }
    body { background: #ffffff !important; }
  }
</style>
<style id="enbd-name-override">
#enbd-header-name, 
#project-name, #projectTitle, #tracker-name, #trackerTitle, 
#header-title, #page-title, #pageTitle, #enbd-title, #app-title, 
#title, #name, .project-name, .tracker-name, .header-title, .page-title, 
.title, .brand, .app-title, .name {
  color: #111 !important;
  font-size: 18px !important;
  font-weight: 600 !important;
}
</style><style id="owner-name-override">
/* Owner name formal-but-distinct style */
.owner-name-chalk, p.tiny.owner-name-chalk {
  color: #111 !important;
  font-family: "Chalkboard","Chalkboard SE","Bradley Hand","Comic Sans MS",cursive !important;
}
</style><style id="enbd-title-top-gap">
#enbd-title { margin-top: 7mm !important; }
</style><style id="owner-year-formal-override">
/* Formal, distinguished styling for Owner & Year controls (bigger, dark grey years) */
:root{
  --formal-font: "Baskerville","Didot","Georgia","Times New Roman",serif;
  --formal-color: #111;   /* black for owners */
  --year-color:  #333;    /* dark grey for years */
}

/* Owner controls */
#ownerSelect,
.owner-container, .owner-middle,
#ownerNameDisplay, .owner-name,
.ownerToggleBtn,
#repOwner {
  color: var(--formal-color) !important;
  font-family: var(--formal-font) !important;
}

#ownerSelect { font-size: 17px !important; }
.owner-container, .owner-middle { font-size: 17px !important; }
#ownerNameDisplay { font-size: 19px !important; font-weight: 600 !important; }
.ownerToggleBtn { font-size: 17px !important; }

/* Year controls */
#yearInput,
#yearFancy,
#yearPrevBtn, #yearToggleBtn,
#repYear,
.nextYearTargetTitle {
  color: var(--year-color) !important;
  font-family: var(--formal-font) !important;
}

#yearInput  { font-size: 17px !important; }
#yearFancy  { font-size: 19px !important; font-weight: 600 !important; }
#yearPrevBtn, #yearToggleBtn { font-size: 17px !important; }
</style><style id="year-color-force">
/* Hard override: ensure Years are dark grey, not blue */
#yearFancy,
#yearFancy.owner-name,
#yearFancy[class*="owner-theme-"] {
  background: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  color: #333 !important;
  -webkit-text-fill-color: #333 !important;
  text-shadow: none !important;
}

#yearInput { color:#333 !important; }
#repYear   { color:#333 !important; }
#yearPrevBtn, #yearToggleBtn { color:#333 !important; }

/* If there are generic theme rules setting gradients, neutralize them when applied to #yearFancy */
[class*="owner-theme-"]#yearFancy,
#yearFancy.owner-theme-1,
#yearFancy.owner-theme-2,
#yearFancy.owner-theme-3,
#yearFancy.owner-theme-4,
#yearFancy.owner-theme-5,
#yearFancy.owner-theme-6,
#yearFancy.owner-theme-7,
#yearFancy.owner-theme-8,
#yearFancy.owner-theme-9,
#yearFancy.owner-theme-10 {
  background: none !important;
  -webkit-background-clip: initial !important;
  color:#333 !important;
  -webkit-text-fill-color:#333 !important;
}
</style><style id="group-frames-style">
/* === Formal grouping frames (subtle) === */
.group-frame{
  border: 1px solid #e5e7eb !important;
  border-radius: 12px !important;
  padding: 8px 12px !important;
  margin: 8px 12px !important;
  background: #fff;
}

/* Table gets an outline to avoid altering cell borders */
.group-outline-table{
  outline: 1px solid #e5e7eb !important;
  outline-offset: 0;
  border-radius: 12px; /* may not clip table, but keeps visual softness */
}

/* Keep ribbon untouched (already styled) */
#odc-ribbon-container.group-frame{ border: none !important; margin-bottom: 6px !important; }

/* Ensure group spacing plays nice on small screens */
@media (max-width: 800px){
  .group-frame{ padding: 6px 8px !important; margin: 6px 8px !important; }
}
</style><style id="next-needed-frame-style">
/* Formal frame around the "Next needed" block */
.next-needed-frame{
  border: 1px solid #e5e7eb !important;
  border-radius: 12px !important;
  padding: 8px 12px !important;
  margin: 8px 12px !important;
  background: #fff;
}
</style><style id="next-needed-badge-frame">
/* Framing just the small "Next needed" ribbon under owners/years */
#nextNeededBadge.next-needed-ribbon{
  border: 1px solid #d1d5db !important;   /* slightly darker than #e5e7eb for visibility */
  border-radius: 10px !important;
  background:#fff !important;
  padding: 8px 12px !important;
  margin: 8px 12px !important;
}
</style><style id="kpi-compact-strip-style">
/* Enhanced modern KPI strip with premium styling */
.kpi-strip{
  display: grid;
  grid-template-columns: repeat(4, minmax(160px, 1fr));
  gap: 16px;
  margin: 12px 16px 8px;
  padding: 8px;
  background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(248,250,252,0.9) 100%);
  border-radius: 20px;
  box-shadow: 
    0 8px 32px rgba(74,141,133,0.08),
    0 2px 8px rgba(0,0,0,0.04),
    inset 0 1px 0 rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.2);
  position: relative;
  overflow: hidden;
}

.kpi-strip::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, 
    var(--accent) 0%, 
    var(--green) 25%, 
    var(--gold) 50%, 
    var(--purple) 75%, 
    var(--accent) 100%);
  border-radius: 20px 20px 0 0;
}

.kpi-item{
  position: relative;
  border: 1px solid rgba(74,141,133,0.12);
  border-radius: 16px;
  padding: 18px 16px;
  background: linear-gradient(145deg, 
    rgba(255,255,255,0.95) 0%, 
    rgba(251,253,252,0.9) 100%);
  box-shadow: 
    0 4px 16px rgba(74,141,133,0.06),
    0 1px 4px rgba(0,0,0,0.04),
    inset 0 1px 0 rgba(255,255,255,0.8);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  overflow: hidden;
}

.kpi-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--accent);
  transform: scaleX(0);
  transition: transform 0.3s ease;
}

.kpi-item:nth-child(1)::before { background: linear-gradient(90deg, #4a8d85, #6fae75); }
.kpi-item:nth-child(2)::before { background: linear-gradient(90deg, #6fae75, #e3b04b); }
.kpi-item:nth-child(3)::before { background: linear-gradient(90deg, #e3b04b, #d46b6b); }
.kpi-item:nth-child(4)::before { background: linear-gradient(90deg, #9f7fbf, #4a8d85); }

.kpi-item:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 12px 32px rgba(74,141,133,0.12),
    0 4px 12px rgba(0,0,0,0.08),
    inset 0 1px 0 rgba(255,255,255,0.9);
  border-color: rgba(74,141,133,0.2);
}

.kpi-item:hover::before {
  transform: scaleX(1);
}

.kpi-label{ 
  font-size: 12px; 
  color: var(--muted); 
  letter-spacing: 0.5px; 
  margin-bottom: 6px;
  font-weight: 600;
  text-transform: uppercase;
  display: flex;
  align-items: center;
  gap: 4px;
}

.kpi-value{ 
  font-size: 24px; 
  font-weight: 700; 
  color: var(--text-bold);
  line-height: 1.2;
  font-family: 'Poppins', sans-serif;
  position: relative;
}

.kpi-value span {
  background: linear-gradient(135deg, var(--text-bold) 0%, var(--accent) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* KPI sign colours */
.kpi-pos { color: var(--green) !important; font-weight: 700 !important; }
.kpi-neg { color: var(--red) !important; font-weight: 700 !important; }
.kpi-zero { color: var(--muted) !important; font-weight: 700 !important; }

/* Force Balance KPI (kpiVal_rem) to always be solid red and bold in all browsers (override gradients/text-fill)
   Chrome/Safari may use -webkit-background-clip + -webkit-text-fill-color to paint gradients; force a solid fill. */
#kpiVal_rem {
  color: var(--red) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--red) !important; /* Chrome */
  text-fill-color: var(--red) !important;
}

/* Adjusted Target (orange) - force solid orange number */
#kpiVal_target {
  color: var(--orange-red-flag) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--orange-red-flag) !important;
}

/* Forecasted Year-End (gold) - force solid gold number */
#kpiVal_forecast {
  color: var(--gold) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--gold) !important;
}

/* Avg. Mo. Target (distinct color) - force solid purple */
#kpiVal_avgMonthly {
  color: var(--purple) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--purple) !important;
}

/* Force Mo. Variance and Total Deviation to use solid color when signed (override gradient/text-fill) */
#kpiVal_monthlyVariance.kpi-neg,
#kpiVal_deviation.kpi-neg {
  color: var(--red) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--red) !important;
}

#kpiVal_monthlyVariance.kpi-pos,
#kpiVal_deviation.kpi-pos {
  color: var(--green) !important;
  font-weight: 700 !important;
  background: none !important;
  background-image: none !important;
  -webkit-background-clip: initial !important;
  background-clip: initial !important;
  -webkit-text-fill-color: var(--green) !important;
}

/* Enhanced responsive design */
@media (max-width: 1024px){
  .kpi-strip{ 
    grid-template-columns: repeat(2, minmax(180px, 1fr));
    gap: 14px;
  }
}

@media (max-width: 640px){
  .kpi-strip{ 
    grid-template-columns: 1fr;
    gap: 12px;
    margin: 8px 12px 6px;
  }
  .kpi-item {
    padding: 16px 14px;
  }
  .kpi-value {
    font-size: 22px;
  }
}

/* Dark mode enhancements */
body.dark .kpi-strip {
  background: linear-gradient(135deg, rgba(40,45,50,0.95) 0%, rgba(30,35,40,0.9) 100%);
  border-color: rgba(255,255,255,0.1);
  box-shadow: 
    0 8px 32px rgba(0,0,0,0.3),
    0 2px 8px rgba(0,0,0,0.2),
    inset 0 1px 0 rgba(255,255,255,0.1);
}

body.dark .kpi-item {
  background: linear-gradient(145deg, 
    rgba(50,55,60,0.95) 0%, 
    rgba(45,50,55,0.9) 100%);
  border-color: rgba(255,255,255,0.08);
  box-shadow: 
    0 4px 16px rgba(0,0,0,0.2),
    0 1px 4px rgba(0,0,0,0.1),
    inset 0 1px 0 rgba(255,255,255,0.1);
}

body.dark .kpi-item:hover {
  box-shadow: 
    0 12px 32px rgba(0,0,0,0.4),
    0 4px 12px rgba(0,0,0,0.3),
    inset 0 1px 0 rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.15);
}

/* Animation for loading states */
@keyframes kpi-loading {
  0%, 100% { opacity: 0.9; }
  50% { opacity: 1; }
}

@keyframes kpi-entrance {
  0% { 
    opacity: 0; 
    transform: translateY(20px) scale(0.95); 
  }
  100% { 
    opacity: 1; 
    transform: translateY(0) scale(1); 
  }
}

.kpi-value.loading {
  animation: kpi-loading 1.5s ease-in-out infinite;
}

.kpi-item {
  animation: kpi-entrance 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.kpi-item:nth-child(1) { animation-delay: 0.1s; }
.kpi-item:nth-child(2) { animation-delay: 0.2s; }
.kpi-item:nth-child(3) { animation-delay: 0.3s; }
.kpi-item:nth-child(4) { animation-delay: 0.4s; }

/* Micro-interactions */
.kpi-item:active {
  transform: translateY(0) scale(0.98);
  transition: transform 0.1s ease;
}
</style><style id="hide-old-kpi-cards">.kpi-old-hide{ display:none !important; }</style><style id="kpi-compact-placement-style">
/* Keep compact KPI strip in the original block location */
.kpi-old-area > :not(#kpiCompactStrip){
  display: none !important;
}
/* Ensure our strip has spacing consistent with surrounding layout */
.kpi-strip{ margin: 6px 4px !important; }
</style>
<style id="black-frame-around-main">
/* === Softer black frame around the main indicator + monthly pills === */
#mainSection{
  border: 1px solid rgba(0,0,0,0.6) !important;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.06) inset, var(--card-shadow) !important;
}
.top > .card:first-of-type{
  border: 1px solid rgba(0,0,0,0.6) !important;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.06) inset, var(--card-shadow) !important;
}
</style>
<style id="two-fine-borders-chart">
/* === Outer fine border: around the entire chart CARD === */
.card:has(canvas), .card:has(svg), .chart-panel:has(canvas), .chart-panel:has(svg) {
  border: 1px solid #000 !important;
  border-radius: 12px !important;
}

/* === Inner fine border: around the chart drawing only (canvas/SVG) === */
.card:has(canvas) canvas,
.card:has(svg) svg,
.chart-container canvas, .chart-container svg,
.chart, .charts, .chart-area, .chartWrapper, .chart-wrapper,
canvas[id*="chart"], canvas[class*="chart"], canvas.chartjs-render-monitor {
  outline: 1px solid #000 !important;
  outline-offset: 3px !important;
  border-radius: 10px !important;
}

/* Ensure containers don't clip the outline offset */
.chart-container, .chartWrapper, .chart-wrapper, .card:has(canvas) {
  overflow: visible !important;
}
</style>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400;1,500&amp;display=swap" id="nyt-fonts" rel="stylesheet"/>
<style id="nyt-special-style">
.nyt-special{
  color:#000 !important;
  font-style: italic !important;
  font-family: "Playfair Display", Georgia, "Times New Roman", serif !important;
  letter-spacing: 0.2px;
}
</style>
<style id="nyt-black-italic">
/* === Override: Next Year Target line in black italic Playfair === */
#nextYearTargetContainer {
  font-family: 'Playfair Display', Georgia, 'Times New Roman', serif !important;
  font-style: italic !important;
  color: #000 !important;
}
#nextYearTargetContainer * {
  font-family: 'Playfair Display', Georgia, 'Times New Roman', serif !important;
  font-style: italic !important;
  color: #000 !important;
}
/* keep spacing/alignment from existing rules */
</style>
<style id="white-fine-black-buttons">
/* === Override: Action buttons white with fine black border === */
#btnExportExcel, #btnImportExcel, #btnExportPDF, #btnPrint, #btnGenerateReport {
  background: #fff !important;
  color: #000 !important;
  border: 1px solid #000 !important;   /* very fine black border */
  box-shadow: none !important;
}
#btnExportExcel:hover, #btnImportExcel:hover, #btnExportPDF:hover, #btnPrint:hover, #btnGenerateReport:hover {
  background: #fff !important;
  filter: none !important;
  opacity: 0.95;
}
</style>
<style id="hard-refresh-border">
/* === Override 3: Ensure "Hard Refresh" has white fill + fine black border === */
button.btn-refresh, a.btn-refresh, [onclick*="hardRefresh"] {
  background: #fff !important;
  color: #000 !important;
  border: 1px solid #000 !important;
  box-shadow: none !important;
  filter: none !important;
}
</style>
<style id="hard-refresh-icon-css">
/* === Icon ring for Hard Refresh === */
.hr-icon {
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 1.25em !important;
  height: 1.25em !important;
  border: 1px solid #000 !important;   /* fine black border */
  border-radius: 9999px !important;
  margin-right: 6px !important;
  line-height: 1 !important;
}
</style>
<style id="notes-and-columns-borders">
/* === Override: General Notes rectangle & table columns borders === */
/* General Notes card (dashboard) and report notes */
#generalNotesCard, #repGeneralNotes {
  background: #fff !important;
  border: 1px solid #000 !important;    /* fine black border */
  box-shadow: none !important;
}

/* Main tracker table columns: add subtle fine black grid */
.group-outline-table {
  border: 1px solid #000 !important;
  border-collapse: separate !important;
  border-spacing: 0 !important;
}
.group-outline-table thead th,
.group-outline-table tbody td {
  border-right: 1px solid #000 !important;
  border-bottom: 1px solid #000 !important;
}
.group-outline-table thead th:first-child,
.group-outline-table tbody td:first-child {
  border-left: 0 !important;
}
.group-outline-table thead tr:first-child th {
  border-top: 0 !important;
}

/* Keep chips/pills untouched */
</style>
<style>

/* === injected: small empty windows for KPI placeholders === */
.empty-window{
  min-height: 72px;
  background: #ffffff;
  border: 1px solid rgba(0,0,0,0.25);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.empty-window .placeholder-spacer{
  width: 100%;
  height: 48px;
}

</style>
<style>

/* === injected: labels for empty KPI windows === */
.empty-window{ position: relative; }
.empty-window .ew-label{
  position: absolute;
  top: 6px;
  left: 8px;
  font-size: 13px;
  line-height: 1.2;
  font-style: italic;
  color: #000;
  opacity: 0.9;
  user-select: none;
}

</style>
<style>
/* === injected: opening balance value styling === */
.empty-window .ew-value{
  position: absolute;
  bottom: 10px;
  right: 12px;
  font-size: 17px;
  font-weight: 600;
  color: #000;
  user-select: none;
}
</style>
<style>

/* === injected: Remaining tile color cues === */
.empty-window.rem-pos .ew-value { color: #0a7a0a; }   /* green */
.empty-window.rem-neg .ew-value { color: #b00020; }   /* red */

</style>
<script defer="" id="miniCards-logic">
(function(){
  // Guards so we don't bind twice even if script is included again
  if (window.__miniCardsBound) return;
  window.__miniCardsBound = true;

  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  const MONTH_MAP = {"jan":0,"january":0,"feb":1,"february":1,"mar":2,"march":2,"apr":3,"april":3,
                     "may":4,"jun":5,"june":5,"jul":6,"july":6,"aug":7,"august":7,"sep":8,"sept":8,
                     "september":8,"oct":9,"october":9,"nov":10,"november":10,"dec":11,"december":11};

  // Fixed indices per your layout (1-based → 6th=Target, 7th=Month)
  const IDX_TARGET = 5; // zero-based
  const IDX_MONTH  = 6; // zero-based
  let   IDX_KEYDATE = null;
  let   IDX_BALANCE = null;

  function toNum(x){ const n=String(x||"").replace(/[^\d.\-]/g,""); const v=parseFloat(n); return isNaN(v)?null:v; }
  function fmtAED(n){ try{ return new Intl.NumberFormat('en-AE',{maximumFractionDigits:0}).format(n); } catch(e){ return String(Math.round(n)).replace(/\B(?=(\d{3})+(?!\d))/g,','); } }
  function getCurrentYear(){
    if (window.currentYear) return window.currentYear;
    const yf=document.getElementById("yearFancy"); if (yf && yf.textContent){ const y=parseInt(yf.textContent.replace(/[^\d]/g,''),10); if(!isNaN(y)) return y; }
    const yi=document.getElementById("yearInput"); if (yi && yi.value){ const y=parseInt(yi.value,10); if(!isNaN(y)) return y; }
    return (new Date()).getFullYear();
  }
  function parseDateToYM(txt){
    const s=(txt||"").trim();
    if (!s) return null;
    if (/^\d{4}-\d{2}-\d{2}/.test(s)){ const d=new Date(s); if(!isNaN(d)) return {y:d.getFullYear(), m:d.getMonth()}; }
    if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/.test(s)){ const [a,b,c]=s.split(/[\/\-]/).map(x=>parseInt(x,10)); const d=new Date(c,b-1,a); if(!isNaN(d)) return {y:d.getFullYear(), m:d.getMonth()}; }
    if (/^\d{1,2}[\/\-]\d{4}$/.test(s)){ const [m,y]=s.split(/[\/\-]/).map(x=>parseInt(x,10)); if(!isNaN(m)&&!isNaN(y)) return {y:y, m:m-1}; }
    const m=s.toLowerCase().match(/(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\s*[\-\/]?\s*(\d{4})/);
    if (m){ const mi=MONTH_MAP[m[1]]; const yr=parseInt(m[2],10); if(!isNaN(mi)&&!isNaN(yr)) return {y:yr, m:mi}; }
    const t=Date.parse(s); if(!isNaN(t)){ const d=new Date(t); return {y:d.getFullYear(), m:d.getMonth()}; }
    return null;
  }

  function findMainTable(){
    const tables = Array.from(document.querySelectorAll("table"));
    for (const tbl of tables){
      if (tbl.querySelector("thead") && tbl.querySelector("tbody")) return tbl;
    }
    return tables[0] || null;
  }
  function initHeadIndices(tbl){
    IDX_KEYDATE = null; IDX_BALANCE = null;
    const thEls = Array.from(tbl.querySelectorAll("thead th"));
    for (let i=0;i<thEls.length;i++){
      const t = thEls[i].textContent.trim().toLowerCase();
      if (IDX_KEYDATE==null && (t.includes("key date") || t.includes("key dates") || t==="date" || t.includes("due date"))) IDX_KEYDATE = i;
      if (IDX_BALANCE==null && (t.includes("balance"))) IDX_BALANCE = i;
    }
  }
  function extractYMfromMonthCell(cellText){
    const s=(cellText||"").trim().toLowerCase();
    let m=null, y=null;
    const mm = s.match(/(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)/);
    if (mm) m = MONTH_MAP[mm[1]];
    if (m==null && /^\d{1,2}(\s|$)/.test(s)){ const mi=parseInt(s,10)-1; if(mi>=0&&mi<12) m=mi; }
    const ymatch = s.match(/(\d{4})/);
    if (ymatch) y = parseInt(ymatch[1],10);
    return {y,m};
  }
  function collect(year){
    const tbl = findMainTable(); if (!tbl) return [];
    initHeadIndices(tbl);
    const tbody = tbl.querySelector("tbody"); if (!tbody) return [];

    const uniq = new Map();
    Array.from(tbody.querySelectorAll("tr")).forEach(tr => {
      const tds = Array.from(tr.children);
      if (tds.length < Math.max(IDX_TARGET, IDX_MONTH)+1) return;

      const target = toNum(tds[IDX_TARGET]?.textContent);
      if (target == null || !(target > 0)) return;

      let {y, m} = extractYMfromMonthCell(tds[IDX_MONTH]?.textContent || "");
      if ((y==null || m==null) && IDX_KEYDATE != null && tds[IDX_KEYDATE]){
        const ym = parseDateToYM(tds[IDX_KEYDATE].textContent || "");
        if (ym){ if (y==null) y=ym.y; if (m==null) m=ym.m; }
      }
      if (y == null) y = year; // assume target year if missing
      if (y !== year || m == null) return;

      let balance = null;
      if (IDX_BALANCE != null && tds[IDX_BALANCE]) balance = toNum(tds[IDX_BALANCE].textContent);
      else balance = toNum(tds[tds.length-1]?.textContent);

      const key = `${m}|${target}|${balance ?? "x"}`;
      if (!uniq.has(key)) uniq.set(key, { m, target, balance });
    });
    return Array.from(uniq.values()).sort((a,b)=> a.m - b.m);
  }

  let __lastJSON_L = "", __lastJSON_R = "";
  let __expanded_L = false, __expanded_R = false;

  function makeSpan(cls, text, num){
    const s = document.createElement("span");
    s.className = cls;
    s.textContent = text;
    if (num != null && num < 0){ s.classList.add("neg"); }
    return s;
  }

  function renderCard(side){
    const isLeft = side === "left";
    const list = document.getElementById(isLeft ? "ntList" : "nytList");
    if (!list) return;

    const baseYear = getCurrentYear();
    const year = baseYear + 1; // Both cards now pull from next year
    const rows = collect(year);

    const expanded = isLeft ? __expanded_L : __expanded_R;
    const curr = JSON.stringify(rows) + "|" + expanded + "|" + year;
    if (isLeft){
      if (curr === __lastJSON_L) return; __lastJSON_L = curr;
    } else {
      if (curr === __lastJSON_R) return; __lastJSON_R = curr;
    }

    list.innerHTML = "";
    if (!rows.length){
      list.innerHTML = '<li class="tiny muted">No ' + (isLeft?'current':'next') + '-year targets found.</li>';
      return;
    }

    const first = rows[0];
    const li0 = document.createElement("li"); li0.className="topline";
    const m0 = makeSpan("month", MONTHS[first.m] || ("M"+(first.m+1)));
    const a0 = makeSpan("amt", "Target AED " + fmtAED(first.target), first.target);
    li0.append(m0, a0);
    if (first.balance != null && !isNaN(first.balance)){
      const b0 = makeSpan("bal", " Balance AED " + fmtAED(first.balance), first.balance);
      li0.appendChild(b0);
    }
    list.appendChild(li0);

    const rest = rows.slice(1);
    if (!(isLeft ? __expanded_L : __expanded_R)){
      if (rest.length){
        const tog = document.createElement("div"); tog.className="toggle"; tog.textContent = "Show all";
        const chip = document.createElement("span"); chip.className="countchip"; chip.textContent = `(+${rest.length})`;
        tog.appendChild(chip);
        tog.addEventListener("click", () => { if (isLeft) { __expanded_L = true; } else { __expanded_R = true; } renderCard(side); });
        list.appendChild(tog);
      }
      return;
    }

    rest.forEach(r => {
      const li = document.createElement("li");
      const m = makeSpan("month", MONTHS[r.m] || ("M"+(r.m+1)));
      const a = makeSpan("amt", "Target AED " + fmtAED(r.target), r.target);
      li.append(m, a);
      if (r.balance != null && !isNaN(r.balance)){
        const b = makeSpan("bal", " Balance AED " + fmtAED(r.balance), r.balance);
        li.appendChild(b);
      }
      list.appendChild(li);
    });

    const hide = document.createElement("div");
    hide.className = "toggle";
    hide.textContent = "Hide others";
    hide.addEventListener("click", () => { if (isLeft) { __expanded_L = false; } else { __expanded_R = false; } renderCard(side); });
    list.appendChild(hide);
  }

  function observeAndKick(){
    const tbl = findMainTable(); if (!tbl) return;
    const tbody = tbl.querySelector("tbody"); if (!tbody || !('MutationObserver' in window)) return;
    const mo = new MutationObserver(() => { renderCard("left"); renderCard("right"); });
    mo.observe(tbody, { childList:true, subtree:true, characterData:true });
    // initial + warmup
    let tries=0; const iv=setInterval(()=>{ tries++; renderCard("left"); renderCard("right"); if(tries>20) clearInterval(iv); }, 500);
  }

  // Collapse/expand header toggles for both cards
  function setupCollapses(){
    const pairs = [
      ["ntHeader", "ntContent", "nextTargetCard"],
      ["nytHeader","nytContent","nextYearTargetCard"]
    ];
    pairs.forEach(([hId, cId, cardId]) => {
      const header = document.getElementById(hId);
      const content = document.getElementById(cId);
      const card = document.getElementById(cardId);
      if (!header || !content || !card) return;
      header.addEventListener("click", () => {
        card.classList.toggle("collapsed");
        content.style.display = card.classList.contains("collapsed") ? "none" : "block";
      });
    });
  }

  // Defer actual start until DOM ready (script is defer, but just to be safe)
  function start(){ setupCollapses(); observeAndKick(); }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start);
  else start();
})();
</script>
<style id="miniCards-styles">
/* Shared look for both mini cards */
:root{
  --card-bg: rgba(255,255,255,0.94);
  --card-border: rgba(0,0,0,0.12);
  --shadow-1: 0 10px 24px rgba(0,0,0,0.10);
  --shadow-2: 0 1px 6px rgba(0,0,0,0.06);
}
#nextTargetCard, #nextYearTargetCard {
  position: fixed !important;
  top: 60px !important;
  min-width: 210px !important;
  max-width: 240px !important;
  padding: 8px 10px !important;
  background: var(--card-bg) !important;
  border: 1px solid var(--card-border) !important;
  border-radius: 12px !important;
  box-shadow: var(--shadow-1), var(--shadow-2) !important;
  z-index: 2147482800 !important;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}
/* Enlarge left card by 30% for more noticeable difference */
#nextTargetCard {
  min-width: 273px !important;
  max-width: 312px !important;
  transform: scale(1.1) !important;
  transform-origin: top right !important;
}
/* Keep positions mirrored (both on right) */
#nextTargetCard { right: 16px !important; left: auto !important; }
#nextYearTargetCard { right: 16px !important; left: auto !important; }

/* Inner layout identical */
#nextTargetCard .mini-header, #nextYearTargetCard .mini-header{
  display:flex; align-items:center; justify-content:space-between;
  gap:8px; padding:6px 8px 6px 10px; cursor:pointer; user-select:none;
}
#nextTargetCard .mini-header h4, #nextYearTargetCard .mini-header h4{
  margin:0; font-size: 13px; font-weight:700; letter-spacing:.1px;
}
#nextTargetCard .content, #nextYearTargetCard .content{
  padding: 6px 10px 10px 10px; max-height: 260px; overflow:auto;
}
#nextTargetCard ul, #nextYearTargetCard ul{ margin:0; padding:0; list-style:none; }
#nextTargetCard li, #nextYearTargetCard li{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:5px 0; border-bottom:1px dashed rgba(0,0,0,0.06); font-size: 13px;
}
#nextTargetCard li:last-child, #nextYearTargetCard li:last-child{ border-bottom:none; }
#nextTargetCard li .month, #nextYearTargetCard li .month{ font-weight:600; opacity:.9; }
#nextTargetCard li .amt, #nextYearTargetCard li .amt{ font-weight:700; }
#nextTargetCard li .bal, #nextYearTargetCard li .bal{ font-weight:600; opacity:.7; }
#nextTargetCard .topline, #nextYearTargetCard .topline { font-weight: 700; }
#nextTargetCard .toggle, #nextYearTargetCard .toggle {
  display:inline-block; margin-top:6px; font-size: 12px; opacity:.8; cursor:pointer; text-decoration:underline;
}
#nextTargetCard .countchip, #nextYearTargetCard .countchip { font-size: 12px; opacity:.75; margin-left:6px; }
.neg { color: red; font-weight: 600; }

@media (max-width: 700px){
  #nextTargetCard{ top: 56px !important; left: 10px !important; }
  #nextYearTargetCard{ top: 56px !important; right: 10px !important; }
}
</style>
<style id="pdf-hardening">
/* --- Absolute PDF hardening --- */
@page {
  size: A4 portrait;
  margin: 12mm;
}
@media print {
  /* Disable sticky headers */
  thead th, thead td { position: static !important; top: auto !important; }
  /* Avoid page breaks inside critical blocks */
  header, .card, .tableCard, table, .months-mini, .modal, #chartCard, #generalNotesCard { break-inside: avoid !important; page-break-inside: avoid !important; }
  /* Ensure tables wrap nicely */
  table { table-layout: auto !important; width: 100% !important; }
  td, th { white-space: normal !important; word-break: break-word !important; }
  /* Clamp any accidental overflows */
  html, body, .wrap { overflow: visible !important; }
  * { overflow-wrap: anywhere !important; }
  /* Remove heavy effects */
  *, *::before, *::after {
    box-shadow: none !important;
    text-shadow: none !important;
    filter: none !important;
    animation: none !important;
    transition: none !important;
    backdrop-filter: none !important;
  }
  /* Flatten header visuals */
  header {
    background: #ffffff !important;
    border: 1px solid #eee !important;
    box-shadow: none !important;
  }
  header::before, header::after, header .floating-particles, header .shimmer, header .sparkle, header .light-beam { display: none !important; }
  /* Ensure gauge text stays inside */
  .gaugeWrapper { overflow: hidden !important; }
  .gaugeText {
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    max-width: 64% !important;
    width: 64% !important;
    text-align: center !important;
  }
  /* Lighter fonts */
  body { font-size: 13px !important; line-height: 1.38 !important; color: #111 !important; }
  h1, h2, h3 { font-weight: 600 !important; }
  /* Remove gradient backgrounds on pills/badges */
  .month-pill, .nextBadge { background: #fff !important; }
  .month-pill.next { border: 1px solid #ddd !important; box-shadow: none !important; }
}
</style>
<style id="pdf-hardening-v4">
@page { size: A4 portrait; margin: 10mm; }
@media print {
  /* Hide interactive and nav elements */
  nav, footer, button, input, select, textarea, .ownerToggleBtn, #ownerToggleBtn, #yearPrevBtn, #yearToggleBtn, #darkToggle, #tipToggle, #monthlyLockToggle, #btnToggleFuture, #btnToggleAll {
    display: none !important;
  }
  /* Remove backgrounds and lighten content */
  body, .card, .tableCard, header, .month-pill, .progressValue, .progressBar, .chip, .badge {
    background: #fff !important;
    color: #111 !important;
    border: 1px solid #ddd !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
  }
  /* Remove background images */
  * { background-image: none !important; }
  /* Reset transforms and effects */
  *, *::before, *::after {
    transform: none !important;
    text-shadow: none !important;
    box-shadow: none !important;
    filter: none !important;
    animation: none !important;
    transition: none !important;
    backdrop-filter: none !important;
  }
  /* Avoid page breaks inside major components */
  .card, .tableCard, .notes, .charts, #chartCard, #generalNotesCard, header, .row {
    break-inside: avoid !important;
    page-break-inside: avoid !important;
  }
  /* Constrain widths and wrap to avoid overflow */
  html, body {
    width: 100% !important;
    overflow: visible !important;
    font-size: 10.5px !important;
    line-height: 1.45 !important;
  }
  table {
    width: 100% !important;
    table-layout: fixed !important;
    word-break: break-word !important;
  }
  th, td {
    white-space: normal !important;
    word-break: break-word !important;
  }
  /* Clamp gauge text */
  .gaugeWrapper { overflow: hidden !important; }
  .gaugeText {
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    max-width: 66% !important;
    text-align: center !important;
  }
  /* Hide tooltips and overlays */
  .tooltip, .modal, .overlay, .backdrop, .drawer {
    display: none !important;
  }
}
</style>
<style id="print-leak-guard">
@media print {
  pre, code, .debug, .dev, .script-dump, [data-dev], [data-debug] {
    display: none !important;
    visibility: hidden !important;
  }
}
</style>
<style id="page-background-image-fixed">
  /* Strong override so the wallpaper wins even with kill-all !important rules */
  html, body {
    background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg') !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    background-attachment: fixed !important;
    min-height: 100% !important;
  }

  /* Make sure it also appears in print/PDF */
  @media print {
    html, body::before {
      -webkit-print-color-adjust: exact !important;
      print-color-adjust: exact !important;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
  }
</style>
<style id="page-wallpaper-override">
  :root { --page-wallpaper: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg'); }

  /* Ensure page itself is transparent and tall */
  html, body {
    height: 100% !important;
    min-height: 100% !important;
    background: transparent !important;
  }

  /* Primary method: a fixed pseudo-layer that always covers the viewport */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;            /* sits behind all content */
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Fallback layer in case some browsers ignore ::before due to stacking contexts */
  #page-wallpaper-layer {
    position: fixed;
    inset: 0;
    z-index: -2;
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Ensure print/PDF keeps the wallpaper */
  @media print {
    html, body::before { 
      -webkit-print-color-adjust: exact !important; 
      print-color-adjust: exact !important; 
    }
    body::before {
      position: fixed;
    }
  }
</style>
<style id="chart-background-restore">
  #chartCard,
  #chartWrapper,
  #chartWrapper canvas {
    background: #ffffff !important;
    border-radius: 8px;   /* rounded edges */
    box-shadow: 0 2px 6px rgba(0,0,0,0.1); /* subtle depth */
  }
</style>
<style id="branding-background-restore">
  .branding-text, #branding, .footer-note {
    display: inline-block;
    background: #ffffff !important;
    padding: 4px 8px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  }
</style>
<style id="legend-css-25pct-v4">
/* Force ~25% smaller custom legend UI */
.legend-item { font-size: 10px !important; gap: 6px !important; }
.legend-color { width: 12px !important; height: 12px !important; border-radius: 3px !important; }
/* Chart.js HTML legend (if used) */
.chartjs-legend li { font-size: 9px !important; }
.chartjs-legend li span { width: 9px !important; height: 9px !important; }
</style>
</head>
<body><div id="odc-ribbon-container" style="position:sticky;top:0;z-index:9999;background:#fafafa;color:#111;padding:8px 12px;margin:4px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 3px rgba(0,0,0,.04);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;font-size: 14px;">
<div id="odc-ribbon" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:center">
<div style="display:flex;gap:16px;flex-wrap:wrap;justify-content:center">
<div style="padding:4px 8px;background:#fff;border-radius:4px;border:1px solid rgba(0,0,0,0.04);"><strong style="color:#666;font-weight:500;">Next Due</strong>: <span id="odc-next-due" style="font-weight:500;color:#333;">—</span> <span id="odc-next-label" style="opacity:.6;font-size: 13px;color:#888;"></span></div>
<div style="padding:4px 8px;background:#fff;border-radius:4px;border:1px solid rgba(0,0,0,0.04);border-left:2px solid #dc3545;"><strong style="color:#dc3545;font-weight:500;">Target</strong>: <span style="color:#666;">AED</span> <span id="odc-required" style="font-weight:500;color:#dc3545;">—</span></div>
<div style="padding:4px 8px;background:#fff;border-radius:4px;border:1px solid rgba(0,0,0,0.04);border-left:2px solid #28a745;"><strong style="color:#28a745;font-weight:500;">Actual Inflow</strong>: <span style="color:#666;">AED</span> <span id="odc-cumcr" style="font-weight:500;color:#28a745;">—</span></div>
<div style="padding:4px 8px;background:#fff;border-radius:4px;border:1px solid rgba(0,0,0,0.04);border-left:2px solid #f39c12;"><strong style="color:#f39c12;font-weight:500;">Gap to meet</strong>: <span id="odc-gap" style="font-weight:500;color:#e67e22;">—</span></div>
</div>
<div style="display:flex;gap:14px;align-items:center">
</div>
</div>
<div id="odc-panel" style="display:none;margin-top:10px;background:rgba(255,255,255,.15);padding:10px;border-radius:10px">
<div style="display:flex;gap:16px;flex-wrap:wrap">
<label>OD Limit (AED) <input id="odc-od-limit" style="border-radius:8px;border:1px solid rgba(255,255,255,.4);padding:4px 8px;background:#fff;color:#111;width:140px" type="number"/></label>
<label>EOD Balance on due (AED) <input id="odc-od-balance" placeholder="negative if overdrawn" style="border-radius:8px;border:1px solid rgba(255,255,255,.4);padding:4px 8px;background:#fff;color:#111;width:180px" type="number"/></label>
<button id="odc-save" style="border:0;border-radius:8px;padding:6px 12px;background:#111;color:#fff;cursor:pointer">Save</button>
</div>
<div id="odc-note" style="margin-top:6px;font-size: 13px;opacity:.9">Utilisation% = max(0, -EOD / Limit) × 100 • values stored locally</div>
</div>
</div>
<!-- per-year: removed global wipe block -->
<div aria-hidden="true" class="__tip" id="__tooltip" role="tooltip"></div>
<div class="wrap">
<header>
<div class="floating-particles">
<div class="particle"></div>
<div class="particle"></div>
<div class="particle"></div>
<div class="particle"></div>
<div class="particle"></div>
</div>
<!-- Shimmer effect -->
<div class="shimmer"></div>
<!-- Light beam effect -->
<div class="light-beam"></div>
<!-- Sparkle effects -->
<div class="sparkle"></div>
<div class="sparkle"></div>
<div class="sparkle"></div>
<div class="sparkle"></div>
<div class="sparkle"></div>
<div class="headerTopFull">
<div class="title-left">
<div style="display:flex; flex-direction:column;">
<h1 id="enbd-title" style="font-weight:600;font-size: 18px;color:#111;margin-top:7mm;">ENBD Performance Tracker</h1>
<!-- Creator credit moved below the title -->
<p class="tiny owner-name-chalk" style='margin-top:6px;;color:#111;font-family:"Chalkboard","Chalkboard SE","Bradley Hand","Comic Sans MS",cursive;font-size: 15px;'>created by Fuad Al-Taher</p>
</div>
<div class="owner-middle">
<div class="owner-container group-frame">
<h2 class="owner-name" id="ownerNameDisplay" style="font-size: 35px; color:var(--accent); margin:0; padding:0; text-align:center;"></h2>
<button class="ownerToggleBtn" id="ownerToggleBtn" title="Change owner (if Edit is unlocked, password is q)">★</button>
<input id="yearInput" max="2100" min="2000" step="1" style="width:70px; text-align:center;" type="number"/>
<span aria-hidden="true" class="title-star">🌟</span>
<h2 class="owner-name owner-theme-9" id="yearFancy" style="font-size: 26px; margin:0 6px; display:inline-block;" tabindex="0">—</h2>
<button class="ownerToggleBtn" id="yearPrevBtn" title="Previous year (click)">☆</button>
<button class="ownerToggleBtn" id="yearToggleBtn" title="Next year (click) — also use mouse wheel/Arrow keys on the year">★</button>
<select aria-label="Select owner" id="ownerSelect">
<option value="owner1">SHTHA_ENBD</option>
<option value="owner2">Owner 2</option>
<option value="owner3">Owner 3</option>
<option value="owner4">Owner 4</option>
<option value="owner5">Owner 5</option>
<option value="owner6">Owner 6</option>
<option value="owner7">Owner 7</option>
<option value="owner8">Owner 8</option>
<option value="owner9">Owner 9</option>
<option value="owner10">Owner 10</option>
</select>
</div>
</div>
</div>
<div class="headerTop">
<!-- Year selector for editing year -->
<!-- Star icon moved after the year input to align with the title -->
</div>
</div>
<div class="right">
<!-- Prominent Next Needed badge (mirrors main alert) -->
<div aria-live="polite" class="nextBadge next-needed-ribbon" id="nextNeededBadge">
<span class="label">Next needed:</span>
<span class="pill" id="nextBadgeMonth">—</span>
<span class="amount" id="nextBadgeAmount">—</span>
<span class="days" id="nextBadgeDays">—</span>
<div class="tiny muted smallDate">Local: <span id="localDate"></span></div>
<div class="tiny muted smallDate">Saved: <span id="savedAt">—</span></div>
<div class="controls smallControls">
<button aria-label="Toggle edit lock" class="ghost small" id="monthlyLockToggle" title="Unlock to edit monthly fields">🔒 Lock</button>
<button aria-label="Toggle dark mode" class="ghost small" id="darkToggle">🌙</button>
<button aria-label="Toggle tooltips" class="ghost small" id="tipToggle">💬 Tips</button>
</div>
</div>
</div>
</header>
<!-- ALL YEARS TARGET WIDGET -->
<div id="allYearsWidget" style="position: fixed; top: 26px; left: 20px; z-index: 10000; background: linear-gradient(135deg, #ffffff 0%, #f0f8ff 50%, #e6f3ff 100%); padding: 4px 8px; border-radius: 8px; box-shadow: 0 4px 16px rgba(135,206,235,0.2); font-size: 11px; font-family: monospace; max-width: 180px; border: 1px solid rgba(135,206,235,0.3);">
<div onclick="toggleAllYearsDropdown()" style="font-weight: bold; color: #4a8d85; margin-bottom: 2px; text-align: center; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; gap: 4px;">
<span>🎯</span>
<span id="targetCounter" style="font-size: 9px; background: rgba(135,206,235,0.15); padding: 1px 4px; border-radius: 4px; min-width: 16px; color: #2c5282;">12</span>
<span id="dropdownArrow" style="font-size: 8px;">▼</span>
</div>
<div id="allYearsContent" style="display: none; max-height: 400px; overflow-y: auto; font-size: 12px; z-index: 10001; position: relative; background: rgba(255,255,255,0.99); border: 1px solid rgba(135,206,235,0.2); border-radius: 6px; margin-top: 4px; box-shadow: 0 2px 12px rgba(135,206,235,0.15);">
<div style="color: #666;">Loading...</div>
</div>
</div>
<div class="top">
<div class="card">
<div class="summary">
<style id="kpi-force-two-lines">
/* Force KPI strip to wrap into two lines (preferred) */
#kpiCompactStrip{
  display:flex !important;
  flex-wrap:wrap !important; /* allow wrapping */
  gap:8px !important;
  padding:8px !important;
  align-items:stretch !important;
}
#kpiCompactStrip .kpi-item{
  overflow: visible;
  position: relative; /* allow per-item pseudo separators */
  min-width:120px !important;
  box-sizing:border-box !important;
  padding:6px 8px !important;
}
@media (max-width:1100px){
  #kpiCompactStrip .kpi-item{ flex:0 0 48% !important; }
}
</style>
<div class="row kpi-old-area"><div class="kpi-strip" id="kpiCompactStrip">
<div class="kpi-item"><div class="kpi-label">🎯 Adjusted Target</div><div class="kpi-value"><span id="kpiVal_target">—</span></div></div>
<div class="kpi-item"><div class="kpi-label">📈 YTD Inflow</div><div class="kpi-value"><span id="kpiVal_ytd">—</span></div></div>
<div class="kpi-item"><div class="kpi-label">💰 Balance</div><div class="kpi-value"><span id="kpiVal_rem">—</span></div></div>
<div class="kpi-item"><div class="kpi-label">🏦 Opening Balance</div><div class="kpi-value"><span id="kpiVal_ob">—</span></div></div>
<!-- Compact KPIs: reduced padding and font-size -->
<div class="kpi-item" style="padding:4px 6px; min-width:68px; box-sizing:border-box;"><div class="kpi-label" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Avg. Mo. Target</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_avgMonthly">—</span></div></div>
<div class="kpi-item" style="padding:4px 6px; min-width:68px; box-sizing:border-box;"><div class="kpi-label" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Avg. Mo. Inflow</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_avgActualMonthly">—</span></div></div>
<div class="kpi-item" style="padding:4px 6px; min-width:82px; box-sizing:border-box;"><div class="kpi-label" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Mo. Variance</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_monthlyVariance">—</span></div></div>
<div class="kpi-item" style="padding:4px 6px; min-width:82px; box-sizing:border-box;"><div class="kpi-label" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Total Deviation</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_deviation">—</span></div></div>
<div class="kpi-item" style="padding:4px 6px; min-width:82px; box-sizing:border-box;"><div class="kpi-label" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Forecasted Year‑End</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_forecast">—</span></div></div>
<div class="kpi-item" style="padding:4px 6px; min-width:82px; box-sizing:border-box;"><div class="kpi-label" id="kpiLabel_monthlyNeeded" style="font-weight:600 !important; font-size: 9px !important; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">📊 Mo. Needed Inflow</div><div class="kpi-value" style="font-weight:700 !important; font-size: 13px !important; white-space:nowrap;"><span id="kpiVal_monthlyNeeded">—</span></div></div>
</div>
<!-- KPI wrap override: inserted to force a predictable two-line layout -->
<style id="kpi-force-two-lines-override">
  /* Ensure this override wins: use ID selector + !important */
  #kpiCompactStrip{ display:flex !important; flex-wrap:wrap !important; gap:12px !important; align-items:flex-start !important; }
  #kpiCompactStrip .kpi-item{ flex: 1 1 220px !important; min-width:160px !important; box-sizing:border-box !important; padding:6px 8px !important; }
  /* On narrow screens prefer two items per row */
  @media (max-width:1200px){
    #kpiCompactStrip .kpi-item{ flex: 1 1 45% !important; min-width:40% !important; }
  }
  /* Slightly reduce label/value size to help fit */
  #kpiCompactStrip .kpi-label{ font-size: 11px !important; }
  #kpiCompactStrip .kpi-value{ font-size: 18px !important; }
</style>
<style id="kpi-targeted-center">
  /* Center only the KPI numeric spans listed by ID (safe, narrow scope) */
  #kpiCompactStrip span#kpiVal_target,
  #kpiCompactStrip span#kpiVal_ytd,
  #kpiCompactStrip span#kpiVal_rem,
  #kpiCompactStrip span#kpiVal_ob,
  #kpiCompactStrip span#kpiVal_avgMonthly,
  #kpiCompactStrip span#kpiVal_avgActualMonthly,
  #kpiCompactStrip span#kpiVal_forecast,
  #kpiCompactStrip span#kpiVal_monthlyVariance,
  #kpiCompactStrip span#kpiVal_deviation,
  #kpiCompactStrip span#kpiVal_monthlyNeeded {
    display: block !important;
    text-align: center !important;
    margin: 0 auto !important;
    width: 100% !important;
  }

  /* Center the top dashboard big numbers only (keep other layout intact) */
  #dashYearlyTarget, #dashYtdAccomplished, #dashRemaining, #dashOpeningBalance {
    text-align: center !important;
    margin: 0 auto !important;
    display: block !important;
  }
</style>
<style id="kpi-style-enhance">
  /* Visual polish for KPI tiles (colors, shadows, subtle hover) */
  #kpiCompactStrip .kpi-item {
    background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(247,251,250,0.98));
    border: 1px solid rgba(11,59,54,0.06);
    border-radius: 12px;
    box-shadow: 0 6px 18px rgba(11,59,54,0.05);
    transition: transform .22s cubic-bezier(.2,.9,.3,1), box-shadow .22s ease, filter .22s ease;
    overflow: hidden;
  }
  #kpiCompactStrip .kpi-item:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 14px 36px rgba(11,59,54,0.10);
    filter: saturate(1.03);
  }
  #kpiCompactStrip .kpi-label {
    color: #2f6f68;
    opacity: 0.95;
  }
  #kpiCompactStrip .kpi-value { 
    color: #0b3b36;
    font-family: 'Poppins', sans-serif;
    padding: 2px 6px;
    border-radius: 6px;
  }
  #kpiCompactStrip .kpi-value span {
    display:inline-block;
    background: linear-gradient(90deg,#0b3b36,#2e8b66);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight:800;
  }
  /* subtle entrance pop */
  @keyframes kpiPop { from{ transform: translateY(6px) scale(.995); opacity:0 } to{ transform: translateY(0) scale(1); opacity:1 } }
  #kpiCompactStrip .kpi-item { animation: kpiPop .32s ease both; }
  /* small badge for positive/negative using existing classes */ 
  .kpi-pos { text-shadow: 0 2px 6px rgba(46,139,102,0.08); }
  .kpi-neg { text-shadow: 0 2px 6px rgba(212,107,107,0.06); }
  /* keep monthly pills untouched (explicit) */ 
  .month-pill, .months-mini { transition: none !important; }
</style>
<style id="kpi-separator-fix">
  /* Reliable two-line separator on every KPI item except the very first */
  #kpiCompactStrip .kpi-item:not(:first-child)::before{
    content: '';
    position: absolute;
    left: -18px;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    pointer-events: none;
    z-index: 60;
    background: linear-gradient(transparent 42%, rgba(0,0,0,0.14) 42%, rgba(0,0,0,0.14) 46%, transparent 46%, transparent 54%, rgba(0,0,0,0.14) 54%, rgba(0,0,0,0.14) 58%, transparent 58%);
    background-size: 100% 50%;
    background-repeat: no-repeat;
    opacity: 1;
  }
  /* Hide the older sibling-based after rule to avoid duplicates */
  .kpi-item + .kpi-item::after { display: none !important; }
</style>
<div>
<div style="display:flex; align-items:center; gap:6px;">
<div class="small" style="font-size: 11px; line-height:1;">Early Target 🎯</div>
</div>
<div class="big" data-tip="—" data-tip-label="Early Target" id="dashYearlyTarget" style="color: #1E90FF; font-size: 19px; line-height:1;">0</div>
<div class="small" id="dashTargetNote" style="margin-top:2px; opacity:0.9; font-size: 11px; line-height:1;"></div>
</div>
<div>
<div style="display:flex; align-items:center; gap:6px;">
<div class="small" style="font-size: 11px; line-height:1;">Opening Balance 🏦</div>
</div>
<div class="big" data-tip="—" data-tip-label="Opening Balance" id="dashOpeningBalance" style="color:#8B008B; font-size: 19px; line-height:1;">0</div>
</div>
<div>
<div style="display:flex; align-items:center; gap:6px;">
<div class="small" style="font-size: 11px; line-height:1;">YTD Actual Inflow (Past History) 💰</div>
</div>
<div class="big" data-tip="—" data-tip-label="YTD Actual Inflow (Past History)" id="dashYtdAccomplished" style="color: var(--green); font-size: 19px; line-height:1;">0</div>
</div>
<div>
<div style="display:flex; align-items:center; gap:6px;">
<div class="small" style="font-size: 11px; line-height:1;">Remaining 📉</div>
</div>
<div class="big" data-tip="—" data-tip-label="Remaining" id="dashRemaining" style="color: var(--red); font-size: 19px; line-height:1;">0</div>
</div>
<div class="gaugeWrapper">
<div class="small">Year Progress 📅</div>
<canvas aria-label="Year progress gauge" height="108" id="gaugeChart" width="120"></canvas>
<canvas aria-hidden="true" height="108" id="gaugeMonthsOverlay" style="position:absolute; inset:0; pointer-events:none;" width="120"></canvas>
</div>
</div>
<div class="progressWrap modern-progress">
<div style="display:flex; gap:10px;">
<div style="flex:1;">
<div class="progressRow">
<div class="progressLabel">Inflow Achieved</div>
<div class="progressValue" id="progressCompletionValue">0</div>
</div>
<div class="progressBar bar">
<div class="fillGreen" id="progressFill"></div>
<div class="tooltip" id="completionTooltip">0 AED</div>
</div>
</div>
<div style="flex:1;">
<div class="progressRow">
<div class="progressLabel">Remaining to Target</div>
<div class="progressValue" id="progressTargetValue">0</div>
</div>
<div class="progressBar bar">
<div class="fillRed" id="targetFill"></div>
<div class="tooltip" id="targetTooltip">0 AED</div>
</div>
</div>
</div>
</div>
<div style="display:flex; justify-content:space-between; align-items:center; margin-top:0px;">
<div>
<div class="tiny muted">Monthly progress 📊</div>
<div class="tiny" id="dashNextText"></div>
</div>
<div class="topToolbar" id="topToolbar" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
<button aria-label="Show upcoming months" class="ghost small" id="btnToggleFuture" title="Toggle show only upcoming months">Upcoming</button>
<button aria-label="Show all months" class="ghost small" id="btnToggleAll" title="Show all months">All</button>
<button aria-label="Export to Excel" class="small" id="btnExportExcel">📄 Excel</button>
<button aria-label="Import from Excel" class="small" id="btnImportExcel">📥 Import</button>
<button aria-label="Export to PDF" class="ghost small" id="btnExportPDF">PDF</button><button aria-label="Generate report" class="ghost small" id="btnGenerateReport">📑 Report</button><button aria-label="Print" class="ghost small" id="btnPrint">🖨 Print</button><button class="ghost small btn-refresh" id="btnHardRefresh" title="Hard Refresh">⟳ Refresh</button></div>
</div>
<div class="nextAlert" id="nextContainer" style="display:none;">
<div id="nextLeft" style="display:flex; gap:10px; align-items:center;">
<div class="pill" id="nextMonthPill"></div>
<div>
<div class="tiny muted">Next needed 🚀</div>
<div class="big" id="nextText"></div>
</div>
</div>
<div style="text-align:right;">
<div class="tiny muted">Days to next ⏳</div>
<div class="big" id="nextDays"></div>
</div>
</div>
<div aria-label="Monthly progress overview" class="months-mini" id="monthsMini"></div>
</div>
</div>
<div class="card" id="chartCard">
<div class="tiny muted" id="nextJanTiny" style="color:#e3b04b; font-weight:600; text-align:right; font-size: 13px; opacity:0.9; letter-spacing:0.2px; margin:2px 0 4px; text-align:left;"></div>
<div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
<div>
<div style="font-weight:700;color:var(--text-bold); font-size: 9px; font-weight:500; opacity:0.9">Monthly Performance 📈</div>
</div>
<div style="display:flex; gap:8px; align-items:center;">
<button aria-label="Toggle chart view" class="ghost small" id="btnToggleView" title="Switch between monthly and cumulative view">📊 Toggle View</button>
<button aria-label="AI Analysis" class="ghost small" id="btnAIAnalysis" title="Generate AI-powered performance analysis">🤖 AI Analysis</button>
<button aria-label="Scenario Planning" class="ghost small" id="btnScenarioPlanning" title="What-if analysis and scenario planning">🎯 Scenarios</button>
<button aria-label="Monthly Notes" class="ghost small" id="btnMonthlyNotes" title="Write notes for each month">📒 Notes</button>
</div>
</div>
<div id="chartWrapper" style="margin-top:2px;">
<canvas aria-label="Monthly performance chart" id="performanceChart"></canvas>
</div>
</div>
</div>
<div class="card" id="generalNotesCard" style="margin-top:8px; padding:12px;">
<div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
<div style="font-weight:700;">General Notes 📝</div>
<div style="display:flex; align-items:center; gap:8px;">
<span class="tiny muted">These notes are saved per owner and year.</span>
<label class="tiny muted" for="noteColor" style="white-space:nowrap;">Font Color:</label>
</div>
</div>
<textarea id="generalNotes" placeholder="Write overall notes here..." rows="3" style="width:100%; border-radius:8px; border:1px solid #dfe7e4; padding:8px; font-size: 15px; margin-top:8px;"></textarea>
</div>
<div class="card tableCard group-frame">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div style="display:flex; gap:14px; align-items:center;">
<div style="font-weight:700">Monthly Details 📋</div>
<div class="tiny muted">Inline edit when unlocked • notes &amp; key dates available</div>
</div>
<div style="display:flex; gap:8px; align-items:center;">
<button aria-label="Reset all data" class="ghost small" id="btnReset">Reset</button>
</div>
</div>
<table aria-label="Performance tracker table" class="group-outline-table">
<thead>
<tr>
<!-- Shift the Brought Forward cell so that it begins above the Expected Inflow column (column 7). There are six columns before Expected Inflow (Key Dates, Days to Next, Project, Notes, Target, Month). -->
<th colspan="7" style="border:none;"></th>
<th colspan="4" style="padding:4px 10px; font-size: 13px; color:var(--muted);
  white-space:nowrap; text-align:right;">
<div style="display:flex; justify-content:flex-end; align-items:center; gap:6px; width:100%;">
<span>BROUGHT FORWARD</span>
<span id="bfValue" style="color:var(--gold); font-weight:700;"></span>
<button aria-label="Brought forward info" class="iconBtn" id="bfInfoBtn" title="What is Brought Forward?">ℹ️</button>
<button aria-label="Edit Brought Forward note" class="iconBtn" id="bfNoteBtn" style="color: var(--gold); border: 1px solid var(--gold); background: rgba(227,176,75,0.1); font-size: 17px;" title="Add note for Brought Forward">📝</button>
</div>
</th>
</tr>
<tr>
<th colspan="11" style="text-align:center; background:transparent; border:none; padding:4px 0;">
<button aria-label="Toggle edit lock (mirror)" class="ghost small" id="monthlyLockToggle2" title="Unlock to edit monthly fields (Mirror)">🔒 Lock</button>
</th>
</tr>
<tr>
<!-- New column order: Row No, Key Dates, Days to Next, Project, Notes, Target, Month, Expected Inflow, Actual Inflow (Past History), Variance, Balance -->
<th class="tinyCol">#</th>
<th class="smallCol">Key Dates</th>
<th class="tinyCol">Days to Next</th>
<th class="projectCol">Project</th>
<th class="notesCol">Notes</th>
<th class="smallCol">Target</th>
<th class="monthCol">Month</th>
<th>Expected Inflow</th>
<th>Actual Inflow</th>
<th>Variance</th>
<th>Balance</th>
</tr>
</thead>
<tbody id="tableBody"></tbody>
<tfoot>
<tr>
<th>Total</th>
<th></th><th></th><th></th><th></th>
<th id="monthlyTarget">0</th>
<th></th>
<th></th>
<th id="ytdAccomplished">0</th>
<th id="totalVariance">0</th>
<th id="accumulatedVariance">0</th>
</tr>
</tfoot>
</table>
<div aria-label="Monthly variance heatmap" class="heatmapRow" id="heatmapRow" style="margin-top:2px;"></div>
</div>
<div style="display:flex; justify-content:flex-end; gap:4px; margin-top:4px; margin-bottom:14px;">
<button aria-label="Change owner name" class="ghost small" id="btnChangeName" style="font-size: 11px; padding:3px 5px;">Change Name</button>
<button aria-label="Change password" class="ghost small" id="btnChangePassword" style="font-size: 11px; padding:3px 5px;">Change Password</button>
</div>
<div aria-label="Notes editor" aria-modal="true" class="modal" id="notesModal" role="dialog">
<h3 style="margin:0">Notes 📝</h3>
<button aria-label="Close notes modal" class="close-btn" id="notesCloseBtn" title="Close">×</button>
<textarea aria-label="Notes input" id="notesTextarea" placeholder="Enter notes..." rows="6"></textarea>
<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:-2px;">
<button aria-label="Clear notes" class="ghost" id="notesClearBtn">Erase</button>
<button aria-label="Cancel" class="ghost" id="notesCancelBtn">Cancel</button>
<button aria-label="Save notes" id="notesSaveBtn">Save</button>
</div>
</div>
<div aria-label="Key dates editor" aria-modal="true" class="modal" id="dateModal" role="dialog">
<h3 style="margin:0">Select Key Dates 📅</h3>
<button aria-label="Close date modal" class="close-btn" id="dateCloseBtn" title="Close">×</button>
<input aria-label="First key date" id="dateInput1" type="date"/>
<input aria-label="Second key date" id="dateInput2" type="date"/>
<input aria-label="Third key date" id="dateInput3" type="date"/>
<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:-2px;">
<button aria-label="Clear dates" class="ghost" id="dateClearBtn">Erase</button>
<button aria-label="Cancel" class="ghost" id="dateCancelBtn">Cancel</button>
<button aria-label="Save dates" id="dateSaveBtn">Save</button>
</div>
</div>
<div aria-label="Project editor" aria-modal="true" class="modal" id="projectModal" role="dialog">
<h3 style="margin:0">Project 📋</h3>
<button aria-label="Close project modal" class="close-btn" id="projectCloseBtn" title="Close">×</button>
<input aria-label="Project input" id="projectInput" placeholder="Enter project name..." type="text"/>
<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:-2px;">
<button aria-label="Clear project" class="ghost" id="projectClearBtn">Erase</button>
<button aria-label="Cancel" class="ghost" id="projectCancelBtn">Cancel</button>
<button aria-label="Save project" id="projectSaveBtn">Save</button>
</div>
</div>
<div aria-label="AI Analysis" aria-modal="true" class="modal ai-analysis-modal" id="aiAnalysisModal" role="dialog">
<div class="ai-modal-inner" onclick="event.stopPropagation()">
<div class="ai-modal-header">
<h3>🤖 AI Performance Analysis</h3>
<div class="ts">Generated: <span id="analysisTimestamp">—</span></div>
</div>
<div style="max-height:60vh; overflow-y:auto;">
<pre id="aiAnalysisContent"></pre>
</div>
<div class="sharing-buttons">
<button aria-label="Copy AI Analysis to Clipboard" class="ghost" id="copyAIAnalysisBtn" title="Copy to clipboard">Copy</button>
<button aria-label="Share AI Analysis via WhatsApp" class="ghost" id="shareWhatsAppBtn" title="Share via WhatsApp">WhatsApp</button>
<button aria-label="Share AI Analysis via Email" class="ghost" id="shareEmailBtn" title="Share via email">Email</button>
<button aria-label="Export AI Analysis" class="ghost" id="exportAIAnalysisBtn">Export</button>
<button aria-label="Close AI Analysis" class="ghost" id="closeAIAnalysisBtn">Close</button>
</div>
<!-- Optional quick note for sharing -->
<div class="sharing-note" style="display:flex; gap:8px; align-items:center; justify-content:center; margin-top:8px;">
<input id="shareOptionalNote" placeholder="Optional note 1 (e.g., summary)" style="width:33%; padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); font-size: 14px;"/>
<input id="shareOptionalNote2" placeholder="Optional note 2 (e.g., action/request)" style="width:33%; padding:8px 10px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); font-size: 14px;"/>
<button aria-label="Clear notes" class="ghost" id="shareNoteClear" style="padding:6px 10px;" title="Clear notes">Clear</button>
</div>
<!-- Share preview modal (reused) -->
<div aria-modal="true" class="modal" id="sharePreviewModal" role="dialog" style="display:none; max-width:720px; width:90vw;">
<div class="ai-modal-inner">
<div class="ai-modal-header">
<h3>Share Preview</h3>
<div class="ts" style="font-size: 14px; color:#444;">Review your analysis and notes below. When ready, click <b>Proceed</b> to choose how to share.</div>
</div>
<div style="max-height:50vh; overflow:auto; background:#fafafa; padding:12px; border-radius:8px; border:1px solid rgba(0,0,0,0.04);">
<div id="sharePreviewNotes" style="color:#c62828; font-weight:600; margin-bottom:8px; white-space:pre-wrap;"></div>
<pre id="sharePreviewContent" style="white-space:pre-wrap; word-wrap:break-word; margin:0; font-size: 14px; color:#222;"></pre>
</div>
<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
<button class="ghost" id="sharePreviewCancel">Cancel</button>
<button class="ghost" id="sharePreviewProceed"><b>Proceed</b> →</button>
</div>
</div>
</div>
<!-- Compact share action picker (appears after Proceed) -->
<div id="shareActionPicker" style="display:none; position:fixed; right:18px; bottom:22px; z-index:12000;">
<div style="background:var(--card); border:1px solid rgba(0,0,0,0.06); border-radius:10px; padding:10px; box-shadow:0 6px 18px rgba(0,0,0,0.08); min-width:260px;">
<div style="font-size: 14px; color:#444; margin-bottom:8px; text-align:center;">Choose how you want to share:</div>
<div style="display:flex; gap:8px; align-items:center; justify-content:center;">
<button class="ghost" id="pickerCopy">Copy</button>
<button class="ghost" id="pickerWhatsApp">WhatsApp</button>
<button class="ghost" id="pickerEmail">Email</button>
<button class="ghost" id="pickerExport">Export</button>
<button class="ghost" id="pickerCancel">Cancel</button>
</div>
</div>
</div>
</div>
</div>
<!-- Scenario Planning Modal -->
<div aria-label="Scenario Planning" aria-modal="true" class="modal ai-analysis-modal" id="scenarioModal" role="dialog">
<div class="ai-modal-inner" onclick="event.stopPropagation()">
<div class="ai-modal-header">
<h3>🎯 Scenario Planner</h3>
<div class="ts">See your year-end result if you keep this pace, or try different inflow boosts.</div>
</div>
<div style="max-height:70vh; overflow-y:auto;">
<div class="scenario-section" style="margin-bottom:18px;">
<h4>Current Trend</h4>
<div aria-live="polite" id="scn-current-summary" role="region" style="font-size: 16px; color:#333; margin-bottom:8px;"></div>
</div>
<div class="scenario-section" style="margin-bottom:18px;">
<h4>Try a Change</h4>
<div style="display: flex; flex-direction: column; gap: 16px; max-width: 500px;">
<!-- Two columns for the input fields -->
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
<div style="display: flex; flex-direction: column; gap: 2px;">
<!-- Added explanatory tooltip on label and input -->
<label for="scn-monthly-inc" style="font-weight: 600; color: var(--text); font-size: 11px;" title="Enter the extra amount you will add to your monthly inflow in each remaining month. This increases your average monthly inflow used for projections. Use negative numbers to model a decrease. For example, entering 10000 means an additional AED 10,000 will be added to each remaining month.">Monthly Increase (AED):</label>
<input id="scn-monthly-inc" step="1000" style="width: 100%; padding: 4px 6px; border: 1px solid var(--muted); border-radius: 4px; font-size: 13px; background: var(--card); color: var(--text);" title="Additional monthly inflow (positive to increase, negative to decrease) that is applied to each remaining month in your projection." type="number" value="0"/>
</div>
<div style="display: flex; flex-direction: column; gap: 2px;">
<label for="scn-oneoff" style="font-weight: 600; color: var(--text); font-size: 11px;" title="Specify a single lump-sum inflow on top of your regular monthly inflow. This amount is applied once at the start of the projection and is useful for modelling bonuses or large irregular payments. For example, enter 50000 if you expect a AED 50,000 bonus.">One-off Inflow (AED):</label>
<input id="scn-oneoff" step="1000" style="width: 100%; padding: 4px 6px; border: 1px solid var(--muted); border-radius: 4px; font-size: 13px; background: var(--card); color: var(--text);" title="A one-time deposit applied at the start of the projection. Useful for modelling a bonus, tax refund, or any large irregular payment." type="number" value="0"/>
</div>
<div style="display: flex; flex-direction: column; gap: 2px;">
<label for="scn-newtarget" style="font-weight: 600; color: var(--text); font-size: 11px;" title="Optionally set a different annual inflow target for the scenario. If you provide a value here, the projection will compare outcomes against this new target instead of your existing annual target. Leave it blank to use your current target.">New Target (AED):</label>
<input id="scn-newtarget" placeholder="(optional)" style="width: 100%; padding: 4px 6px; border: 1px solid var(--muted); border-radius: 4px; font-size: 13px; background: var(--card); color: var(--text);" title="An optional override for your annual inflow target; projections will use this target if specified." type="number"/>
</div>
<div style="display: flex; flex-direction: column; gap: 2px;">
<label for="scn-growth" style="font-weight: 600; color: var(--text); font-size: 11px;" title="This is the percentage change applied to your average monthly inflow each month over the projection period. A positive value indicates month-over-month growth (e.g. 5 means +5% per month) while a negative value indicates a decline. Use 0 for no growth.">Growth Rate (%):</label>
<input id="scn-growth" step="1" style="width: 100%; padding: 4px 6px; border: 1px solid var(--muted); border-radius: 4px; font-size: 13px; background: var(--card); color: var(--text);" title="Percentage change applied to your average monthly inflow each month (positive or negative)." type="number" value="0"/>
</div>
</div>
<!-- Months Ahead display with inline Reset button -->
<div style="display:flex; align-items:center; gap:8px; margin-top:8px;">
<label for="scn-months-ahead" style="font-weight:600; color:var(--text); font-size: 11px;" title="Specify how many months forward the scenario should run (between 1 and 12). This determines how far out the projections, charts and recommended strategies extend. Leave blank to automatically use the number of months remaining in the current year.">Months Ahead:</label>
<!-- Replace static display with user-editable input for months ahead -->
<input id="scn-months-ahead" max="12" min="1" style="width:50px;height:20px;padding:2px 4px;border:1px solid var(--muted);border-radius:4px;font-size: 11px;background:var(--card);color:#1976d2;font-weight:bold;text-align:center;line-height:1;" title="How many months to project ahead. Accepts values from 1 to 12; leave blank to automatically use months remaining in the year." type="number"/>
<button class="ghost small" id="scn-reset-inline" style="font-size: 11px; padding:2px 6px;" title="Reset months ahead to default (remaining months in the year)">Reset</button>
</div>
</div>
</div>
<div class="scenario-section" style="margin-bottom:18px;">
<h4>Projection</h4>
<div aria-live="polite" id="scn-projection-summary" role="region" style="font-size: 16px; color:#333; margin-bottom:8px;"></div>
<div style="height:260px;margin:10px 0 0 0;">
<canvas id="scn-chart"></canvas>
</div>
</div>
<div class="scenario-section" style="margin-bottom:18px;">
<h4>Action Options to Reach Target</h4>
<div aria-live="polite" id="scn-action-options" role="region" style="font-size: 15px; color:#333; line-height:1.6;"></div>
<div style="background: linear-gradient(135deg, rgba(25,118,210,0.08), rgba(198,40,40,0.08)); padding: 16px; border-radius: 12px; margin: 16px 0; border: 1px solid rgba(25,118,210,0.2);">
<h5 style="margin: 0 0 12px 0; color: #1976d2; font-size: 17px; font-weight: 600;">🚀 Share Your Complete Scenario Analysis</h5>
<p style="margin: 0 0 12px 0; font-size: 14px; color: #555; line-height: 1.4;">Share all elements of your scenario analysis including current trend, projections, and action options in a comprehensive, professional format.</p>
<div class="ai-modal-actions" style="display:flex; gap:6px; justify-content:flex-start; margin-top: 29mm; padding-top: 29mm; border-top:1px solid rgba(0,0,0,0.1);">
<button class="ghost small" id="shareEntireScenarioBtn" style="background: linear-gradient(45deg, #25d366, #128c7e); color: white; border: none; font-weight: 600; font-size: 11px; padding: 4px 8px; border-radius: 6px;" title="Share Complete Scenario Analysis">🎯 Share All</button>
<button class="ghost small" id="copyEntireScenarioBtn" style="background: linear-gradient(45deg, #2196f3, #1976d2); color: white; border: none; font-weight: 600; font-size: 11px; padding: 4px 8px; border-radius: 6px;" title="Copy Complete Scenario to Clipboard">📋 Copy All</button>
<button class="ghost small" id="exportEntireScenarioBtn" style="background: linear-gradient(45deg, #ff9800, #f57c00); color: white; border: none; font-weight: 600; font-size: 11px; padding: 4px 8px; border-radius: 6px;" title="Export Complete Scenario as Text File">💾 Export All</button>
<button class="ghost small" id="closeScenarioBtn" style="background: linear-gradient(45deg, #666, #999); color: white; border: none; font-weight: 600; font-size: 11px; padding: 4px 8px; border-radius: 6px;" title="Close Scenario Modal">❌ Close</button>
</div>
</div>
</div>
</div>
</div>
<div class="ai-modal-actions" style="display:flex; gap:8px; justify-content:flex-end;">
<button class="ghost" id="scn-reset">Reset</button>
<button class="ghost" id="scn-close">Close</button>
</div>
</div>
</div>
<!-- Monthly Notes Modal -->
<div aria-label="Monthly Notes" aria-modal="true" class="modal ai-analysis-modal" id="monthlyNotesModal" role="dialog">
<div class="ai-modal-inner" onclick="event.stopPropagation()">
<div class="ai-modal-header">
<h3>📒 Monthly Notes</h3>
<div class="ts" id="notesTs"></div>
</div>
<!-- Notes grid is scrollable to ensure copy/export/close buttons remain visible. -->
<div id="notesGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;max-height:60vh;overflow-y:auto;"></div>
<div class="sharing-buttons" style="margin-top: 29mm;">
<button class="ghost" id="notesCopy">Copy</button>
<button class="ghost" id="notesExport">Export</button>
<button class="ghost" id="notesClose">Close</button>
</div>
</div>
</div>
<script>
// global year variable and storage key
let currentYear = new Date().getFullYear();
function getStorageKey(y){ return 'performanceTracker:'+ y; }
let storageKey = getStorageKey(currentYear);

const months = ["January","February","March","April","May","June","July","August","September","October","November","December"];
const owners = (function(){
  function makeOwner(name, pass = "q") {
    return {
      name,
      password: pass,
      monthlyTargets: new Array(12).fill(0),
      actuals: new Array(12).fill(0),
      expected: new Array(12).fill(0),
      notes: new Array(12).fill(""),
      keyDates: new Array(12).fill(null).map(() => []),
      projects: new Array(12).fill(""),
      broughtForward: 0,
      broughtForwardNote: '',
      generalNotes: '',
      generalNotesColor: '#102027',
      targetColor: '#1E90FF',
      ytdColor: '#2E8B57',
      remainingColor: '#d46b6b',
      colColors: {}
    };
  }
  const o = {};
  for (let i=1;i<=10;i++) {
    let name = 'Owner '+i;
    if (i === 1) name = 'SHTHA_ENBD';
    o['owner'+i] = makeOwner(name, 'q');
    // Clear all data arrays for template
    o['owner'+i].monthlyTargets = new Array(12).fill(0);
    o['owner'+i].actuals = new Array(12).fill(0);
    o['owner'+i].expected = new Array(12).fill(0);
    o['owner'+i].notes = new Array(12).fill("");
    o['owner'+i].keyDates = new Array(12).fill(null).map(() => []);
    o['owner'+i].projects = new Array(12).fill("");
    o['owner'+i].broughtForward = 0;
    o['owner'+i].broughtForwardNote = '';
    o['owner'+i].generalNotes = '';
  }
  return o;
})();
let currentOwner = 'owner1';
let monthlyTargets = owners[currentOwner].monthlyTargets;
let actuals = owners[currentOwner].actuals;
let expected = owners[currentOwner].expected;
let notes = owners[currentOwner].notes;
let keyDates = owners[currentOwner].keyDates;
let projects = owners[currentOwner].projects;
let darkMode = false;
let monthlyEditingEnabled = false;
let showUpcomingOnly = false;
let chartMode = (localStorage.getItem('chartMode') || 'cumulative');
window.tooltipsEnabled = (window.tooltipsEnabled === undefined) ? true : window.tooltipsEnabled;
let tooltipsEnabled = window.tooltipsEnabled;
const elements = {
  ownerSelect: document.getElementById('ownerSelect'),
  dashYearlyTarget: document.getElementById('dashYearlyTarget'),
  dashYtdAccomplished: document.getElementById('dashYtdAccomplished'),
  dashRemaining: document.getElementById('dashRemaining'),
  dashNextText: document.getElementById('dashNextText'),
  progressFill: document.getElementById('progressFill'),
  targetFill: document.getElementById('targetFill'),
  progressTargetValue: document.getElementById('progressTargetValue'),
  progressCompletionValue: document.getElementById('progressCompletionValue'),
  targetTooltip: document.getElementById('targetTooltip'),
  completionTooltip: document.getElementById('completionTooltip'),
  monthsMini: document.getElementById('monthsMini'),
  tableBody: document.getElementById('tableBody'),
  monthlyTargetEl: document.getElementById('monthlyTarget'),
  ytdAccomplishedEl: document.getElementById('ytdAccomplished'),
  totalVarianceEl: document.getElementById('totalVariance'),
  accumulatedVarianceEl: document.getElementById('accumulatedVariance'),
  monthlyLockToggle: document.getElementById('monthlyLockToggle'),
  btnReset: document.getElementById('btnReset'),
  btnExportExcel: document.getElementById('btnExportExcel'),
  btnImportExcel: document.getElementById('btnImportExcel'),
  btnExportPDF: document.getElementById('btnExportPDF'),
  btnPrint: document.getElementById('btnPrint'),
  performanceChartCanvas: document.getElementById('performanceChart'),
  notesModal: document.getElementById('notesModal'),
  notesTextarea: document.getElementById('notesTextarea'),
  notesSaveBtn: document.getElementById('notesSaveBtn'),
  notesCancelBtn: document.getElementById('notesCancelBtn'),
  notesClearBtn: document.getElementById('notesClearBtn'),
  dateModal: document.getElementById('dateModal'),
  dateInput1: document.getElementById('dateInput1'),
  dateInput2: document.getElementById('dateInput2'),
  dateInput3: document.getElementById('dateInput3'),
  dateSaveBtn: document.getElementById('dateSaveBtn'),
  dateCancelBtn: document.getElementById('dateCancelBtn'),
  dateClearBtn: document.getElementById('dateClearBtn'),
  projectModal: document.getElementById('projectModal'),
  projectInput: document.getElementById('projectInput'),
  projectSaveBtn: document.getElementById('projectSaveBtn'),
  projectCancelBtn: document.getElementById('projectCancelBtn'),
  projectClearBtn: document.getElementById('projectClearBtn'),
  btnToggleFuture: document.getElementById('btnToggleFuture'),
  btnToggleAll: document.getElementById('btnToggleAll'),
  nextContainer: document.getElementById('nextContainer'),
  nextText: document.getElementById('nextText'),
  nextDays: document.getElementById('nextDays'),
  nextMonthPill: document.getElementById('nextMonthPill'),
  gaugeCanvas: document.getElementById('gaugeChart'),
  gaugeText: document.getElementById('gaugeText'),
  btnToggleView: document.getElementById('btnToggleView'),
  localDate: document.getElementById('localDate'),
  btnResetMain: document.getElementById('btnReset'),
  darkToggle: document.getElementById('darkToggle'),
  tipToggle: document.getElementById('tipToggle'),
  btnChangeName: document.getElementById('btnChangeName'),
  btnChangePassword: document.getElementById('btnChangePassword'),
  ownerNameDisplay: document.getElementById('ownerNameDisplay'),
  yearInput: document.getElementById('yearInput'),
  bfInfoBtn: document.getElementById('bfInfoBtn'),
  bfNoteBtn: document.getElementById('bfNoteBtn'),
  bfValue: document.getElementById('bfValue'),
  heatmapRow: document.getElementById('heatmapRow')
  ,overallTooltip: document.getElementById('overallTooltip')
  ,generalNotes: document.getElementById('generalNotes')
  ,noteColor: document.getElementById('noteColor')
  ,notesCloseBtn: document.getElementById('notesCloseBtn')
  ,projectCloseBtn: document.getElementById('projectCloseBtn')
  ,dateCloseBtn: document.getElementById('dateCloseBtn')
  ,closeScenarioBtn: document.getElementById('closeScenarioBtn')
  ,scenarioModal: document.getElementById('scenarioModal')
};

// Persist general notes per owner & year
if (elements.generalNotes) {
  elements.generalNotes.addEventListener('input', () => {
    owners[currentOwner].generalNotes = elements.generalNotes.value;
    saveState();
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}


// === Tooltip toggle wiring ===
if (elements.tipToggle) {
  elements.tipToggle.addEventListener('click', () => {
    tooltipsEnabled = !tooltipsEnabled;
    window.tooltipsEnabled = tooltipsEnabled;
    updateTipToggleLabel();
    saveState();
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
// Ensure initial label
window.tooltipsEnabled = tooltipsEnabled;
updateTipToggleLabel();

let chartInstance = null;
let gaugeInstance = null;
let currentNoteIndex = null;
let currentDateIndex = null;
let currentProjectIndex = null;
// flag to determine if notes modal is editing Brought Forward note
let editingBfNote = false;

function formatNumber(n) {
  if (n === null || n === undefined) return "";
  return Number(n).toLocaleString('en-US', { maximumFractionDigits: 0 });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
function parseInput(value) {
  if (value === null || value === undefined) return 0;
  const cleaned = ('' + value).replace(/,/g, '').trim();
  if (cleaned === '') return 0;
  const num = Number(cleaned);
  return Number.isFinite(num) ? Math.round(num) : NaN;
}
function saveState() {
  try {
    const state = {
      owners,
      darkMode,
      monthlyEditingEnabled,
      currentOwner,
      tooltipsEnabled
    };
    localStorage.setItem(storageKey, JSON.stringify(state));
  } catch (e) {
    console.error('save failed', e);
  }
}
function loadState() {
  try {
    const s = localStorage.getItem(storageKey);
    if (!s) return;
    const st = JSON.parse(s);
    if (st.owners) {
      for (const ownerId in st.owners) {
        if (owners[ownerId]) {
          owners[ownerId].monthlyTargets = st.owners[ownerId].monthlyTargets || new Array(12).fill(0);
          owners[ownerId].actuals = st.owners[ownerId].actuals || new Array(12).fill(0);
          owners[ownerId].expected = st.owners[ownerId].expected || new Array(12).fill(0);
          owners[ownerId].notes = st.owners[ownerId].notes || new Array(12).fill("");
          owners[ownerId].keyDates = st.owners[ownerId].keyDates || new Array(12).fill(null).map(() => []);
          owners[ownerId].projects = st.owners[ownerId].projects || new Array(12).fill("");
          owners[ownerId].broughtForward = st.owners[ownerId].broughtForward || 0;
          owners[ownerId].name = st.owners[ownerId].name || owners[ownerId].name;
          // keep password as is; if none in state, fall back to existing
          owners[ownerId].password = st.owners[ownerId].password !== undefined ? st.owners[ownerId].password : owners[ownerId].password;
          owners[ownerId].broughtForwardNote = st.owners[ownerId].broughtForwardNote || owners[ownerId].broughtForwardNote;
          owners[ownerId].generalNotes = (st.owners[ownerId].generalNotes !== undefined) ? st.owners[ownerId].generalNotes : (owners[ownerId].generalNotes || '');
          owners[ownerId].generalNotesColor = (st.owners[ownerId].generalNotesColor !== undefined) ? st.owners[ownerId].generalNotesColor : (owners[ownerId].generalNotesColor || '#102027');
          owners[ownerId].targetColor = (st.owners[ownerId].targetColor !== undefined) ? st.owners[ownerId].targetColor : (owners[ownerId].targetColor || '#1E90FF');
          owners[ownerId].ytdColor = (st.owners[ownerId].ytdColor !== undefined) ? st.owners[ownerId].ytdColor : (owners[ownerId].ytdColor || '#2E8B57');
          owners[ownerId].remainingColor = (st.owners[ownerId].remainingColor !== undefined) ? st.owners[ownerId].remainingColor : (owners[ownerId].remainingColor || '#d46b6b');
          owners[ownerId].colColors = (st.owners[ownerId].colColors !== undefined) ? st.owners[ownerId].colColors : (owners[ownerId].colColors || {});
        }
      }
    }
    // Normalize: all owners use simple password 'q'
    for (const id in owners) { owners[id].password = 'q'; }

    darkMode = !!st.darkMode;
    monthlyEditingEnabled = !!st.monthlyEditingEnabled;
    tooltipsEnabled = (st.tooltipsEnabled === undefined) ? true : !!st.tooltipsEnabled;
    window.tooltipsEnabled = tooltipsEnabled;
    currentOwner = st.currentOwner || 'owner1';
    updateCurrentOwnerData();
    updateTipToggleLabel();
    elements.ownerSelect.value = currentOwner;
    updateOwnerOptions();
  } catch (e) {
    console.warn('load failed', e);
  }
}

function updateTipToggleLabel(){
  if (!elements.tipToggle) return;
  tooltipsEnabled = (window.tooltipsEnabled === undefined) ? true : !!window.tooltipsEnabled;
  elements.tipToggle.textContent = tooltipsEnabled ? '💬 Tips: On' : '💬 Tips: Off';
}

function updateOwnerOptions() {
  const options = elements.ownerSelect.options;
  for (let i = 0; i < options.length; i++) {
    const value = options[i].value;
    options[i].textContent = owners[value].name;
  }
}
function updateCurrentOwnerData() {
  monthlyTargets = owners[currentOwner].monthlyTargets;
  if (elements.generalNotes) {
    elements.generalNotes.value = owners[currentOwner].generalNotes || '';
    const savedColor = owners[currentOwner].generalNotesColor || '#102027';
    elements.generalNotes.style.color = savedColor;
    if (elements.noteColor) elements.noteColor.value = savedColor;
  }
  actuals = owners[currentOwner].actuals;
  expected = owners[currentOwner].expected;
  notes = owners[currentOwner].notes;
  keyDates = owners[currentOwner].keyDates;
  projects = owners[currentOwner].projects;
  elements.ownerNameDisplay.textContent = owners[currentOwner].name;
  const savedTargetColor = owners[currentOwner].targetColor || '#1E90FF';
  if (elements.dashYearlyTarget) elements.dashYearlyTarget.style.color = savedTargetColor;
  if (elements.targetColor) elements.targetColor.value = savedTargetColor;
  const savedYtdColor = owners[currentOwner].ytdColor || '#2E8B57';
  if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
  if (elements.ytdColor) elements.ytdColor.value = savedYtdColor;
  const savedRemainingColor = owners[currentOwner].remainingColor || '#d46b6b';
  if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
  if (elements.remainingColor) elements.remainingColor.value = savedRemainingColor;
  // --- expose current owner's arrays globally for widgets/cards that read from window.* ---
  try {
    window.monthlyTargets = monthlyTargets;
    window.monthlyInflows = actuals;           // actual bank inflow per month
    window.keyDates = keyDates;                // per-month key dates
    window.currentOwnerId = (typeof currentOwner !== 'undefined') ? currentOwner : window.currentOwnerId;
    // Opening Balance (if present on this owner)
    window.openingBalance = Number(owners[currentOwner]?.broughtForward || 0);
  } catch(err) { console.warn('Mirror globals error', err); }
  // ask dynamic components (e.g., Next Target card & circle) to re-render
  try { if (typeof window.refreshNextTargetMain === 'function') window.refreshNextTargetMain(); } catch(_) {}

  // --- card-only data mirror (non-invasive) ---
  try {
    window.__cardData = {
      targets: (typeof monthlyTargets !== 'undefined' ? monthlyTargets.slice() : []),
      inflows: (typeof actuals !== 'undefined' ? actuals.slice() : []),
      openingBalance: Number((owners && typeof currentOwner !== 'undefined' && owners[currentOwner] && owners[currentOwner].broughtForward) || 0),
      keyDates: (typeof keyDates !== 'undefined' ? keyDates.slice() : [])
    };
    if (typeof window.refreshNextTargetMain === 'function') window.refreshNextTargetMain();
    if (typeof window.refreshNextNeededRibbon === 'function') window.refreshNextNeededRibbon();
  } catch(err) { console.warn('Card data mirror error', err); }

}
function getNow() {
  const currentRealYear = new Date().getFullYear();
  const displayedYear = window.currentYear || currentRealYear;
  
  if (displayedYear > currentRealYear) {
    // If viewing future year (e.g., 2026), treat "now" as January 1st of that year
    return new Date(displayedYear, 0, 1);
  } else if (displayedYear < currentRealYear) {
    // If viewing past year, treat "now" as end of that year
    return new Date(displayedYear, 11, 31, 23, 59, 59);
  } else {
    // Same year, use actual current date
    return new Date();
  }
}
function getCurrentMonthIndex() {
  const currentRealYear = new Date().getFullYear();
  const displayedYear = window.currentYear || currentRealYear;
  
  if (displayedYear > currentRealYear) {
    // If viewing future year (e.g., 2026), treat current month as January (0)
    return 0;
  } else if (displayedYear < currentRealYear) {
    // If viewing past year, treat current month as December (11)
    return 11;
  } else {
    // Same year, use actual current month
    return getNow().getMonth();
  }
}
function getYearProgress() {
  const now = getNow();
  const start = new Date(now.getFullYear(), 0, 1);
  const end = new Date(now.getFullYear(), 11, 31);
  const daysPassed = (now - start) / (1000 * 60 * 60 * 24);
  const totalDays = (end - start) / (1000 * 60 * 60 * 24) + 1;
  return Math.min(100, (daysPassed / totalDays) * 100);
}
/**
 * Determine the next month requiring additional funds based on negative variance
 * and the nearest future key date. Rather than relying on the chronological
 * order of months, this function looks across all months for those with
 * negative variance and selects the one whose key date is soonest in the
 * future. If multiple key dates exist, the earliest future date is used. If
 * no future key dates are present on months with negative variance, null is
 * returned. The returned object contains the month index and the absolute
 * amount needed to reach the target for that month.
 */
function findNextNeededMonth() {
  // Strategy:
  // 1) Prefer months with a *future key date* AND an accumulated shortfall after that month.
  // 2) If none have future key dates, choose the earliest month in the year where
  //    the accumulated variance (including Brought Forward) is still negative.
  //    This guarantees the ribbon always advances to the next pending month.
  const now = getNow();

  // Helper: accumulated variance after including month i
  function accumAfterMonth(i){
    let acc = (owners[currentOwner]?.broughtForward || 0);
    for (let k = 0; k <= i; k++) {
      const t = Number(monthlyTargets[k] || 0);
      const a = Number(actuals[k] || 0);
      acc += (a - t);
    }
    return acc;
  }

  // Build list of candidates with future key dates
  const dated = [];
  for (let i = 0; i < 12; i++) {
    const accAfter = accumAfterMonth(i);
    if (accAfter >= 0) continue; // only months where cumulative is still short
    const dates = keyDates[i] || [];
    for (const d of dates) {
      let dt;
      try { dt = new Date(d); } catch (_) { dt = null; }
      if (dt && dt > now) {
        const needed = Math.max(0, -accAfter); // shortage equals |accAfter|
        dated.push({ index: i, needed, date: dt });
      }
    }
  }
  if (dated.length) {
    dated.sort((a,b) => a.date - b.date);
    const top = dated[0];
    return { index: top.index, needed: top.needed };
  }

  // Fallback: first month in the year where cumulative is negative
  const currentRealYear = new Date().getFullYear();
  const displayedYear = window.currentYear || currentRealYear;
  
  // For future years, be more flexible and show any month with targets > 0
  if (displayedYear > currentRealYear) {
    console.log(`[findNextNeededMonth] Future year ${displayedYear} detected. monthlyTargets:`, monthlyTargets);
    for (let i = 0; i < 12; i++) {
      const target = Number(monthlyTargets[i] || 0);
      const actual = Number(actuals[i] || 0);
      console.log(`Month ${i}: target=${target}, actual=${actual}`);
      if (target > 0) {
        const shortfall = Math.max(0, target - actual);
        console.log(`Found month ${i} with target ${target}, returning shortfall=${shortfall}`);
        return { index: i, needed: shortfall };
      }
    }
    console.log('No months with targets > 0 found in future year');
  }
  
  // Original logic for current/past years
  for (let i = 0; i < 12; i++) {
    const accAfter = accumAfterMonth(i);
    if (accAfter < 0) {
      return { index: i, needed: Math.max(0, -accAfter) };
    }
  }
  return null;
}
function getDaysToNext(dates) {
  if (!dates || dates.length === 0) return '—';
  const now = getNow();
  const futureDates = dates.map(d => new Date(d)).filter(d => d > now).sort((a, b) => a - b);
  if (futureDates.length === 0) {
    return 'Past';
  }
  const diffMs = futureDates[0] - now;
  const days = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  if (days === 0) return 'Today';
  return days;
}

// Calculate accumulated variance (including brought forward) up to, but not including,
// the given month index. Negative values indicate a shortfall carried over. Positive
// values indicate an overage.
function getAccumVarianceBeforeMonth(index) {
  let sum = owners[currentOwner].broughtForward || 0;
  for (let j = 0; j < index; j++) {
    const targ = Number(monthlyTargets[j] || 0);
    const act = Number(actuals[j] || 0);
    sum += (act - targ);
  }
  return sum;
}
function renderMonthsMini() {
  const container = elements.monthsMini;
  container.innerHTML = '';
  const cur = getCurrentMonthIndex();
  const next = findNextNeededMonth();
  const nextIndex = next ? next.index : null;
  for (let i = 0; i < 12; i++) {
    if (showUpcomingOnly && i < cur) continue;

    // Wrap: one item per month -> pill + external label
    const item = document.createElement('div');
    item.className = 'month-item';

    // Month pill (button)
    const pill = document.createElement('button');
    pill.type = 'button';
    pill.className = 'month-pill';
    pill.setAttribute('aria-label', `View details for ${months[i]}`);
    if (i === cur) pill.classList.add('active');
    if (i === nextIndex) pill.classList.add('next');

    const target = Number(monthlyTargets[i] || 0);
    const actual = Number(actuals[i] || 0);
    if (target > 0) {
      if (actual > target) pill.classList.add('met');
      else if (actual === target) pill.classList.add('equal');
      else pill.classList.add('unmet');
    }
    pill.setAttribute('data-month-index', i);
    pill.title = months[i];
    pill.innerHTML = `
      <div class="tiny muted" style="font-size: 11px; margin-bottom:2px;">${i + 1}</div>
      <div style="font-weight:700">${months[i].slice(0, 3)}</div>
      <div class="tiny muted" style="margin-top: 6px;">${formatNumber(actual)}</div>
    `;

    // External Acc. Variance label (OUTSIDE the pill)
    let accVar = 0;
    for (let k = 0; k <= i; k++) {
      accVar += (Number(actuals[k] || 0) - Number(monthlyTargets[k] || 0));
    }
    const accClass = accVar < 0 ? 'acc-neg' : (accVar > 0 ? 'acc-pos' : 'acc-zero');
    const accLabel = accVar === 0 ? '(met)' : (accVar > 0 ? `surplus ${formatNumber(accVar)}` : `shortage ${formatNumber(Math.abs(accVar))}`);

    const label = document.createElement('div');
    label.className = `acc-var-label ${accClass}`;
    label.setAttribute('aria-label','Balance'); label.title = 'Balance';
label.textContent = 'Balance: ' + accLabel;
    // Add flag based on ACC variance class
    const flag = document.createElement('span');
    if (accClass === 'acc-neg') { flag.className = 'month-flag red'; flag.textContent = '🚩'; }
    else if (accClass === 'acc-pos') { flag.className = 'month-flag green'; flag.textContent = '✅'; }


    // Click behavior on pill
    pill.addEventListener('click', () => {
      const row = document.querySelector(`tr[data-month="${i}"]`);
      if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      openDatePicker(i);
    });

    // Assemble
    item.appendChild(pill);
    item.appendChild(label);
    container.appendChild(item);
  }

}
function renderTable() {
  const tbody = elements.tableBody;
  tbody.innerHTML = '';
  // start accumulated variance with broughtForward amount, as carry-over from previous year
  let accumulated = owners[currentOwner].broughtForward || 0;
  for (let i = 0; i < 12; i++) {
    const target = Number(monthlyTargets[i] || 0);
    const actual = Number(actuals[i] || 0);
    const exp = Number(expected[i] || 0);
    const project = projects[i] || '';
    const variance = actual - target;
    accumulated += variance;
    const datesText = (keyDates[i] || []).map(d => d ? (new Date(d)).toLocaleDateString('en-GB') : '').filter(Boolean).join(', ');
    const daysText = getDaysToNext(keyDates[i]);
    const trendClass = (() => {
      const prevVar = i > 0 ? (Number(actuals[i - 1] || 0) - Number(monthlyTargets[i - 1] || 0)) : null;
      if (prevVar === null) return '';
      return (variance > prevVar) ? 'trendUp' : (variance < prevVar ? 'trendDown' : '');
    })();
    let varClass = 'variance-zero';
    if (variance > 0) varClass = 'variance-pos';
    else if (variance < 0) varClass = 'variance-neg';
    let accumClass = 'accum-zero';
    if (accumulated > 0) accumClass = 'accum-pos';
    else if (accumulated < 0) accumClass = 'accum-neg';
    const tr = document.createElement('tr');
    tr.setAttribute('data-month', i);
    // build cells according to new order
    
tr.innerHTML = `
  <!-- Row number -->
  <td>${i + 1}</td>

  <!-- Dates -->
  <td class="gray"
      title="Click to edit/view dates"
      data-tip-label="Key Dates"
      data-tip="${(keyDates[i] || []).map(d => d ? (new Date(d)).toLocaleDateString('en-GB') : '').filter(Boolean).join(', ') || '—'}">
    ${datesText ? datesText : '—'}
    <button class="iconBtn" data-month="${i}" data-action="date" aria-label="Edit dates for ${months[i]}">📅</button>
  </td>

  <!-- Days to Next (unchanged) -->
  <td style="${daysText === 'Today' ? 'color:var(--gold)' : daysText !== '—' && daysText !== 'Past' && Number(daysText) < 10 ? 'color:var(--red)' : 'color:var(--muted)'}">
    <strong>${daysText}</strong>
  </td>

  <!-- Project -->
  <td class="project ${monthlyEditingEnabled ? 'editable' : ''}"
      data-month="${i}"
      data-field="project"
      data-tip-label="Project"
      data-tip="${(projects[i] || '—').replace(/\"/g,'&quot;')}">
    ${project ? (project.length > 20 ? project.slice(0, 20) + '…' : project) : '—'}
    <button class="iconBtn" data-month="${i}" data-action="project" aria-label="Edit project for ${months[i]}">📋</button>
  </td>

  <!-- Notes -->
  <td class="gray"
      data-tip-label="Notes"
      data-tip="${(notes[i] ? notes[i] : '—').replace(/\"/g,'&quot;')}">
    ${notes[i] ? (notes[i].length > 40 ? notes[i].slice(0, 40) + '…' : notes[i]) : '—'}
    <button class="iconBtn" data-month="${i}" data-action="note" aria-label="Edit note for ${months[i]}">📝</button>
  </td>

  <!-- Monthly Target -->
  <td class="${monthlyEditingEnabled ? 'editable' : ''}"
      data-month="${i}"
      data-field="target"
      data-tip-label="Monthly Target"
      data-tip="${target ? formatNumber(target) + ' AED' : '—'}">
    ${target ? formatNumber(target) : ''}
  </td>

  <!-- Month -->
  <td>${months[i]}</td>

  <!-- Expected Inflow -->
  <td class="${monthlyEditingEnabled ? 'editable expected' : 'expected'}"
      data-month="${i}"
      data-field="expected"
      data-tip-label="Expected Inflow"
      data-tip="${exp ? formatNumber(exp) + ' AED' : '—'}">
    ${exp ? formatNumber(exp) : ''}
  </td>

  <!-- Bank Inflow (Actual) -->
  <td class="${monthlyEditingEnabled ? 'editable' : ''}"
      data-month="${i}"
      data-field="actual"
      data-tip-label="Actual Inflow (Past History)"
      data-tip="${actual ? formatNumber(actual) + ' AED' : '—'}">
    ${actual ? formatNumber(actual) : ''}
  </td>

  <!-- Variance -->
  <td class="${varClass}">
    ${formatNumber(variance)} ${trendClass ? `<span class="${trendClass}" style="margin-left:6px">${trendClass === 'trendUp' ? '↑' : '↓'}</span>` : ''}
  </td>

  <!-- Balance -->
  <td class="${accumClass}">
    ${formatNumber(accumulated)}
  </td>
`;
;
    tbody.appendChild(tr);
  }
  // totals
  const totalTarget = monthlyTargets.reduce((a, b) => a + (Number(b) || 0), 0);
  const __rawActual = actuals.reduce((a, b) => a + (Number(b) || 0), 0);
  const __openingBalance = (owners[currentOwner].broughtForward || 0);
 const totalActual = __rawActual; // EXCLUDE opening balance from YTD Bank Inflow
// Adjusted Target = Yearly Target (Opening Balance + Target) - Opening Balance (surplus reduces target, shortage increases it)
  const adjustedTarget = totalTarget - __openingBalance;
  const totalVariance = (__openingBalance + __rawActual) - totalTarget; // invariant = rawActual - adjustedTarget
  // Update small header metrics
  elements.monthlyTargetEl.textContent = formatNumber(adjustedTarget);
  elements.ytdAccomplishedEl.textContent = formatNumber(Math.max(0, totalActual));
  elements.totalVarianceEl && (elements.totalVarianceEl.textContent = formatNumber(totalVariance));
  elements.accumulatedVarianceEl.textContent = formatNumber(totalVariance);

  // Update overview header
  const obEl = document.getElementById('dashOpeningBalance');
  if (obEl) obEl.textContent = formatNumber(__openingBalance);

  // Show adjusted target in main "Early Target" big number
  const dashTarget = document.getElementById('dashYearlyTarget');
  if (dashTarget) dashTarget.textContent = formatNumber(adjustedTarget);

  // Show explanatory note under target
  const noteEl = document.getElementById('dashTargetNote');
  if (noteEl) {
    const signWord = __openingBalance >= 0 ? '−' : '+'; // display math: Original ± |OB|
    const absOB = Math.abs(__openingBalance);
    noteEl.textContent = `Yearly Target (Opening Balance + Target): ${formatNumber(totalTarget)} ${signWord} Opening Balance ${formatNumber(absOB)} = Adjusted Target ${formatNumber(adjustedTarget)}`;
  }

  // YTD (Bank inflow) remains raw actuals only (OB excluded)
  const dashYtd = document.getElementById('dashYtdAccomplished');
  if (dashYtd) dashYtd.textContent = formatNumber(Math.max(0, totalActual));

  // Remaining = Adjusted Target - YTD (never below 0)
  const dashRem = document.getElementById('dashRemaining');
  if (dashRem) dashRem.textContent = formatNumber(Math.max(0, adjustedTarget - totalActual));
  // update brought forward display
  elements.bfValue.textContent = formatNumber(owners[currentOwner].broughtForward || 0);
  elements.bfValue.classList.toggle('editable-bf', monthlyEditingEnabled);
  renderHeatmap();
}
function renderHeatmap() {
  const container = elements.heatmapRow;
  container.innerHTML = '';
  const maxAbs = Math.max(...monthlyTargets.map((t, i) => Math.abs((Number(actuals[i] || 0) - (Number(t) || 0)))), 1);
  for (let i = 0; i < 12; i++) {
    const t = Number(monthlyTargets[i] || 0);
    const a = Number(actuals[i] || 0);
    const v = a - t;
    const norm = Math.max(-1, Math.min(1, v / (maxAbs || 1)));
    const color = v >= 0 ? interpolateColor([239, 252, 240], [34, 139, 34], Math.min(1, v / maxAbs))
                        : interpolateColor([255, 241, 241], [198, 40, 40], Math.min(1, Math.abs(v) / maxAbs));
    const cell = document.createElement('div');
    cell.className = 'heatCell';
    cell.style.background = `rgb(${color.join(',')})`;
    cell.title = `${months[i]} variance: ${formatNumber(v)}`;
    cell.setAttribute('aria-label', `${months[i]} variance: ${formatNumber(v)}`);
    container.appendChild(cell);
  }
}
function interpolateColor(a, b, t) {
  const r = Math.round(a[0] + (b[0] - a[0]) * t);
  const g = Math.round(a[1] + (b[1] - a[1]) * t);
  const bl = Math.round(a[2] + (b[2] - a[2]) * t);
  return [r, g, bl];
}
function renderChart() {
  const isDark = darkMode;
  const ctx = elements.performanceChartCanvas.getContext('2d');
  if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
  const labels = months.map(m => m.slice(0, 3));
  const targetsData = monthlyTargets.map(n => Number(n) || 0);
  const actualData = actuals.map(n => Number(n) || 0);
  const barColors = actualData.map((v, i) => {
    if (v === 0 && targetsData[i] === 0) return 'rgba(160,160,160,0.16)';
    if (v >= targetsData[i]) return isDark ? 'rgba(130,190,140,0.9)' : 'rgba(111,174,117,0.9)';
    return isDark ? 'rgba(220,120,120,0.9)' : 'rgba(212,107,107,0.9)';
  });
  const datasets = [
    {
      type: 'line',
      label: 'Target',
      data: targetsData,
      borderColor: isDark ? 'rgba(90,160,150,0.95)' : 'rgba(74,141,133,0.95)',
      backgroundColor: isDark ? 'rgba(90,160,150,0.12)' : 'rgba(74,141,133,0.06)',
      borderWidth: 2,
      tension: 0.25,
      pointRadius: 4,
      yAxisID: 'y'
    },
    {
      type: 'bar',
      label: 'Actual',
      data: actualData,
      backgroundColor: barColors,
      borderRadius: 6,
      maxBarThickness: 44,
      yAxisID: 'y'
    }
  ];
  if (chartMode === 'cumulative') {
    const cumTargets = targetsData.map((_, i) => targetsData.slice(0, i + 1).reduce((a, b) => a + b, 0));
    const cumActual = actualData.map((_, i) => actualData.slice(0, i + 1).reduce((a, b) => a + b, 0));
    datasets.unshift(
      {
        type: 'line',
        label: 'Cumulative Actual',
        data: cumActual,
        borderColor: isDark ? 'rgba(130,190,140,0.9)' : 'rgba(111,174,117,0.9)',
        backgroundColor: isDark ? 'rgba(130,190,140,0.15)' : 'rgba(111,174,117,0.08)',
        borderWidth: 2,
        tension: 0.2,
        pointRadius: 0,
        yAxisID: 'y1'
      },
      {
        type: 'line',
        label: 'Cumulative Target',
        data: cumTargets,
        borderColor: isDark ? 'rgba(230,180,80,0.9)' : 'rgba(227,176,75,0.9)',
        backgroundColor: isDark ? 'rgba(230,180,80,0.12)' : 'rgba(227,176,75,0.06)',
        borderWidth: 2,
        tension: 0.2,
        pointRadius: 0,
        borderDash: [6, 4],
        yAxisID: 'y1'
      }
    );
  }
  chartInstance = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { position: 'top', labels: { usePointStyle: true, pointStyle: 'circle', boxWidth: 9, boxHeight: 9, padding: 10, font: { size: 9 } } },
        tooltip: {
          callbacks: {
            title: (items) => ` ${items[0].label} `,
            label: function (ctx) {
              const ds = ctx.dataset;
              const label = ds.label || '';
              const val = ctx.parsed.y || 0;
              const idx = ctx.dataIndex;
              const target = targetsData[idx] || 0;
              if (ds.label === 'Actual') {
                const pct = target ? ((val / target) * 100).toFixed(1) + '%' : '—';
                return `${label}: ${formatNumber(val)} (vs target: ${formatNumber(target)} AED, ${pct})`;
              }
              return `${label}: ${formatNumber(val)}`;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: 'AED' },
          ticks: { callback: (v) => formatNumber(v) },
          grid: { color: isDark ? 'rgba(200,200,200,0.05)' : 'rgba(10,20,20,0.04)' }
        },
        y1: {
          beginAtZero: true,
          display: chartMode === 'cumulative',
          position: 'right',
          grid: { display: false },
          ticks: { callback: (v) => formatNumber(v) }
        },
        x: { grid: { display: false } }
      },
      animation: { duration: 700, easing: 'easeOutCubic' }
    }
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
function renderGauge() {
  const isDark = darkMode;
  if (gaugeInstance) { gaugeInstance.destroy(); gaugeInstance = null; }
  const ctx = elements.gaugeCanvas.getContext('2d');
  const yearProgress = getYearProgress();
  const remained = 100 - yearProgress;
  gaugeInstance = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Time Passed', 'Time Remaining'],
      datasets: [{
        data: [Math.round(yearProgress), Math.round(remained)],
        backgroundColor: [isDark ? 'rgba(90,160,150,0.9)' : 'rgba(74,141,133,0.9)', isDark ? 'rgba(80,80,80,0.3)' : 'rgba(200,200,200,0.18)'],
        hoverOffset: 4
      }]
    },
    options: {
      cutout: '80%',
      plugins: { legend: { display: false }, tooltip: { enabled: false } }
    }
  });
  const next = findNextNeededMonth();
  if (next) {
    const { index, needed } = next;
    // Determine the accumulated variance up to (but not including) this month and the current month's variance.
    const accumBefore = getAccumVarianceBeforeMonth(index);
    const currentVar = (Number(actuals[index] || 0) - Number(monthlyTargets[index] || 0));
    const accumAfter = accumBefore + currentVar;
    // Shortage equals the absolute value of the accumulated variance after this month when negative.
    const shortage = Math.max(0, -accumAfter);
    const targetAmount = Number(monthlyTargets[index] || 0);
    // Tooltip: show the target, the current month variance (shortfall), and the accumulated variance prior to this month.
    const tooltip = `Target: ${formatNumber(targetAmount)}, Current variance: ${formatNumber(currentVar)}, Prev variance: ${formatNumber(accumBefore)}`;
    let shortageLine = '';
    if (shortage > 0) {
      shortageLine = `<br><span style="font-size: 8px; color:var(--orange-red-flag);">shortage ${formatNumber(shortage)}</span>`;
    }
    elements.gaugeText.innerHTML = `<div class="month" style="font-size: 12px;line-height:1; margin-bottom:4px; margin-bottom:8px">${months[index].slice(0, 3)}</div><div class="arrow">↓</div><div class="amount" style="font-size: 11px;line-height:1" title="${tooltip}">${formatNumber(targetAmount)}${shortageLine}</div>`;
  } else {
    elements.gaugeText.innerHTML = '<div class="month">All Met 🎉</div>';
  }
}
function animateBar(el, percent) {
  el.style.transition = 'width .7s cubic-bezier(.4,0,.2,1)';
  setTimeout(() => { el.style.width = percent + '%'; }, 50);
}
function recalcSummary() {
  const yearlyTarget = monthlyTargets.reduce((a, b) => a + (Number(b) || 0), 0);
  const sumActuals = actuals.reduce((a, b) => a + (Number(b) || 0), 0) + (owners[currentOwner].broughtForward || 0);
  let remaining = yearlyTarget - sumActuals;
  remaining = Math.max(0, remaining);
  // completionPercent represents the percentage of the Early Target that has been achieved. It is capped at 100%.
  const completionPercent = yearlyTarget ? ((sumActuals / yearlyTarget) * 100) : 0;
  elements.dashYearlyTarget.textContent = formatNumber(yearlyTarget);
  elements.dashYtdAccomplished.textContent = formatNumber(sumActuals);
  elements.dashRemaining.textContent = formatNumber(remaining);
  // Keep top-number tooltips in sync
  if (elements.dashYearlyTarget) {
    elements.dashYearlyTarget.setAttribute('data-tip-label','Early Target');
    elements.dashYearlyTarget.setAttribute('data-tip', formatNumber(yearlyTarget) + ' AED');
  }
  if (elements.dashYtdAccomplished) {
    elements.dashYtdAccomplished.setAttribute('data-tip-label','YTD Actual Inflow (Past History)');
    elements.dashYtdAccomplished.setAttribute('data-tip', formatNumber(sumActuals) + ' AED');
  }
  if (elements.dashRemaining) {
    elements.dashRemaining.setAttribute('data-tip-label','Remaining');
    elements.dashRemaining.setAttribute('data-tip', formatNumber(remaining) + ' AED');
  }

  elements.progressTargetValue.textContent = formatNumber(remaining);
  elements.progressCompletionValue.textContent = formatNumber(sumActuals);
  elements.targetTooltip.textContent = formatNumber(remaining) + ' AED';
  elements.completionTooltip.textContent = formatNumber(sumActuals) + ' AED';
  // Update the progress bars for remaining and achieved. Each bar's width
  // reflects the percentage of its respective value relative to the Early Target.
  animateBar(elements.targetFill, Math.min(100, (remaining / (yearlyTarget || 1)) * 100));
  animateBar(elements.progressFill, Math.min(100, completionPercent));
  // Update the tooltips with the raw amounts.
  elements.targetTooltip.textContent = formatNumber(remaining) + ' AED';
  elements.completionTooltip.textContent = formatNumber(sumActuals) + ' AED';
    const next = findNextNeededMonth();
    console.log('[recalcSummary] findNextNeededMonth returned:', next);
    console.log('[recalcSummary] Current year:', window.currentYear || new Date().getFullYear());
    
    if (next) {
      const { index } = next;
      // Sum the variances of all previous months (including brought forward) to determine
      // whether there is an existing surplus or deficit prior to this month.
      const accumBefore = getAccumVarianceBeforeMonth(index);
      // Current month's variance (actual minus target). This will be negative if a shortfall exists.
      const currentVar = (Number(actuals[index] || 0) - Number(monthlyTargets[index] || 0));
      // Accumulated variance after including the current month. Negative values indicate a net shortfall.
      const accumAfter = accumBefore + currentVar;
      // Shortage equals the absolute value of the accumulated variance after this month when negative. This aligns with the
      // "Balance" column in the table.
      const shortage = Math.max(0, -accumAfter);
      const surplus = Math.max(0, accumAfter);
      const targetAmount = Number(monthlyTargets[index] || 0);
      const days = getDaysToNext(keyDates[index]);
      // Only present the "Next needed" alert if there is an actual shortage. If the shortage is zero, there is no deficit to highlight.
      if (shortage > 0) {
        elements.nextMonthPill.textContent = months[index].slice(0, 3);
        // Build the display to emphasise the next target amount first, followed by the shortage. The shortage amount is styled in red to indicate urgency.
        elements.nextText.innerHTML = `<strong>${formatNumber(targetAmount)}</strong> <span style="color:var(--orange-red-flag);">(shortage ${formatNumber(shortage)})</span>`;
        elements.nextDays.textContent = (days === '—' || days === 'Past') ? '-' : (days === 'Today' ? 'Today' : `${days}d`);
        elements.nextContainer.style.display = 'flex';
        elements.nextContainer.classList.add('shortage');
        elements.dashNextText.innerHTML = '';
        elements.dashNextText.classList.remove('alert-green');
      } else if (surplus > 0) {
        // Show surplus when there's positive balance
        elements.nextMonthPill.textContent = months[index].slice(0, 3);
        elements.nextText.innerHTML = `<strong>${formatNumber(targetAmount)}</strong> <span style="color:var(--green);">(surplus ${formatNumber(surplus)})</span>`;
        elements.nextDays.textContent = (days === '—' || days === 'Past') ? '-' : (days === 'Today' ? 'Today' : `${days}d`);
        elements.nextContainer.style.display = 'flex';
        elements.nextContainer.classList.remove('shortage');
        elements.dashNextText.innerHTML = '';
        elements.dashNextText.classList.remove('alert-green');
      } else {
        // If there is no shortage, hide the next needed container and provide a note in
        // the dash area indicating that there is no shortfall.
        elements.nextContainer.style.display = 'none';
        elements.nextContainer.classList.remove('shortage');
        if (monthlyTargets.some(t => (Number(t) || 0) > 0)) {
          elements.dashNextText.innerHTML = '<span style="background:var(--very-light-green);color:var(--green);padding:2px 8px;border-radius:8px;font-weight:600;">No shortage – on track 🎉</span>';
          elements.dashNextText.classList.add('alert-green');
        } else {
          elements.dashNextText.textContent = 'No targets set yet';
          elements.dashNextText.classList.remove('alert-green');
        }
      }
    } else {
      // There is no upcoming month with a future key date and negative variance.
      elements.nextContainer.style.display = 'none';
      elements.nextContainer.classList.remove('shortage');
      if (monthlyTargets.some(t => (Number(t) || 0) > 0)) {
        elements.dashNextText.innerHTML = '<span style="background:var(--very-light-green);color:var(--green);padding:2px 8px;border-radius:8px;font-weight:600;">All targets met 🎉</span>';
        elements.dashNextText.classList.add('alert-green');
      } else {
        elements.dashNextText.textContent = 'No targets set yet';
        elements.dashNextText.classList.remove('alert-green');
      }
    }
}
function attachTableEditListeners() {
  const tableEl = document.querySelector('table');
  tableEl.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button[data-action]');
    if (btn) {
      const m = Number(btn.dataset.month);
      const action = btn.dataset.action;
      if (action === 'note') openNotes(m);
      else if (action === 'date') openDatePicker(m);
      else if (action === 'project') openProjectEditor(m);
      return;
    }
    // editing for values
    const cell = ev.target.closest('td[data-month]');
    if (cell && cell.classList.contains('editable') && monthlyEditingEnabled) {
      const month = Number(cell.dataset.month);
      const field = cell.dataset.field;
      const initial = field === 'target' ? (monthlyTargets[month] || '') :
                     field === 'actual' ? (actuals[month] || '') :
                     field === 'expected' ? (expected[month] || '') :
                     (projects[month] || '');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = field !== 'project' ? (initial ? formatNumber(initial) : '') : initial;
      input.style.width = '100%';
      input.style.boxSizing = 'border-box';
      input.setAttribute('aria-label', `Edit ${field} for ${months[month]}`);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          // Save the value immediately
          const currentValue = input.value;
          if (field === 'project') {
            const val = currentValue.trim().slice(0, 100);
            projects[month] = val;
          } else {
            const val = parseInput(currentValue);
            if (!Number.isNaN(val)) {
              if (field === 'target') monthlyTargets[month] = val;
              else if (field === 'actual') actuals[month] = val;
              else if (field === 'expected') expected[month] = val;
            }
          }
          saveState();
          renderAll();
          input.blur();
        }
        if (e.key === 'Escape') {
          input.value = '';
          input.blur();
        }
      });
      input.addEventListener('blur', () => {
        if (field === 'project') {
          const val = input.value.trim().slice(0, 100);
          projects[month] = val;
        } else {
          const val = parseInput(input.value);
          if (!Number.isNaN(val)) {
            if (field === 'target') monthlyTargets[month] = val;
            else if (field === 'actual') actuals[month] = val;
            else if (field === 'expected') expected[month] = val;
          }
        }
        saveState();
        renderAll();
      });
      cell.innerHTML = '';
      cell.appendChild(input);
      input.focus();
      input.select();
    }
    // editing brought forward
    const bfCell = ev.target.closest('#bfValue');
    if (bfCell && monthlyEditingEnabled) {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = formatNumber(owners[currentOwner].broughtForward || 0);
      input.style.width = 'auto';
      input.style.boxSizing = 'border-box';
      input.setAttribute('aria-label', 'Edit brought forward');
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          // Save the value immediately
          const val = parseInput(input.value);
          if (!Number.isNaN(val)) {
            owners[currentOwner].broughtForward = val;
          }
          saveState();
          renderAll();
          input.blur();
        }
        if (e.key === 'Escape') {
          input.value = '';
          input.blur();
        }
      });
      input.addEventListener('blur', () => {
        const val = parseInput(input.value);
        if (!Number.isNaN(val)) {
          owners[currentOwner].broughtForward = val;
        }
        saveState();
        renderAll();
      });
      bfCell.innerHTML = '';
      bfCell.appendChild(input);
      input.focus();
      input.select();
    }
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
function openNotes(index) {
  currentNoteIndex = index;
  elements.notesTextarea.value = notes[index] || '';
  elements.notesClearBtn.style.display = notes[index] ? 'inline-block' : 'none';
  showModalSafely(elements.notesModal);
  elements.notesTextarea.focus();
}
function openProjectEditor(index) {
  currentProjectIndex = index;
  elements.projectInput.value = projects[index] || '';
  elements.projectClearBtn.style.display = projects[index] ? 'inline-block' : 'none';
  showModalSafely(elements.projectModal);
  elements.projectInput.focus();
}

// open note editor specifically for Brought Forward note
function openBfNote() {
  editingBfNote = true;
  elements.notesTextarea.value = owners[currentOwner].broughtForwardNote || '';
  // show clear button only if a note exists
  elements.notesClearBtn.style.display = owners[currentOwner].broughtForwardNote ? 'inline-block' : 'none';
  showModalSafely(elements.notesModal);
  elements.notesTextarea.focus();
}
elements.notesCancelBtn.addEventListener('click', () => {
  hideModal(elements.notesModal);
  // reset editing flags
  if (editingBfNote) {
    editingBfNote = false;
  } else {
    currentNoteIndex = null;
  }
});
// Helper: show a modal reliably even if inline styles exist
    function showModalSafely(modalEl){
      if (!modalEl) return;
      try { modalEl.style.removeProperty('display'); } catch(e){}
      modalEl.classList.add('visible');
    }

  // Helper to robustly hide a modal (remove class, force display none and blur active element)
  function hideModal(modal) {
    try {
      if (!modal) return;
      modal.classList.remove('visible');
      // force repaint / hide in case CSS is overridden elsewhere
      modal.style.display = 'none';
      if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur();
      // double-ensure after a short delay (some render cycles re-add visibility)
      setTimeout(function(){ try { modal.classList.remove('visible'); modal.style.display = 'none'; } catch(e){} }, 40);
    } catch(e){}
  }

  // Extra guard: force-hide any modal that remains visible (removes class, inline style)
  function forceHideAllVisibleModals() {
    try {
      ['notesModal','projectModal','dateModal','aiAnalysisModal','scenarioModal','monthlyNotesModal'].forEach(id => {
        const m = document.getElementById(id);
        if (m && (m.classList.contains('visible') || getComputedStyle(m).display !== 'none')) {
          m.classList.remove('visible');
          m.style.display = 'none';
        }
      });
      if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur();
    } catch(e) { console.warn('forceHideAllVisibleModals failed', e); }
  }

  // Prevent re-opening immediately after a save: observe class changes and block .visible if marker present
  try {
    const moBlock = new MutationObserver((mutations) => {
      mutations.forEach(m => {
        const tgt = m.target;
        if (!(tgt instanceof HTMLElement)) return;
        if (tgt.dataset && tgt.dataset.justSaved && tgt.classList && tgt.classList.contains('visible')) {
          // remove visible immediately
          try { tgt.classList.remove('visible'); tgt.style.display = 'none'; } catch(e){}
          console.debug('Blocked re-open of just-saved modal:', tgt.id || tgt.className);
        }
      });
    });
    moBlock.observe(document.documentElement || document.body, { attributes: true, subtree: true, attributeFilter: ['class'] });
  } catch (e) { console.warn('modal re-open blocker failed', e); }

  elements.notesSaveBtn.addEventListener('click', () => {
  if (editingBfNote) {
    // save brought forward note
    owners[currentOwner].broughtForwardNote = elements.notesTextarea.value.trim().slice(0, 1000);
    editingBfNote = false;
    saveState();
    renderAll();
  hideModal(elements.notesModal);
  setTimeout(forceHideAllVisibleModals, 30);
  } else {
    if (currentNoteIndex === null) return;
    notes[currentNoteIndex] = elements.notesTextarea.value.trim().slice(0, 1000);
    saveState();
    renderAll();
  hideModal(elements.notesModal);
  setTimeout(forceHideAllVisibleModals, 30);
    currentNoteIndex = null;
  }
});
elements.notesClearBtn.addEventListener('click', () => {
  if (editingBfNote) {
    if (confirm('Erase this note?')) {
      owners[currentOwner].broughtForwardNote = '';
      editingBfNote = false;
      saveState();
      renderAll();
    hideModal(elements.notesModal);
    }
  } else {
    if (currentNoteIndex === null) return;
    if (confirm('Erase this note?')) {
      notes[currentNoteIndex] = '';
      saveState();
      renderAll();
    hideModal(elements.notesModal);
      currentNoteIndex = null;
    }
  }
});
elements.projectCancelBtn.addEventListener('click', () => {
  hideModal(elements.projectModal);
  currentProjectIndex = null;
});
elements.projectSaveBtn.addEventListener('click', () => {
  if (currentProjectIndex === null) return;
  projects[currentProjectIndex] = elements.projectInput.value.trim().slice(0, 100);
  saveState();
  renderAll();
  hideModal(elements.projectModal);
  setTimeout(forceHideAllVisibleModals, 30);
  currentProjectIndex = null;
});
elements.projectClearBtn.addEventListener('click', () => {
  if (currentProjectIndex === null) return;
  if (confirm('Erase this project?')) {
    projects[currentProjectIndex] = '';
    saveState();
    renderAll();
    hideModal(elements.projectModal);
    currentProjectIndex = null;
  }
});
function openDatePicker(index) {
  currentDateIndex = index;
  elements.dateInput1.value = (keyDates[index] && keyDates[index][0]) ? keyDates[index][0] : '';
  elements.dateInput2.value = (keyDates[index] && keyDates[index][1]) ? keyDates[index][1] : '';
  
  if (elements.dateInput3) { elements.dateInput3.value = (keyDates[index] && keyDates[index][2]) ? keyDates[index][2] : ''; }
elements.dateClearBtn.style.display = (keyDates[index] && keyDates[index].length > 0) ? 'inline-block' : 'none';
  showModalSafely(elements.dateModal);
  elements.dateInput1.focus();
}
elements.dateCancelBtn.addEventListener('click', () => {
  hideModal(elements.dateModal);
  currentDateIndex = null;
});
elements.dateSaveBtn.addEventListener('click', () => {
  if (currentDateIndex === null) return;
  const d1 = elements.dateInput1.value;
  const d2 = elements.dateInput2.value;
  const d3 = elements.dateInput3 ? elements.dateInput3.value : '';
  const arr = [d1, d2, d3].filter(Boolean).sort();
  keyDates[currentDateIndex] = arr;
  saveState();
  renderAll();
  hideModal(elements.dateModal);
  setTimeout(forceHideAllVisibleModals, 30);
  currentDateIndex = null;
});
elements.dateClearBtn.addEventListener('click', () => {
  if (currentDateIndex === null) return;
  if (confirm('Erase these dates?')) {
    keyDates[currentDateIndex] = [];
    saveState();
    renderAll();
    hideModal(elements.dateModal);
    currentDateIndex = null;
  }
});
// Close button event handlers
elements.notesCloseBtn.addEventListener('click', () => {
  hideModal(elements.notesModal);
  currentNoteIndex = null;
});
elements.projectCloseBtn.addEventListener('click', () => {
  hideModal(elements.projectModal);
  currentProjectIndex = null;
});
elements.dateCloseBtn.addEventListener('click', () => {
  hideModal(elements.dateModal);
  currentDateIndex = null;
});
elements.closeScenarioBtn.addEventListener('click', () => {
  hideModal(elements.scenarioModal);
});
// toggle editing
elements.monthlyLockToggle.addEventListener('click', () => {
  const owner = owners[currentOwner];
  if (owner.password && !monthlyEditingEnabled) {
    const input = prompt(`Enter password for ${owner.name}:`);
    if (input !== owner.password) {
      alert('Incorrect password!');
      return;
    }
  }
  monthlyEditingEnabled = !monthlyEditingEnabled;
  elements.monthlyLockToggle.textContent = monthlyEditingEnabled ? '🔓 Edit' : '🔒 Lock';
  elements.monthlyLockToggle.setAttribute('aria-label', monthlyEditingEnabled ? 'Lock editing' : 'Unlock editing');
  saveState();
  renderAll();
});
// change owner
elements.ownerSelect.addEventListener('change', () => {
  const newOwner = elements.ownerSelect.value;
  const owner = owners[newOwner];
  if (owner.password && monthlyEditingEnabled) {
    const input = prompt(`Enter password for ${owner.name}:`);
    if (input !== owner.password) {
      alert('Incorrect password!');
      elements.ownerSelect.value = currentOwner;
      return;
    }
    monthlyEditingEnabled = false;
    elements.monthlyLockToggle.textContent = '🔒 Lock';
    elements.monthlyLockToggle.setAttribute('aria-label', 'Unlock editing');
  }
  currentOwner = newOwner;
  updateCurrentOwnerData();
  saveState();
  renderAll();
  applyOwnerThemeById(currentOwner);
  flashOwnerName();
});
// reset data
elements.btnResetMain.addEventListener('click', () => {
  const owner = owners[currentOwner];
  if (owner.password) {
    const input = prompt(`Enter password for ${owner.name} to reset data:`);
    if (input !== owner.password) {
      alert('Incorrect password!');
      return;
    }
  }
  if (!confirm('Reset all data to zeros?')) return;
  owners[currentOwner].monthlyTargets = new Array(12).fill(0);
  owners[currentOwner].actuals = new Array(12).fill(0);
  owners[currentOwner].expected = new Array(12).fill(0);
  owners[currentOwner].notes = new Array(12).fill('');
  owners[currentOwner].keyDates = new Array(12).fill(null).map(() => []);
  owners[currentOwner].projects = new Array(12).fill('');
  owners[currentOwner].broughtForward = 0;
  monthlyEditingEnabled = false;
  updateCurrentOwnerData();
  saveState();
  renderAll();
});
// change owner name
elements.btnChangeName.addEventListener('click', () => {
  const owner = owners[currentOwner];
  let passOk = true;
  if (owner.password) {
    const input = prompt(`Enter current password for ${owner.name} to change name:`);
    if (input !== owner.password) {
      alert('Incorrect password!');
      passOk = false;
    }
  }
  if (passOk) {
    const newName = prompt('Enter new name:', owner.name);
    if (newName && newName.trim()) {
      owners[currentOwner].name = newName.trim();
      updateOwnerOptions();
      updateCurrentOwnerData();
    updateTipToggleLabel();
      saveState();
      renderAll();
    }
  }
});
// change password
elements.btnChangePassword.addEventListener('click', () => {
  const owner = owners[currentOwner];
  let oldPass = '';
  if (owner.password) {
    oldPass = prompt(`Enter current password for ${owner.name}:`);
    if (oldPass !== owner.password) {
      alert('Incorrect password!');
      return;
    }
  }
  const newPass = prompt('Enter new password (leave blank to remove):');
  if (newPass !== null) {
    owners[currentOwner].password = newPass.trim() || null;
    saveState();
    alert('Password updated.');
  }
});
// Excel export
elements.btnExportExcel.addEventListener('click', () => {
  try {
    const wb = XLSX.utils.book_new();
    const yearlyTarget = monthlyTargets.reduce((a, b) => a + (Number(b) || 0), 0);
    const sumActuals = actuals.reduce((a, b) => a + (Number(b) || 0), 0) + (owners[currentOwner].broughtForward || 0);
    const remaining = yearlyTarget - sumActuals;
    const completion = yearlyTarget ? (sumActuals / yearlyTarget) : 0;
    let best = { i: 0, v: -Infinity }, worst = { i: 0, v: Infinity };
    for (let i = 0; i < 12; i++) {
      const v = Number(actuals[i] || 0) - Number(monthlyTargets[i] || 0);
      if (v > best.v) best = { i, v };
      if (v < worst.v) worst = { i, v };
    }
    const wsData = [];
    // Title and owner
    wsData.push(['Performance Tracker']);
    wsData.push(['Owner', owners[currentOwner].name]);
    wsData.push(['Year', currentYear]);
    wsData.push([]);
    // Summary section
    wsData.push(['Summary']);
    wsData.push(['Early Target 🎯', yearlyTarget]);
    wsData.push(['Brought Forward', owners[currentOwner].broughtForward]);
    wsData.push(['YTD Actual Inflow 💰', sumActuals]);
    wsData.push(['Remaining 📉', remaining]);
    wsData.push(['Year Completion', (completion * 100).toFixed(2) + '%']);
    // Additional KPIs
    // Avg. Monthly Target (use absolute monthly targets to avoid negative-month distortions)
    const totalTargetAbs = monthlyTargets.reduce((a,b) => a + Math.abs(Number(b) || 0), 0);
    const avgMonthly = Math.round(totalTargetAbs / 12);
    // Avg. Actual Monthly Inflow (based on months with recorded inflows up to last non-zero month)
    let lastMonthIndex = -1;
    for (let i = 0; i < actuals.length; i++) { if (actuals[i] && actuals[i] != 0) lastMonthIndex = i; }
    const monthsPassed = lastMonthIndex >= 0 ? lastMonthIndex + 1 : 0;
    let totalActualUpTo = 0;
    if (monthsPassed > 0) {
      for (let j = 0; j <= lastMonthIndex; j++) { totalActualUpTo += Math.abs(Number(actuals[j] || 0)); }
    }
    const avgActualMonthly = monthsPassed > 0 ? Math.round(totalActualUpTo / monthsPassed) : 0;
    // Monthly Variance (avgActual - avgTarget)
    const monthlyVariance = Math.round(avgActualMonthly - avgMonthly);
    // Total Deviation vs required YTD
    const requiredYTD = yearlyTarget ? Math.round((yearlyTarget / 12) * monthsPassed) : 0;
    const deviation = Math.round(sumActuals - requiredYTD);
    // Forecast: linear projection based on YTD and months passed
    const forecast = monthsPassed > 0 ? Math.round((sumActuals / monthsPassed) * 12) : Math.round(yearlyTarget || 0);
    wsData.push(['Avg. Mo. Target', avgMonthly]);
    wsData.push(['Avg. Mo. Inflow', avgActualMonthly]);
    wsData.push(['Mo. Variance', monthlyVariance]);
    wsData.push(['Total Deviation', deviation]);
    wsData.push(['Forecasted Year‑End', forecast]);
    // Year progress and next needed summary
    const yearProgress = getYearProgress().toFixed(1) + '%';
    const nextInfo = findNextNeededMonth();
    let nextMonthName = '';
    let nextTarget = '';
    let nextShortage = '';
    let nextDays = '';
    if (nextInfo) {
      const idx = nextInfo.index;
      nextMonthName = months[idx];
      nextTarget = Number(monthlyTargets[idx] || 0);
      const accumBefore = getAccumVarianceBeforeMonth(idx);
      const currentVar = (Number(actuals[idx] || 0) - Number(monthlyTargets[idx] || 0));
      const accumAfter = accumBefore + currentVar;
      nextShortage = Math.max(0, -accumAfter);
      nextDays = getDaysToNext(keyDates[idx]);
    }
    wsData.push(['Year Progress', yearProgress]);
    wsData.push(['Next Needed Month', nextMonthName]);
    wsData.push(['Next Month Target', nextTarget]);
    wsData.push(['Shortage (Balance)', nextShortage]);
    wsData.push(['Days to Next', nextDays]);
    // Best/worst month summary
    wsData.push(['Best Month', months[best.i], best.v]);
    wsData.push(['Worst Month', months[worst.i], worst.v]);
    wsData.push([]);
    // Monthly data header
    wsData.push(['Monthly Data']);
    wsData.push(['Key Dates','Days to Next','Project','Notes','Target','Month','Expected Inflow','Actual Inflow (Past History)','Variance','Balance']);
    let accum = 0;
    for (let i = 0; i < 12; i++) {
      const t = Number(monthlyTargets[i] || 0);
      const a = Number(actuals[i] || 0);
      const exp = Number(expected[i] || 0);
      const project = projects[i] || '';
      const v = a - t;
      accum += v;
      const dates = (keyDates[i] || []).map(d => d ? (new Date(d)).toLocaleDateString('en-GB') : '').filter(Boolean).join('; ');
      const days = getDaysToNext(keyDates[i]);
      wsData.push([
        dates || '',
        days,
        project,
        notes[i] || '',
        t,
        months[i],
        exp,
        a,
        v,
        accum
      ]);
    }
    wsData.push(['Total','','','','', yearlyTarget, '', '', sumActuals, sumActuals - yearlyTarget, accum]);
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    for (let r = 14; r < 26; r++) {
      const v = ws[`I${r + 1}`]?.v;
      if (v !== undefined) {
        ws[`I${r + 1}`].s = { font: { color: { rgb: v > 0 ? '008000' : v < 0 ? 'FF0000' : '000000' } } };
      }
      const av = ws[`J${r + 1}`]?.v;
      if (av !== undefined) {
        ws[`J${r + 1}`].s = { font: { color: { rgb: av > 0 ? '008000' : av < 0 ? 'FF0000' : '000000' } } };
      }
    }
    XLSX.utils.book_append_sheet(wb, ws, 'Report');
    XLSX.writeFile(wb, `Performance_Tracker_${owners[currentOwner].name}.xlsx`);
  } catch (e) {
    console.error(e);
    alert('Excel export failed');
  }
});
// Import Excel
elements.btnImportExcel.addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.xlsx';
  input.click();
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data);
    const ws = wb.Sheets[wb.SheetNames[0]];
    const json = XLSX.utils.sheet_to_json(ws, {header:1});
    let monthlyStart = -1;
    for (let r = 0; r < json.length; r++) {
      if (json[r][0] === 'Monthly Data') {
        monthlyStart = r + 2; // header is next row
        break;
      }
    }
    if (monthlyStart === -1) return alert('Invalid format: Monthly Data not found');
    for (let i = 0; i < 12; i++) {
      const row = json[monthlyStart + i];
      if (!row) continue;
      // Parse dates from DD/MM/YYYY format to JavaScript Date objects
      if (row[0]) {
        const dateStrings = row[0].split('; ').filter(Boolean);
        keyDates[i] = dateStrings.map(dateStr => {
          // Parse DD/MM/YYYY format
          const parts = dateStr.trim().split('/');
          if (parts.length === 3) {
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // JavaScript months are 0-based
            const year = parseInt(parts[2], 10);
            if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
              return new Date(year, month, day);
            }
          }
          return dateStr; // fallback to original string if parsing fails
        });
      } else {
        keyDates[i] = [];
      }
      // Days to next skipped
      projects[i] = row[2] || '';
      notes[i] = row[3] || '';
      monthlyTargets[i] = parseInput(row[4]) || 0;
      // Month name row[5] ignored
      expected[i] = parseInput(row[6]) || 0;
      actuals[i] = parseInput(row[7]) || 0;
      // variance row[8] ignored, accum row[9] ignored
    }
    // get Brought Forward
    let bfRow = -1;
    for (let r = 0; r < json.length; r++) {
      if (json[r][0] === 'Brought Forward') {
        bfRow = r;
        break;
      }
    }
    if (bfRow !== -1) {
      owners[currentOwner].broughtForward = parseInput(json[bfRow][1]) || 0;
    }
    saveState();
    renderAll();
  };
});
// PDF export
elements.btnExportPDF.addEventListener('click', async () => {
  try {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    const el = document.querySelector('.wrap');

    // Ensure all content is visible and scroll to top
    el.scrollIntoView();
    window.scrollTo(0, 0);

    // Use html2canvas with optimized settings for lighter PDF
    const canvas = await html2canvas(el, {
      backgroundColor: '#ffffff',
      scale: 0.8, // Reduced scale for lighter file size
      useCORS: true,
      allowTaint: true,
      scrollX: 0,
      scrollY: 0,
      windowWidth: el.scrollWidth,
      windowHeight: el.scrollHeight,
      width: el.scrollWidth,
      height: el.scrollHeight,
      imageTimeout: 0,
      removeContainer: true,
      logging: false
    });

    const img = canvas.toDataURL('image/jpeg', 0.7); // Use JPEG with 70% quality for better compression
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const imgProps = doc.getImageProperties(img);
    const imgWidth = imgProps.width;
    const imgHeight = imgProps.height;

    // Calculate dimensions
    const ratio = imgWidth / pageWidth;
    const scaledImgHeight = imgHeight / ratio;
    const contentHeightPerPage = pageHeight;

    // Calculate how many pages we need
    const totalPages = Math.ceil(scaledImgHeight / contentHeightPerPage);

    // Split the image across pages properly
    for (let page = 0; page < totalPages; page++) {
      if (page > 0) {
        doc.addPage();
      }

      // Calculate the portion of the image for this page
      const sourceY = page * contentHeightPerPage * ratio;
      const sourceHeight = Math.min(contentHeightPerPage * ratio, imgHeight - sourceY);

      if (sourceHeight > 0) {
        // Create a temporary canvas for this page's portion
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imgWidth;
        tempCanvas.height = sourceHeight;

        // Draw the portion of the original image
        const originalImg = new Image();
        originalImg.src = img;

        await new Promise((resolve) => {
          originalImg.onload = () => {
            tempCtx.drawImage(
              originalImg,
              0, sourceY, imgWidth, sourceHeight,  // Source rectangle
              0, 0, imgWidth, sourceHeight          // Destination rectangle
            );
            resolve();
          };
        });

        const pageImg = tempCanvas.toDataURL('image/jpeg', 0.7); // Use JPEG for consistent compression
        doc.addImage(pageImg, 'PNG', 0, 0, pageWidth, (sourceHeight / ratio));
      }
    }

    doc.save(`Performance_Tracker_${owners[currentOwner].name}.pdf`);
  } catch (e) {
    console.error(e);
    alert('PDF export failed: ' + e.message);
  }
});
// Print
elements.btnPrint.addEventListener('click', () => window.print());
// toggles upcoming/all months
elements.btnToggleFuture.addEventListener('click', () => {
  showUpcomingOnly = true;
  renderAll();
});
elements.btnToggleAll.addEventListener('click', () => {
  showUpcomingOnly = false;
  renderAll();
});
// toggle chart view
elements.btnToggleView.addEventListener('click', () => {
  chartMode = (chartMode === 'bars') ? 'cumulative' : 'bars';
  localStorage.setItem('chartMode', chartMode);
  renderChart();
});
// dark mode toggle
elements.darkToggle.addEventListener('click', () => {
  darkMode = !darkMode;
  document.body.classList.toggle('dark', darkMode);
  elements.darkToggle.textContent = darkMode ? '☀️' : '🌙';
  elements.darkToggle.setAttribute('aria-label', darkMode ? 'Switch to light mode' : 'Switch to dark mode');
  saveState();
  renderChart();
  renderGauge();
});
// Info button for Brought Forward explanation
elements.bfInfoBtn.addEventListener('click', () => {
  alert('Brought forward represents the amount carried over from previous periods (e.g., last year or previous months). It is added to current year actuals when calculating YTD inflow and can be edited when unlocking monthly editing.');
});
// Year change listener
elements.yearInput.addEventListener('change', (ev) => {
  const year = parseInt(ev.target.value, 10);
  if (Number.isNaN(year) || year < 2000 || year > 2100) {
    alert('Invalid year');
    ev.target.value = currentYear;
    return;
  }
  // save current state before switching year
  saveState();
  currentYear = year;
  storageKey = getStorageKey(currentYear);
  // load state for new year
  loadState();
  renderAll();
});
function renderAll() {
  // update local date/time display according to Dubai timezone
  elements.localDate.textContent = getNow().toLocaleString('en-GB', {
    dateStyle: 'medium',
    timeStyle: 'short',
    timeZone: 'Asia/Dubai'
  });
  recalcSummary();
  renderMonthsMini();
  renderTable();
  renderChart();
  renderGauge();
  // update lock/unlock text
  elements.monthlyLockToggle.textContent = monthlyEditingEnabled ? '🔓 Edit' : '🔒 Lock';
  elements.monthlyLockToggle.setAttribute('aria-label', monthlyEditingEnabled ? 'Lock editing' : 'Unlock editing');
  // update dark toggle text
  elements.darkToggle.textContent = darkMode ? '☀️' : '🌙';
  elements.darkToggle.setAttribute('aria-label', darkMode ? 'Switch to light mode' : 'Switch to dark mode');
  // set year input value
  elements.yearInput.value = currentYear;
  // update Brought Forward note button title if present
  
  // Ensure next needed ribbon is updated after all other calculations
  // Remove the separate refresh call to avoid conflicts
  setTimeout(() => {
    // Debug: Log year context for troubleshooting
    console.log('renderAll completed for year:', window.currentYear || new Date().getFullYear());
  }, 100);
  if (elements.bfNoteBtn) {
    const note = owners[currentOwner].broughtForwardNote;
    elements.bfNoteBtn.title = note && note.trim() ? note : 'Add note for Brought Forward';
  }
}
// Initialize the app

// === ENTER-TO-SAVE SHORTCUTS ===
function attachEnterToSaveShortcuts(){
  // Notes: Enter -> Save (Shift+Enter keeps newline), Esc -> Cancel
  if (elements.notesTextarea) {
    elements.notesTextarea.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        elements.notesSaveBtn.click();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        elements.notesCancelBtn.click();
      }
    });
  }

  // Project name: Enter -> Save, Esc -> Cancel
  if (elements.projectInput) {
    elements.projectInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.projectSaveBtn.click();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        elements.projectCancelBtn.click();
      }
    });
  }

  // Date inputs: Enter -> Save, Esc -> Cancel
  [elements.dateInput1, elements.dateInput2].forEach((inp) => {
    if (!inp) return;
    inp.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elements.dateSaveBtn.click();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        elements.dateCancelBtn.click();
      }
    });
  });

  // Modal-level fallback: ensure Enter/Escape work even if individual inputs miss the event
  try {
    if (elements.notesModal) {
      elements.notesModal.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          e.stopPropagation();
          elements.notesSaveBtn && elements.notesSaveBtn.click();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          e.stopPropagation();
          elements.notesCancelBtn && elements.notesCancelBtn.click();
        }
      });
    }
    if (elements.projectModal) {
      elements.projectModal.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          elements.projectSaveBtn && elements.projectSaveBtn.click();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          e.stopPropagation();
          elements.projectCancelBtn && elements.projectCancelBtn.click();
        }
      });
    }
    if (elements.dateModal) {
      elements.dateModal.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          elements.dateSaveBtn && elements.dateSaveBtn.click();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          e.stopPropagation();
          elements.dateCancelBtn && elements.dateCancelBtn.click();
        }
      });
    }
  } catch (err) { console.warn('Modal-level enter shortcuts failed', err); }
}

// Document-level fallback (capture phase) – ensure Enter/Escape act on visible modals
try {
  document.addEventListener('keydown', (e) => {
    // If user is composing in an IME, ignore
    if (e.isComposing) return;
    const notesVisible = elements.notesModal && elements.notesModal.classList.contains('visible');
    const projVisible = elements.projectModal && elements.projectModal.classList.contains('visible');
    const dateVisible = elements.dateModal && elements.dateModal.classList.contains('visible');

    // If no modal is visible, do nothing here
    if (!notesVisible && !projVisible && !dateVisible) return;

    // Escape should close active modal(s)
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
      if (notesVisible) elements.notesCancelBtn && elements.notesCancelBtn.click();
      if (projVisible) elements.projectCancelBtn && elements.projectCancelBtn.click();
      if (dateVisible) elements.dateCancelBtn && elements.dateCancelBtn.click();
      return;
    }

    // Enter handling. For notes modal allow Shift+Enter (newline).
    if (e.key === 'Enter') {
      // If notes modal and shiftKey => allow newline
      if (notesVisible && e.shiftKey) return;
      e.preventDefault();
      e.stopPropagation();
      if (notesVisible) { elements.notesSaveBtn && elements.notesSaveBtn.click(); return; }
      if (projVisible) { elements.projectSaveBtn && elements.projectSaveBtn.click(); return; }
      if (dateVisible) { elements.dateSaveBtn && elements.dateSaveBtn.click(); return; }
    }
  }, true);
} catch (err) { console.warn('Document-level modal enter handler failed', err); }


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
function init() {
  // set year input initial value
  elements.yearInput.value = currentYear;
  loadState();
  document.body.classList.toggle('dark', darkMode);
  elements.darkToggle.textContent = darkMode ? '☀️' : '🌙';
  elements.darkToggle.setAttribute('aria-label', darkMode ? 'Switch to light mode' : 'Switch to dark mode');
  elements.monthlyLockToggle.textContent = monthlyEditingEnabled ? '🔓 Edit' : '🔒 Lock';
  elements.monthlyLockToggle.setAttribute('aria-label', monthlyEditingEnabled ? 'Lock editing' : 'Unlock editing');
  attachTableEditListeners();
    attachEnterToSaveShortcuts();
// attach click listener to Brought Forward note button if it exists
  if (elements.bfNoteBtn) {
    elements.bfNoteBtn.addEventListener('click', () => {
      openBfNote();
    });
  }
  renderAll();
}
// Run initialization
init();

// ===== Custom Hover Tooltip (Projects, Notes, Key Dates) =====
(function(){
  const tip = document.getElementById('__tooltip');
  if (!tip) return;

  let hideTimer = null;
  const MARGIN = 12;

  function showTip(label, text, x, y) {
    if (!text) return hideTip();
    tip.innerHTML = (label ? `<span class="__label">${escapeHtml(label)}</span>` : '') + escapeHtml(String(text));
    tip.classList.add('__on');
    tip.setAttribute('aria-hidden','false');
    positionTip(x, y);
  }
  function hideTip() {
    tip.classList.remove('__on');
    tip.setAttribute('aria-hidden','true');
  }
  function positionTip(mouseX, mouseY) {
    const rect = tip.getBoundingClientRect();
    let left = mouseX + MARGIN;
    let top = mouseY + MARGIN;
    const vw = window.innerWidth, vh = window.innerHeight;
    if (left + rect.width + 8 > vw) left = vw - rect.width - 8;
    if (top + rect.height + 8 > vh) top = vh - rect.height - 8;
    tip.style.left = left + 'px';
    tip.style.top = top + 'px';
  }
  function escapeHtml(s){
    return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
  }

  // Delegate hover across the table for specific fields
  const tbl = document.getElementById('dataTable');
  if (!tbl) return;

  function getDateText(td){
    // find date inputs inside the cell
    const ins = td.querySelectorAll('input[type="date"]');
    if (!ins || ins.length === 0) return '';
    const v1 = ins[0]?.value || '';
    const v2 = ins[1]?.value || '';
    const parts = [];
    if (v1) parts.append ? parts.append(`From: ${v1}`) : parts.push(`From: ${v1}`);
    if (v2) parts.push(`To: ${v2}`);
    return parts.join(' | ');
  }

  function findFieldLabel(target){
    // Inspect header to map column index to labels
    const cell = target.closest('td,th');
    if (!cell || !cell.parentElement) return '';
    const row = cell.parentElement;
    const idx = Array.prototype.indexOf.call(row.children, cell);
    const ths = tbl.tHead ? tbl.tHead.rows[0].cells : null;
    if (ths && ths[idx]) return ths[idx].textContent.trim();
    return '';
  }

  tbl.addEventListener('mousemove', (e) => {
    const el = e.target;
    if (!(el instanceof HTMLElement)) return;

    let label = '';
    let text = '';

    // Notes textarea
    if (el.tagName === 'TEXTAREA') {
      label = findFieldLabel(el);
      text = el.value || '';
    }
    // Project input[type=text]
    else if (el.tagName === 'INPUT' && el.type === 'text') {
      label = findFieldLabel(el);
      text = el.value || '';
    }
    // Key Dates cell or its date inputs
    else {
      const dateTd = el.closest('td');
      if (dateTd && findFieldLabel(dateTd) && dateTd.querySelector('input[type="date"]')) {
        label = findFieldLabel(dateTd);
        text = getDateText(dateTd);
      }
    }

    if (text && (label.includes('Project') || label.includes('Notes') || label.includes('Key'))) {
      showTip(label, text, e.clientX, e.clientY);
    } else {
      hideTip();
    }
  });

  tbl.addEventListener('mouseleave', hideTip);
})();

</script>
<!-- === Injected: Global hover tooltip engine (non-invasive) === -->
<script>
(function initHoverTooltips(){
  const tip = document.getElementById('__tooltip');
  if (!tip) return;

  let active = null;

  function show(contentHTML, evt, labelText) {
    if (!window.tooltipsEnabled) return;
    tip.innerHTML = (labelText ? '<span class="__label">' + labelText + '</span>' : '') + contentHTML;
    tip.setAttribute('aria-hidden','false');
    tip.classList.add('__on');
    position(evt);
  }

  function hide() {
    tip.classList.remove('__on');
    tip.setAttribute('aria-hidden','true');
    active = null;
  }

  function position(evt) {
    const pad = 10;
    const vw = window.innerWidth, vh = window.innerHeight;
    const rect = tip.getBoundingClientRect();
    let left = evt.clientX + pad;
    let top  = evt.clientY + pad;
    if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
    if (top + rect.height + pad > vh) top = Math.max(pad, vh - rect.height - pad);
    tip.style.left = left + 'px';
    tip.style.top  = top  + 'px';
  }

  function fallbackFromCell(cell){
    // Use full text content as fallback
    const t = (cell.textContent || '').trim();
    return t || '';
  }

  document.addEventListener('mousemove', function(evt){
    if (!window.tooltipsEnabled) { if (active) hide(); return; }

    const cell = evt.target.closest('td');
    if (!cell || !cell.closest('tbody')) { 
      if (active) hide();
      return;
    }

    // Prefer explicit data-tip attributes
    let label = cell.getAttribute('data-tip-label') || '';
    let content = cell.getAttribute('data-tip');

    if (!content) {
      // numbers/everything: show the full text of the cell as generic tooltip
      content = fallbackFromCell(cell);
    }

    if (content) {
      if (active !== cell) {
        active = cell;
        show(content, evt, label);
      } else {
        position(evt);
      }
    } else if (active) {
      hide();
    }
  }, { passive: true });

  document.addEventListener('scroll', hide, true);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hide(); });
})();
</script>
<script>
// === Auto-Save Augmentation (non-destructive) ===
(function () {
  // Debounce helper
  let __as_timer = null;
  function __debounceSave(ms=250) {
    if (__as_timer) clearTimeout(__as_timer);
    __as_timer = setTimeout(() => { try { saveState(); } catch(e) {} }, ms);
  }

  // Saved-at indicator
  function updateSavedAt() {
    const el = document.getElementById('savedAt');
    if (!el) return;
    const now = new Date();
    // Format as HH:MM:SS
    const pad = n => String(n).padStart(2, '0');
    const t = pad(now.getHours()) + ':' + pad(now.getMinutes()) + ':' + pad(now.getSeconds());
    el.textContent = t;
    el.title = now.toLocaleString('en-GB');
  }
  window.updateSavedAt = updateSavedAt;

  // Wrap existing saveState to also update the indicator
  if (typeof window.saveState === 'function') {
    const __oldSave = window.saveState;
    window.saveState = function() {
      const r = __oldSave.apply(this, arguments);
      try { updateSavedAt(); } catch (e) {}
      return r;
    };
  }

  // Ensure yearInput reflects currentYear, and switching years uses per-year storage
  try {
    const yEl = document.getElementById('yearInput');
    if (yEl && typeof window.getStorageKey === 'function') {
      if (typeof window.currentYear === 'number') {
        yEl.value = window.currentYear;
      } else {
        const nowY = new Date().getFullYear();
        yEl.value = nowY;
        window.currentYear = nowY;
      }
      yEl.addEventListener('change', function () {
        const v = parseInt(this.value, 10);
        if (!isFinite(v) || v < 2000 || v > 2100) return;
        // save current state under old key first
        try { saveState(); } catch(e) {}
        // switch storage key to new year and load
        try {
          window.currentYear = v;
          window.storageKey = window.getStorageKey(v);
          if (typeof window.loadState === 'function') {
            window.loadState();
          }
          // re-render UI after switching year if functions exist
          if (typeof window.renderTable === 'function') window.renderTable();
          if (typeof window.recalcSummary === 'function') window.recalcSummary();
          if (typeof window.renderChart === 'function') window.renderChart();
          if (typeof window.renderMonthsMini === 'function') window.renderMonthsMini();
          if (typeof window.renderGauge === 'function') window.renderGauge();
          // finally save the freshly loaded state for the new year (to persist flags like toggles)
          try { saveState(); } catch(e) {}
        } catch (e) { console.warn('Year switch failed', e); }
      });
    }
  } catch (e) { console.warn(e); }

  // Owner change autosave (save before and after change via existing handlers)
  try {
    const ownerSel = document.getElementById('ownerSelect');
    if (ownerSel) {
      ownerSel.addEventListener('change', function () {
        try { saveState(); } catch(e) {}
        // allow existing code to handle the switch; then save again shortly
        setTimeout(() => { try { saveState(); } catch(e) {} }, 200);
      });
    }
  } catch (e) { console.warn(e); }

  // Core inputs autosave (dates, textareas, text inputs)
  document.addEventListener('input', function (e) {
    const t = e.target;
    if (!t) return;
    if (t.matches('input, textarea, [contenteditable="true"]')) {
      __debounceSave(400);
    }
  }, true);

  // Commit-on-Enter autosave for table edits or modals
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      // slightly delay to allow model/arrays update handlers to run first
      setTimeout(() => { try { saveState(); } catch(e) {} }, 50);
    }
  }, true);

  // Click autosave for common save/clear buttons & toggles
  const clickIds = [
    'notesSaveBtn','notesClearBtn',
    'dateSaveBtn','dateClearBtn',
    'projectSaveBtn','projectClearBtn',
    'monthlyLockToggle','darkToggle','tipToggle',
    'btnToggleFuture','btnToggleAll','btnToggleView',
    'btnReset','btnChangeName','btnChangePassword',
    'bfNoteBtn','bfInfoBtn','btnExportExcel','btnImportExcel'
  ];
  document.addEventListener('click', function (e) {
    const t = e.target;
    if (!t) return;
    // match by id or within button with matching id
    for (const id of clickIds) {
      if (t.id === id || t.closest('#'+id)) {
        setTimeout(() => { try { saveState(); } catch(e) {} }, 80);
        break;
      }
    }
    // also capture table cell edits that might be using custom handlers
    if (t.closest('td.editable') || t.closest('.modal button')) {
      setTimeout(() => { try { saveState(); } catch(e) {} }, 120);
    }
  }, true);

  // On first load, show last saved if we already have state
  try {
    const raw = localStorage.getItem(window.storageKey || '');
    if (raw) updateSavedAt();
  } catch (e) {}

})();

// === Minimal tooltip hover binding for any element with [data-tip] ===
function attachHoverTooltips() {
  const tipEl = document.getElementById('__tooltip');
  if (!tipEl) return;

  function showTip(ev, label, content) {
    if (!window.tooltipsEnabled) return;
    tipEl.innerHTML = (label ? '<span class="__label">'+ label +'</span>' : '') + (content || '');
    tipEl.classList.add('__on');
    tipEl.setAttribute('aria-hidden', 'false');
    const pad = 10;
    const x = ev.clientX + pad;
    const y = ev.clientY + pad;
    tipEl.style.left = x + 'px';
    tipEl.style.top = y + 'px';
  }
  function hideTip() {
    tipEl.classList.remove('__on');
    tipEl.setAttribute('aria-hidden', 'true');
  }
  function moveTip(ev) {
    const pad = 10;
    tipEl.style.left = (ev.clientX + pad) + 'px';
    tipEl.style.top = (ev.clientY + pad) + 'px';
  }

  document.addEventListener('mouseover', (e) => {
    const t = e.target.closest('[data-tip]');
    if (!t) return;
    showTip(e, t.getAttribute('data-tip-label') || '', t.getAttribute('data-tip') || '');
  });
  document.addEventListener('mousemove', (e) => {
    if (!tipEl.classList.contains('__on')) return;
    moveTip(e);
  });
  document.addEventListener('mouseout', (e) => {
    const t = e.target.closest('[data-tip]');
    if (t) hideTip();
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}

document.addEventListener('DOMContentLoaded', attachHoverTooltips);

// === Owner theme application ===
function applyOwnerTheme() {
  const el = elements.ownerNameDisplay;
  if (!el) return;
  // Remove any existing owner-theme-X class
  for (let i=1; i<=10; i++) el.classList.remove('owner-theme-' + i);
  // Map owner id to theme number (owner1 -> 1, ..., owner10 -> 10)
  const idx = Number((currentOwner.replace('owner',''))) || 1;
  el.classList.add('owner-theme-' + idx);
}
// Hook into owner change if not already
if (elements.ownerSelect) {
  elements.ownerSelect.addEventListener('change', () => {
    // currentOwner likely updated elsewhere; ensure theme update runs after
    setTimeout(applyOwnerTheme, 0);
  });
}


// Color picker for YTD Bank Inflow (per owner & year)
if (elements.ytdColor) {
  elements.ytdColor.addEventListener('input', () => {
    const val = elements.ytdColor.value || '#2E8B57';
    owners[currentOwner].ytdColor = val;
    if (elements.dashYtdAccomplished) elements.dashYtdAccomplished.style.color = savedYtdColor;
    saveState();
  });
}
// Color picker for Remaining (per owner & year)
if (elements.remainingColor) {
  elements.remainingColor.addEventListener('input', () => {
    const val = elements.remainingColor.value || '#d46b6b';
    owners[currentOwner].remainingColor = val;
    if (elements.dashRemaining) elements.dashRemaining.style.color = savedRemainingColor;
    saveState();
  });
}

// Color picker for General Notes (per owner & year)
if (elements.noteColor) {
  elements.noteColor.addEventListener('input', () => {
    const val = elements.noteColor.value || '#102027';
    owners[currentOwner].generalNotesColor = val;
    if (elements.generalNotes) elements.generalNotes.style.color = val;
    saveState();
  });
}
// Apply on initial load after DOM/content + state load
document.addEventListener('DOMContentLoaded', () => {
  // slight delay to make sure loadState() ran
  setTimeout(applyOwnerTheme, 50);
});

// === Owner toggle hard fix ===
function switchOwner(ownerId){
  if (!owners[ownerId]) return;
  currentOwner = ownerId;
  monthlyEditingEnabled = false;
  if (elements.monthlyLockToggle){
    elements.monthlyLockToggle.textContent = '🔒 Lock';
    elements.monthlyLockToggle.setAttribute('aria-label','Unlock editing');
  }
  updateCurrentOwnerData();
  if (elements.ownerSelect) elements.ownerSelect.value = ownerId;
  saveState();
  renderAll && renderAll();
  applyOwnerTheme && applyOwnerTheme();
}
function bindOwnerSelectForce(){
  if (!elements || !elements.ownerSelect) return;
  // Overwrite any earlier handler by assigning directly
  elements.ownerSelect.onchange = function(){
    const val = elements.ownerSelect.value;
    switchOwner(val);
  };
}
// Bind after DOM ready and after loadState effects
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(bindOwnerSelectForce, 0);
  setTimeout(() => { if (elements && elements.ownerSelect) { elements.ownerSelect.value = currentOwner; } }, 20);
});

// === Owner select tiny icon toggle ===
(function initOwnerTinyToggle(){
  const btn = document.getElementById('ownerToggleBtn');
  const sel = document.getElementById('ownerSelect');
  if (!btn || !sel) return;

  // Start hidden
  sel.classList.add('owner-hidden');

  // Toggle open/close on star click
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const open = sel.classList.toggle('owner-show');
    sel.classList.toggle('owner-hidden', !open);
    if (open) {
      sel.focus();
      try { sel.click(); } catch(e){}
    }
  });

  // On change: update app state & close
  sel.addEventListener('change', () => {
    try {
      // If your app uses these globals/functions, update them
      if (typeof elements !== 'undefined' && elements.ownerSelect) {
        const val = elements.ownerSelect.value;
        if (typeof currentOwner !== 'undefined') currentOwner = val;
        if (typeof updateCurrentOwnerData === 'function') updateCurrentOwnerData();
        if (typeof updateOwnerOptions === 'function') updateOwnerOptions();
        if (typeof renderTable === 'function') renderTable();
        if (typeof renderChart === 'function') renderChart();
        if (typeof renderMonthsMini === 'function') renderMonthsMini();
        if (typeof saveState === 'function') saveState();
        if (typeof applyOwnerThemeById === 'function') applyOwnerThemeById(currentOwner);
        if (typeof flashOwnerName === 'function') flashOwnerName();
      }
    } catch(e){ /* no-op */ }

    sel.classList.remove('owner-show');
    sel.classList.add('owner-hidden');
  });

  // Close on losing focus (after option selection UI closes)
  sel.addEventListener('blur', () => {
    // Use a timeout to allow change event (if any) to fire first
    setTimeout(() => {
      sel.classList.remove('owner-show');
      sel.classList.add('owner-hidden');
    }, 100);
  }, true);

  // We intentionally DO NOT close on generic document clicks because
  // the native options popup isn't part of the DOM and would be treated
  // as an outside click in some browsers, preventing selection.
})();

// === Generic hover tooltip for any [data-tip] element (uses #__tooltip already in DOM) ===
(function initGlobalHoverTips(){
  const tip = document.getElementById('__tooltip');
  if (!tip) return;
  function showTip(el, e){
    if (!window.tooltipsEnabled) return;
    const label = el.getAttribute('data-tip-label') || '';
    const text  = el.getAttribute('data-tip') || '';
    tip.innerHTML = (label ? '<span class="__label">'+label+'</span>' : '') + (text || '');
    tip.classList.add('__on');
    tip.style.left = (e.clientX + 12) + 'px';
    tip.style.top  = (e.clientY + 12) + 'px';
    tip.setAttribute('aria-hidden', 'false');
  }
  function hideTip(){
    tip.classList.remove('__on');
    tip.setAttribute('aria-hidden', 'true');
  }
  document.addEventListener('mousemove', (e) => {
    const el = e.target.closest('[data-tip]');
    if (el && window.tooltipsEnabled) {
      showTip(el, e);
    } else if (tip.classList.contains('__on')) {
      hideTip();
    }
  });
})();

// === Attach hover tooltip to the numbers inside the gauge circle ===
(function initGaugeTooltip(){
  function attachGaugeTooltip(){
    try {
      const m = typeof getCurrentMonthIndex === 'function' ? getCurrentMonthIndex() : (new Date()).getMonth();
      const monthsArr = (typeof months !== 'undefined' && months) ? months : ["January","February","March","April","May","June","July","August","September","October","November","December"];
      const t = (typeof monthlyTargets !== 'undefined' && monthlyTargets[m]) ? Number(monthlyTargets[m]||0) : 0;
      const a = (typeof actuals !== 'undefined' && actuals[m]) ? Number(actuals[m]||0) : 0;
      const v = a - t;
      const gt = document.getElementById('gaugeText');
      if (!gt) return;
      // Ensure there's a number container to hover over:
      gt.setAttribute('data-tip-label', 'This Month');
      gt.setAttribute('data-tip',
        'Month: ' + monthsArr[m] +
        '\nTarget: ' + (typeof formatNumber==='function'?formatNumber(t):t) + ' AED' +
        '\nBank Inflow: ' + (typeof formatNumber==='function'?formatNumber(a):a) + ' AED' +
        '\nVariance: ' + (typeof formatNumber==='function'?formatNumber(v):v) + ' AED'
      );
    } catch(e){ /* no-op */ }
  }
  // run now and periodically to stay in sync with UI updates
  attachGaugeTooltip();
  setInterval(attachGaugeTooltip, 2000);
})();


// === Owner theme + visual confirmation ===
function applyOwnerThemeById(ownerId){
  try {
    const idx = Number(String(ownerId).replace('owner','')) || 1;
    const el = elements && elements.ownerNameDisplay ? elements.ownerNameDisplay : document.getElementById('ownerNameDisplay');
    if (!el) return;
    // remove previous theme classes
    for (let i=1;i<=10;i++) el.classList.remove('owner-theme-'+i);
    el.classList.add('owner-theme-'+Math.max(1, Math.min(10, idx)));
  } catch(e){ /* no-op */ }
}

function flashOwnerName(){
  const el = elements && elements.ownerNameDisplay ? elements.ownerNameDisplay : document.getElementById('ownerNameDisplay');
  if (!el) return;
  el.style.transition = 'filter .3s ease';
  el.style.filter = 'brightness(1.4)';
  setTimeout(()=>{ el.style.filter=''; }, 400);
}

</script>
<script>
// ===== Per-Year Isolation Core =====
(function(){
  function makeOwner(name, pass) {
    return {
      name: name,
      password: pass || "q",
      monthlyTargets: new Array(12).fill(0),
      actuals: new Array(12).fill(0),
      expected: new Array(12).fill(0),
      notes: new Array(12).fill(""),
      keyDates: new Array(12).fill(null).map(() => []),
      projects: new Array(12).fill(""),
      broughtForward: 0,
      broughtForwardNote: ""
    };
  }
  function makeFreshOwners() {
    const o = {};
    for (let i = 1; i <= 10; i++) o['owner' + i] = makeOwner('Owner ' + i, 'q');
    return o;
  }
  // expose factories if needed elsewhere
  window.makeOwner = window.makeOwner || makeOwner;
  window.makeFreshOwners = window.makeFreshOwners || makeFreshOwners;
})();
</script>
<script>
// ===== Per-Year Isolation Init =====
(function(){
  function safe(fn){ try{ fn && fn(); }catch(e){ console.warn('per-year safe:', e); } }
  function refreshUI(){
    safe(window.updateOwnerOptions);
    safe(window.updateCurrentOwnerData);
    safe(window.renderTable);
    safe(window.renderMonthsMini);
    safe(window.renderChart);
    safe(window.updateTipToggleLabel);
    safe(window.updateGauge);
    safe(window.updateDashboard);
  }
  window.initYearSlot = function(year){
    window.currentYear = Number(year) || (new Date()).getFullYear();
    window.storageKey = (typeof window.getStorageKey==='function') ? window.getStorageKey(window.currentYear) : ('performanceTracker:' + window.currentYear);
    let saved = null;
    try { saved = localStorage.getItem(window.storageKey); } catch(e){}
    if (!window.makeFreshOwners) { console.warn('per-year: makeFreshOwners missing'); }
    if (saved) {
      // Reset to ensure shape, then load persisted
      if (window.makeFreshOwners) window.owners = window.makeFreshOwners();
      safe(window.loadState);
    } else {
      if (window.makeFreshOwners) window.owners = window.makeFreshOwners();
      window.currentOwner = window.currentOwner || 'owner1';
      // optional flags
      window.monthlyEditingEnabled = !!window.monthlyEditingEnabled && window.monthlyEditingEnabled;
      if (typeof window.tooltipsEnabled === 'undefined') window.tooltipsEnabled = true;
      safe(window.saveState);
    }
    // reflect the year input if present
    try {
      var yel = document.getElementById('yearInput');
      if (yel) yel.value = String(window.currentYear);
    }catch(e){}
    refreshUI();
  };

  window.addEventListener('DOMContentLoaded', function(){
    // bootstrap current year
    window.initYearSlot(window.currentYear);
    // hook year input changes
    var y = document.getElementById('yearInput');
    if (y && !y._perYearHooked){
      y.addEventListener('change', function(){
        var v = parseInt(y.value,10);
        if (!v || v < 2000 || v > 2100) { y.value = String(window.currentYear); return; }
        window.initYearSlot(v);
      });
      y._perYearHooked = true;
    }
    // Ensure reset only clears current year if there's a reset button
    var resetBtn = document.getElementById('btnReset') || document.querySelector('[data-role="resetYear"]');
    if (resetBtn && !resetBtn._perYearHooked){
      resetBtn.addEventListener('click', function(ev){
        if (!confirm('Reset data for year ' + window.currentYear + '?')) return;
        try { localStorage.removeItem(window.storageKey); } catch(e){}
        if (window.makeFreshOwners) window.owners = window.makeFreshOwners();
        window.currentOwner = 'owner1';
        safe(window.saveState);
        refreshUI();
      });
      resetBtn._perYearHooked = true;
    }
  });
})();

// === Hover tooltip for the numbers inside the circle ===
(function () {
  const gt = document.getElementById('gaugeText');
  if (!gt) return;

  function setGaugeTip() {
    const txt = (gt.textContent || '').trim() || '—';
    gt.setAttribute('data-tip-label', 'Year Progress');
    gt.setAttribute('data-tip', txt);
    gt.setAttribute('title', txt);
  }

  setGaugeTip();

  const mo = new MutationObserver(setGaugeTip);
  mo.observe(gt, { childList: true, subtree: true, characterData: true });

  document.addEventListener('change', (e) => {
    if (e.target && (e.target.id === 'ownerSelect' || e.target.id === 'yearInput')) {
      setTimeout(setGaugeTip, 0);
    }
  });

  ['btnToggleFuture','btnToggleAll','btnToggleView','monthlyLockToggle'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('click', () => setTimeout(setGaugeTip, 0));
  });
})();

</script>
<script>
// === Column Title Color Controls (per owner & year) ===
(function(){
  // Create tiny color dot inputs to the left of each header title in the second header row
  function ensureHeaderPickers(){
    const headerRows = document.querySelectorAll('table thead tr');
    if (!headerRows || headerRows.length < 2) return;
    const titleRow = headerRows[1];
    const ths = titleRow.querySelectorAll('th');
    ths.forEach((th, idx) => {
      // Skip if already added
      if (th.querySelector('input.colColorDot')) return;
      // Create input
      const picker = document.createElement('input');
      picker.type = 'color';
      picker.className = 'colColorDot';
      picker.title = 'Set title color';
      // default color (use current computed color or fallback)
      try {
        const comp = getComputedStyle(th).color;
        // Convert rgb(...) to hex
        const rgb = comp.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
        if (rgb) {
          const toHex = (n)=> ('0' + parseInt(n,10).toString(16)).slice(-2);
          picker.value = '#' + toHex(rgb[1]) + toHex(rgb[2]) + toHex(rgb[3]);
        } else {
          picker.value = '#102027';
        }
      } catch(e){ picker.value = '#102027'; }

      // Insert before the text (left side)
      th.insertBefore(picker, th.firstChild);

      // Listener to apply & persist
      picker.addEventListener('input', () => {
        th.style.color = picker.value;
        try {
          if (!window.owners) return;
          const owner = window.owners[window.currentOwner];
          if (!owner) return;
          if (!owner.colColors) owner.colColors = {};
          owner.colColors[idx] = picker.value;
          if (typeof window.saveState === 'function') window.saveState();
        } catch(e){ console.warn('col title save failed', e); }
      });
    });
  }

  // Apply saved colors for current owner/year and sync picker values
  function applySavedColumnColors(){
    try {
      const owner = window.owners && window.owners[window.currentOwner];
      if (!owner) return;
      const headerRows = document.querySelectorAll('table thead tr');
      if (!headerRows || headerRows.length < 2) return;
      const titleRow = headerRows[1];
      const ths = titleRow.querySelectorAll('th');
      const colors = owner.colColors || {};
      ths.forEach((th, idx) => {
        const c = colors[idx];
        if (c) th.style.color = c;
        const picker = th.querySelector('input.colColorDot');
        if (picker && c) picker.value = c;
      });
    } catch(e){ console.warn('apply col colors failed', e); }
  }

  // Hook into owner switching and on first load
  function hookOwnerSwitch(){
    const sel = document.getElementById('ownerSelect');
    if (sel && !sel.__colHooked){
      sel.addEventListener('change', () => {
        // tiny delay to allow external updateCurrentOwnerData/render to finish
        setTimeout(() => { ensureHeaderPickers(); applySavedColumnColors(); }, 0);
      });
      sel.__colHooked = true;
    }
  }

  // Run after DOM ready
  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(() => {
    ensureHeaderPickers();
    applySavedColumnColors();
    hookOwnerSwitch();
  });

  // Expose for other code paths (e.g., after table re-render)
  window.applySavedColumnHeaderColors = applySavedColumnColors;
  window.ensureHeaderPickers = ensureHeaderPickers;
})();
</script>
<script>
// === Highlight "Target" cell for next-needed month (red border/background) ===
(function(){
  function highlightNextTargetCell(){
    try {
      const next = (typeof findNextNeededMonth === 'function') ? findNextNeededMonth() : null;
      const tbody = document.getElementById('tableBody');
      if (!tbody) return;

      // Clear previous flags
      tbody.querySelectorAll('td.next-needed-target').forEach(td => {
        td.classList.remove('next-needed-target');
      });

      if (!next || next.index === undefined || next.index === null) return;
      const row = tbody.querySelector(`tr[data-month="${next.index}"]`);
      if (!row) return;

      // Target is the 6th cell: #, Key Dates, Days to Next, Project, Notes, Target, ...
      const targetCell = row.querySelector('td:nth-child(6)');
      if (!targetCell) return;

      targetCell.classList.add('next-needed-target');
      // keep content as-is (do not overwrite), just add the flag class
      // ensure cell remains editable if unlocked
      if (typeof window.monthlyEditingEnabled !== 'undefined' && window.monthlyEditingEnabled) {
        targetCell.classList.add('editable');
      }
      targetCell.setAttribute('data-field','target');
      targetCell.setAttribute('data-month', String(next.index));
      targetCell.style.cursor = 'text';
    } catch(e){
      console.warn('highlightNextTargetCell error:', e);
    }
  }

  // Observe table re-renders and re-apply flag
  function setupObserver(){
    const tbody = document.getElementById('tableBody');
    if (!tbody || tbody.__nextNeededObserved) return;
    const obs = new MutationObserver(() => {
      clearTimeout(tbody.__nextNeededTimer);
      tbody.__nextNeededTimer = setTimeout(highlightNextTargetCell, 0);
    });
    obs.observe(tbody, { childList: true, subtree: true });
    tbody.__nextNeededObserved = true;
  }

  function hookOwnerAndYear(){
    const sel = document.getElementById('ownerSelect');
    if (sel && !sel.__nextNeededHooked){
      sel.addEventListener('change', () => setTimeout(highlightNextTargetCell, 0));
      sel.__nextNeededHooked = true;
    }
    const y = document.getElementById('yearInput');
    if (y && !y.__nextNeededHooked){
      y.addEventListener('change', () => setTimeout(highlightNextTargetCell, 0));
      y.__nextNeededHooked = true;
    }
    ['btnToggleFuture','btnToggleAll','monthlyLockToggle'].forEach(id => {
      const el = document.getElementById(id);
      if (el && !el.__nextNeededHooked){
        el.addEventListener('click', () => setTimeout(highlightNextTargetCell, 0));
        el.__nextNeededHooked = true;
      }
    });
    document.addEventListener('input', (e) => {
      // react to edits in target/expected/bank inflow fields
      if (e.target && e.target.closest && e.target.closest('#tableBody')) {
        setTimeout(highlightNextTargetCell, 0);
      }
    });
  }

  function ready(fn){ if (document.readyState !== 'loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(() => {
    setupObserver();
    hookOwnerAndYear();
    setTimeout(highlightNextTargetCell, 0);
  });

  // Expose for manual trigger if needed
  window.highlightNextTargetCell = highlightNextTargetCell;
})();

// === Sync Next Needed header badge with main alert ===
(function(){
  const badge = document.getElementById('nextNeededBadge');
  const m = document.getElementById('nextBadgeMonth');
  const a = document.getElementById('nextBadgeAmount');
  const d = document.getElementById('nextBadgeDays');
  const container = document.getElementById('nextContainer');
  const pill = document.getElementById('nextMonthPill');
  const txt = document.getElementById('nextText');
  const days = document.getElementById('nextDays');

  if (!badge || !container || !pill || !txt || !days) return;

  function sync(){
    const isVisible = container.style.display !== 'none';
    if (!isVisible){
      badge.style.display = 'none';
      return;
    }
    // Extract month label from pill, amount from txt, days from days
    const monthLabel = pill.textContent.trim();
    const amountText = txt.textContent.trim();
    const daysText = days.textContent.trim();
    m.textContent = monthLabel || '—';
    a.textContent = amountText || '—';
    d.textContent = daysText ? (`(${daysText})`) : '—';
    badge.style.display = 'inline-flex';
  }

  // Observe changes in the nextContainer subtree
  const mo = new MutationObserver(sync);
  mo.observe(container, { subtree:true, childList:true, characterData:true, attributes:true });

  // Also run on startup and whenever window gains focus (in case of async UI updates)
  window.addEventListener('focus', sync);
  document.addEventListener('DOMContentLoaded', sync);
  setTimeout(sync, 300); // initial debounce
})();

</script>
<script>
(function(){
  var badge = document.getElementById('nextNeededBadge');
  if(!badge) return;
  function forceShow(){
    if(badge.style.display === 'none' || getComputedStyle(badge).display === 'none'){
      badge.style.display = 'inline-flex';
    }
    // If empty, show placeholders
    var m = document.getElementById('nextBadgeMonth');
    var a = document.getElementById('nextBadgeAmount');
    var d = document.getElementById('nextBadgeDays');
    if(m && !m.textContent.trim()) m.textContent = '—';
    if(a && !a.textContent.trim()) a.textContent = '—';
    if(d && !d.textContent.trim()) d.textContent = '—';
  }
  // Initial
  forceShow();
  // Keep it shown if any script tries to hide it later
  var mo = new MutationObserver(forceShow);
  mo.observe(badge, {attributes:true, attributeFilter:['style','class']});
  // Also re-assert after render cycles
  setInterval(forceShow, 1500);
})();
</script>
<script>

// === Tiny line above Monthly Performance: dynamic "Next Year <Mon> Target (YYYY+1)" ===
(function(){
  function monthName(i){return ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][i]}

  function readStore(year){
    try{
      var key = (typeof getStorageKey==='function') ? getStorageKey(year) : ('performanceTracker:'+year);
      var raw = localStorage.getItem(key);
      if(!raw) return null;
      var obj = JSON.parse(raw);
      return obj || null;
    }catch(e){ console.warn('readStore error', e); return null; }
  }

  function findFirstTargetMonth(store, ownerId){
    try{
      if(!store) return {idx:null, amount:null};
      // support both shapes:
      // 1) { owners: { owner1: { monthlyTargets:[...] } } }
      // 2) { monthlyTargets: [...] , ... } (single owner)
      var node = null;
      if (store.owners && store.owners[ownerId]) node = store.owners[ownerId];
      else node = store;
      var arr = node && (node.monthlyTargets || node.targets || node.monthTargets);
      if(!arr || !arr.length) return {idx:null, amount:null};
      for (var i=0;i<arr.length;i++){
        var v = parseFloat(arr[i] || 0);
        if (isFinite(v) && v>0) return {idx:i, amount:v};
      }
      return {idx:null, amount:null};
    }catch(e){ console.warn('findFirstTargetMonth error', e); return {idx:null, amount:null}; }
  }

  function updateNextYearLine(){
    try{
      var yEl = document.getElementById('yearInput');
      var y = parseInt((yEl && yEl.value) || (window.currentYear || (new Date()).getFullYear()), 10);
      if(!isFinite(y)) y = (new Date()).getFullYear();
      var nextY = y + 1;
      var line = document.getElementById('nextJanTiny');
      if(!line) return;

      // try next-year store
      var ownerSel = document.getElementById('ownerSelect');
      var ownerId = ownerSel ? ownerSel.value : (window.currentOwner || 'owner1');
      var storeNext = readStore(nextY);
      var info = findFirstTargetMonth(storeNext, ownerId);

      if (info.idx!=null){
        var amt = (info.amount!=null && isFinite(info.amount)) ? Number(info.amount).toLocaleString() + ' AED' : '—';
        // line.innerHTML = '- Next Year Target :- The month of <span class="ny-month">' + monthName(info.idx) + '</span> | The amount of <span class="ny-amount">' + amt + '</span>';
        // line.style.display = '';
        line.textContent = '';
        line.style.display = 'none';
      } else {
        // no next-year entries → hide the line
        line.textContent = '';
        line.style.display = 'none';
      }

      // enforce gold/yellow style subtly
      line.style.color = '#e3b04b';
      line.style.fontWeight = '600';
      line.style.opacity = '0.95';
    }catch(e){ console.warn('next-year line update error', e); }
  }

  // Run on load and on relevant changes
  document.addEventListener('DOMContentLoaded', updateNextYearLine);
  ['input','change'].forEach(function(evt){
    var yEl = document.getElementById('yearInput');
    if (yEl) yEl.addEventListener(evt, updateNextYearLine);
    var ownerSel = document.getElementById('ownerSelect');
    if (ownerSel) ownerSel.addEventListener(evt, updateNextYearLine);
  });

  // Re-evaluate after any save cycle (storage may change)
  setInterval(updateNextYearLine, 1500);
})();

// === Mirror a second Edit toggle above the table columns ===
(function(){
  function syncLockButtons(){
    try{
      var mainBtn = document.getElementById('monthlyLockToggle');
      var mirrorBtn = document.getElementById('monthlyLockToggle2');
      if (!mainBtn || !mirrorBtn) return;
      mirrorBtn.textContent = mainBtn.textContent;
      // mirror title too for consistency
      mirrorBtn.title = mainBtn.title || mirrorBtn.title;
      mirrorBtn.setAttribute('aria-label', mainBtn.getAttribute('aria-label') || mirrorBtn.getAttribute('aria-label'));
    }catch(e){ console.warn('sync lock buttons err', e); }
  }
  function wireMirror(){
    var mainBtn = document.getElementById('monthlyLockToggle');
    var mirrorBtn = document.getElementById('monthlyLockToggle2');
    if (!mainBtn || !mirrorBtn) return;
    // clicking the mirror delegates to the main button so it reuses the existing logic
    mirrorBtn.addEventListener('click', function(){ mainBtn.click(); });
    // keep labels in sync whenever the main button is clicked
    mainBtn.addEventListener('click', function(){ setTimeout(syncLockButtons, 0); });
    // initial sync
    syncLockButtons();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wireMirror);
  } else {
    wireMirror();
  }
})();

// === General Notes: optional defensive resize to stay neat on first load ===
(function(){
  var gn = document.getElementById('generalNotes');
  if (!gn) return;
  try{
    gn.style.maxWidth = '100%';
  }catch(e){}
})();
</script>
<script>
(function(){
  function scrubDash(){
    var el = document.getElementById('dashNextText');
    if(!el) return;
    if (/next\s*year/i.test(el.textContent)) {
      el.textContent = '';
      el.classList.remove('alert-green','shortage');
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', scrubDash);
  } else {
    scrubDash();
  }
  var target = document.getElementById('dashNextText');
  if (target && 'MutationObserver' in window) {
    var mo = new MutationObserver(scrubDash);
    mo.observe(target, { childList:true, subtree:true, characterData:true });
  }
})();
</script>
<div aria-hidden="true" id="reportArea">
<h2>ENBD Performance Report</h2>
<div class="meta" id="reportMeta"></div>
<h3>📊 Key Performance Indicators</h3>
<h3>Summary</h3>
<table id="reportSummary">
<tbody>
<tr><td>Owner</td><td id="repOwner" style="text-align:right">—</td></tr>
<tr><td>Year</td><td id="repYear" style="text-align:right">—</td></tr>
<tr><td>Yearly Target</td><td id="repTarget" style="text-align:right">0</td></tr>
<tr><td>YTD Actual Inflow</td><td id="repYTD" style="text-align:right">0</td></tr>
<tr><td>Remaining</td><td id="repRemaining" style="text-align:right">0</td></tr>
<tr><td>Next Needed</td><td id="repNext" style="text-align:right">—</td></tr>
<tr><td>Adjusted Target</td><td id="repAdjustedTarget" style="text-align:right">0</td></tr>
<tr><td>YTD Inflow</td><td id="repYTDInflow" style="text-align:right">0</td></tr>
<tr><td>Balance</td><td id="repBalance" style="text-align:right">0</td></tr>
<tr><td>Opening Balance</td><td id="repOpeningBalance" style="text-align:right">0</td></tr>
<tr><td>Avg. Mo. Target</td><td id="repAvgMonthlyTarget" style="text-align:right">0</td></tr>
<tr><td>Avg. Mo. Inflow</td><td id="repAvgMonthlyInflow" style="text-align:right">0</td></tr>
<tr><td>Mo. Variance</td><td id="repMonthlyVariance" style="text-align:right">0</td></tr>
<tr><td>Total Deviation</td><td id="repTotalDeviation" style="text-align:right">0</td></tr>
<tr><td>Forecasted Year-End</td><td id="repForecastedYearEnd" style="text-align:right">0</td></tr>
</tbody>
</table>
<h3 style="margin-top: 29mm;">Monthly Entries</h3>
<table id="reportTable">
<thead>
<tr>
<th>Month</th>
<th>Target</th>
<th>Expected</th>
<th>Actual</th>
<th>Variance</th>
<th>Balance</th>
<th>Project</th>
<th>Notes</th>
<th>Key Dates</th>
</tr>
</thead>
<tbody></tbody>
<tfoot>
<tr>
<td>Total</td>
<td id="repTotTarget">0</td>
<td></td>
<td id="repTotActual">0</td>
<td id="repTotVariance">0</td>
<td id="repTotAccum">0</td>
<td colspan="3"></td>
</tr>
</tfoot>
</table>
<h3 style="margin-top: 29mm;">General Notes</h3>
<div id="repGeneralNotes" style="white-space:pre-wrap; font-size: 29px; line-height:1.4; margin:12px 0;"></div>
<div style="height:6mm;"></div>
<div style="height:3mm;"></div>
<!-- KPI header placeholder: appears in the blank area between General Notes and Executive Summary -->
<div style="height:2mm;"></div>
<div style="margin:8px 0 8px 0; display:flex; justify-content:center;">
<div id="reportKPIHeader" style="width:60%; min-height:46px; border:1px solid #e0e0e0; border-radius:6px; display:flex; align-items:center; justify-content:center; background:#fff; font-weight:700; font-size: 16px; color:#111; box-shadow:0 1px 0 rgba(0,0,0,0.03); padding:8px 14px;">
    📊 Key Performance Indicators
  </div>
</div>
<div class="report-page" style="page-break-before: always; page-break-after: always; padding:10px 20px; margin:6px 0;">
<div id="repAIAnalysis" style="white-space:pre-wrap; line-height:1.4; background:#ffffff; padding:15px; border-radius:8px; border-left:3px solid #007bff; color:#111111; font-weight:300; letter-spacing:0.1px; margin:12px 0;">
EXECUTIVE SUMMARY
• Performance Level: CONCERNING
• Risk Level: EXTREME (CRITICAL EMERGENCY - IMMEDIATE INTERVENTION REQUIRED)
• Risk Score: 10.0/10
• Sustainability: Review required

CORE METRICS DASHBOARD
• Target Achievement: 25.3%
• Monthly Efficiency: 37.9%
• Momentum Rate: 0.34x
• Risk Score: 10.0/10 (EXTREME)
• Forecast Accuracу: -62.1%
<!-- Sustainability Index removed from static sample (use conservative wording above) -->

TIME-BASED ANALYSIS
• Time Elapsed: 249 days (68.2% of year)
• Time Remaining: 116 days (31.8% of year)
• Expected Progress: 81.9% (by day 249)
• Current vs Expected: 25.3% vs 81.9%
• GAP ANALYSIS: 56.6% behind schedule!
• REQUIRED DAILY: 235732 AED/day to catch up
• TIME PRESSURE: Only 116 days left - CRITICAL urgencу!
• YEAR-END RISK: EXTREME (10.0/10) - CRITICAL EMERGENCY - IMMEDIATE INTERVENTION REQUIRED

PERFORMANCE INSIGHTS
• CRITICAL SITUATION: Only 25.3% target achieved - immediate action needed!
• EFFICIENCY CONCERNS: Only 37.9% of target efficiency achieved.
• SLOWING MOMENTUM: Performance pace is concerning.
• EXTREME RISK (10.0/10): Critical situation with severe time deficit and performance issues!
• CRITICAL GAP: 56.6% behind expected progress
• FORECAST ALERT: Year-end projection deviates significantly from target.

STRATEGIC RECOMMENDATIONS
• IMMEDIATE FOCUS: Accelerate inflow in remaining months
• TARGET REVIEW: Assess and adjust monthly targets if needed
• EFFICIENCY BOOST: Identify and implement efficiency improvements
• PROCESS OPTIMIZATION: Review operational processes for bottlenecks
• RESOURCE ALLOCATION: Consider resource reallocation strategies
• TRAINING FOCUS: Evaluate training and skill development needs
- EMERGENCY INTERVENTION: Implement immediate recovery plan - 56.6% behind schedule!
- TIME-BASED RECOVERY: Focus on accelerated inflow for remaining 116 days
- CRITICAL TARGETS: Set aggressive daily targets to catch up

PREDICTIVE ANALYTICS
- Projected Year-End: 12.0%
- Confidence Level: LOW
- Risk Outlook: CRITICAL

BENCHMARKING &amp; COMPARISON
- Industry Standard: 85-95% target achievement
- Your Performance: BELOW industry standard
- Efficiency Benchmark: 90-110% of target
- Your Efficiency: BELOW benchmark

ACTION PRIORITY MATRIX
- URGENT: Target Achievement
- HIGH: Operational Efficiency
- CRITICAL: Emergency Recovery
- HIGH: Momentum Recovery
- FOCUS ON IMPROVEMENT: Several areas need attention
  </div>
</div>
</div>
<script>
(function(){
  function clean(n){ return Number(n||0) || 0; }
  function fmt(n){ return Number(n||0).toLocaleString('en-US', {maximumFractionDigits:0}); }
  function hasEntries(){
    try{
      // Consider there are entries if any target/expected/actual is >0 or any note/project/date exists
      for (var i=0;i<12;i++){
        if (clean(monthlyTargets[i])>0 || clean(expected[i])>0 || clean(actuals[i])>0) return true;
        if ((notes[i]||'').trim() !== '' || (projects[i]||'').trim() !== '') return true;
        if (Array.isArray(keyDates[i]) && keyDates[i].length) return true;
      }
    }catch(e){}
    return false;
  }
  function calcVarianceRow(i){
    var tar = clean(monthlyTargets[i]);
    var act = clean(actuals[i]);
    return act - tar;
  }
  function calcAccumVariances(){
    var acc = 0, out = [];
    for (var i=0;i<12;i++){
      var v = calcVarianceRow(i);
      acc += v;
      out.push(acc);
    }
    return out;
  }
  function monthName(i){ return (months && months[i]) || ('M'+(i+1)); }

  function gatherNextNeeded(){
    // Use the header badges if available
    var m = document.getElementById('nextBadgeMonth');
    var a = document.getElementById('nextBadgeAmount');
    var d = document.getElementById('nextBadgeDays');
    var month = (m && m.textContent || '').trim();
    var amount = (a && a.textContent || '').trim();
    var days = (d && d.textContent || '').trim();
    if (month && amount) {
      return month + ' — ' + amount + (days ? (' ('+days+')') : '');
    }
    return '—';
  }

  function fillReport(){
    var ownerName = owners[currentOwner]?.name || currentOwner;
    var yearVal = elements.yearInput ? elements.yearInput.value : (''+currentYear);
    var target = elements.dashYearlyTarget ? elements.dashYearlyTarget.textContent : '0';
    var ytd = elements.dashYtdAccomplished ? elements.dashYtdAccomplished.textContent : '0';
    var remaining = elements.dashRemaining ? elements.dashRemaining.textContent : '0';

    // Get KPI values from dashboard
    var adjustedTarget = document.getElementById('kpiVal_target') ? document.getElementById('kpiVal_target').textContent : '0';
    var ytdInflow = document.getElementById('kpiVal_ytd') ? document.getElementById('kpiVal_ytd').textContent : '0';
    var balance = document.getElementById('kpiVal_rem') ? document.getElementById('kpiVal_rem').textContent : '0';
    var openingBalance = document.getElementById('kpiVal_ob') ? document.getElementById('kpiVal_ob').textContent : '0';
    var avgMonthlyTarget = document.getElementById('kpiVal_avgMonthly') ? document.getElementById('kpiVal_avgMonthly').textContent : '0';
    var avgMonthlyInflow = document.getElementById('kpiVal_avgActualMonthly') ? document.getElementById('kpiVal_avgActualMonthly').textContent : '0';
    var monthlyVariance = document.getElementById('kpiVal_monthlyVariance') ? document.getElementById('kpiVal_monthlyVariance').textContent : '0';
    var totalDeviation = document.getElementById('kpiVal_deviation') ? document.getElementById('kpiVal_deviation').textContent : '0';
    var forecastedYearEnd = document.getElementById('kpiVal_forecast') ? document.getElementById('kpiVal_forecast').textContent : '0';

    document.getElementById('repOwner').textContent = ownerName;
    document.getElementById('repYear').textContent = yearVal;
    document.getElementById('repTarget').textContent = target;
    document.getElementById('repYTD').textContent = ytd;
    document.getElementById('repRemaining').textContent = remaining;
    document.getElementById('repNext').textContent = gatherNextNeeded();

    // Add KPI values to report
    document.getElementById('repAdjustedTarget').textContent = adjustedTarget;
    document.getElementById('repYTDInflow').textContent = ytdInflow;
    document.getElementById('repBalance').textContent = balance;
    document.getElementById('repOpeningBalance').textContent = openingBalance;
    document.getElementById('repAvgMonthlyTarget').textContent = avgMonthlyTarget;
    document.getElementById('repAvgMonthlyInflow').textContent = avgMonthlyInflow;
    document.getElementById('repMonthlyVariance').textContent = monthlyVariance;
    document.getElementById('repTotalDeviation').textContent = totalDeviation;
    document.getElementById('repForecastedYearEnd').textContent = forecastedYearEnd;

    // Meta line
    var now = new Date();
    var meta = 'Generated ' + now.toLocaleString('en-GB') + ' • Owner: ' + ownerName + ' • Year: ' + yearVal;
    document.getElementById('reportMeta').textContent = meta;

    // Table rows
    var tbody = document.querySelector('#reportTable tbody');
    tbody.innerHTML = '';
    var accs = calcAccumVariances();
    var totTarget = 0, totActual = 0, totVar = 0, totAccLast = 0;

    for (var i=0;i<12;i++){
      var t = clean(monthlyTargets[i]);
      var e = clean(expected[i]);
      var a = clean(actuals[i]);
      var n = (notes[i]||'').trim();
      var p = (projects[i]||'').trim();
      var kd = (Array.isArray(keyDates[i]) ? keyDates[i].filter(Boolean).join(', ') : '');
      if (t>0 || e>0 || a>0 || n || p || kd){
        var tr = document.createElement('tr');
        tr.innerHTML = '<td style="text-align:left">'+monthName(i)+'</td>' +
                       '<td>'+fmt(t)+'</td>' +
                       '<td>'+fmt(e)+'</td>' +
                       '<td>'+fmt(a)+'</td>' +
                       '<td>'+fmt(calcVarianceRow(i))+'</td>' +
                       '<td>'+fmt(accs[i])+'</td>' +
                       '<td style="text-align:left">'+(p||'')+'</td>' +
                       '<td style="text-align:left">'+(n||'')+'</td>' +
                       '<td style="text-align:left">'+(kd||'')+'</td>';
        tbody.appendChild(tr);
        totTarget += t;
        totActual += a;
        totVar += calcVarianceRow(i);
        totAccLast = accs[i];
      }
    }
    document.getElementById('repTotTarget').textContent = fmt(totTarget);
    document.getElementById('repTotActual').textContent = fmt(totActual);
    document.getElementById('repTotVariance').textContent = fmt(totVar);
    document.getElementById('repTotAccum').textContent = fmt(totAccLast);

  // General notes
  var gn = elements.generalNotes ? elements.generalNotes.value : '';
  var repGen = document.getElementById('repGeneralNotes');
  repGen.textContent = gn || '—';
  // add a modest gap after general notes so the following analysis starts clearly (avoid huge fixed gaps)
  repGen.style.marginBottom = '1.2cm';

    // AI Analysis (ensure analysis appears on its own report page)
    var aiAnalysis = generateAIAnalysis();
    try{
      var repArea = document.getElementById('reportArea');
      var analysisWrap = document.getElementById('repAIAnalysisWrap');
      var aiEl = document.getElementById('repAIAnalysis');
      if (!analysisWrap){
        analysisWrap = document.createElement('div');
        analysisWrap.id = 'repAIAnalysisWrap';
        analysisWrap.className = 'report-page';
    analysisWrap.style.pageBreakBefore = 'always';
  // keep a small top margin so header shows separated but avoid pushing content far down
  analysisWrap.style.marginTop = '0.8cm';
        if (aiEl) aiEl.parentNode.insertBefore(analysisWrap, aiEl);
        if (aiEl) analysisWrap.appendChild(aiEl);
      }
      document.getElementById('repAIAnalysis').textContent = aiAnalysis;
    }catch(e){ document.getElementById('repAIAnalysis').textContent = aiAnalysis; }
  }

  function generateAIAnalysis(){
    try {
      // Extract KPI values
      var target = parseFloat(clean(document.getElementById('repTarget').textContent.replace(/,/g, ''))) || 0;
      var ytd = parseFloat(clean(document.getElementById('repYTD').textContent.replace(/,/g, ''))) || 0;
      var remaining = parseFloat(clean(document.getElementById('repRemaining').textContent.replace(/,/g, ''))) || 0;
      var adjustedTarget = parseFloat(clean(document.getElementById('repAdjustedTarget').textContent.replace(/,/g, ''))) || 0;
      var ytdInflow = parseFloat(clean(document.getElementById('repYTDInflow').textContent.replace(/,/g, ''))) || 0;
      var balance = parseFloat(clean(document.getElementById('repBalance').textContent.replace(/,/g, ''))) || 0;
      var openingBalance = parseFloat(clean(document.getElementById('repOpeningBalance').textContent.replace(/,/g, ''))) || 0;
      var avgMonthlyTarget = parseFloat(clean(document.getElementById('repAvgMonthlyTarget').textContent.replace(/,/g, ''))) || 0;
      var avgMonthlyInflow = parseFloat(clean(document.getElementById('repAvgMonthlyInflow').textContent.replace(/,/g, ''))) || 0;
      var monthlyVariance = parseFloat(clean(document.getElementById('repMonthlyVariance').textContent.replace(/,/g, ''))) || 0;
      var totalDeviation = parseFloat(clean(document.getElementById('repTotalDeviation').textContent.replace(/,/g, ''))) || 0;
      var forecastedYearEnd = parseFloat(clean(document.getElementById('repForecastedYearEnd').textContent.replace(/,/g, ''))) || 0;

      // Use adjusted target if available, else original target
      var primaryTarget = adjustedTarget > 0 ? adjustedTarget : target;

      // Advanced Calculations
      var completionRate = primaryTarget > 0 ? (ytd / primaryTarget) * 100 : 0;
      var efficiency = avgMonthlyTarget > 0 ? (avgMonthlyInflow / avgMonthlyTarget) * 100 : 0;
      var varianceImpact = totalDeviation !== 0 ? (totalDeviation / primaryTarget) * 100 : 0;
      var forecastAccuracy = primaryTarget > 0 ? ((forecastedYearEnd - primaryTarget) / primaryTarget) * 100 : 0;

      // Calculate year progress for momentum
      var now = new Date();
      var currentYear = now.getFullYear();
      var startOfYear = new Date(currentYear, 0, 1);
      var daysElapsed = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24)) + 1;
      var totalDaysInYear = (currentYear % 4 === 0 && (currentYear % 100 !== 0 || currentYear % 400 === 0)) ? 366 : 365;
      var yearProgress = daysElapsed / totalDaysInYear;
      var momentumRate = yearProgress > 0 ? (completionRate / (yearProgress * 100)) : 0;

      // Advanced Contextual Factors for Optimum Accuracy
      var historicalMaxDaily = 0;
      var seasonalStrength = 1.0; // 0.8-1.2 multiplier
      var trendStrength = 1.0; // based on trendSlope
      var dataCompleteness = 1.0; // 0.9-1.0 based on missing data

      // 1. Historical Max Daily Inflow (for feasibility)
      try {
        if (Array.isArray(actuals)) {
          for (var m = 0; m < 12; m++) {
            if (actuals[m] && actuals[m] > 0) {
              var monthlyDaily = actuals[m] / 30;
              if (monthlyDaily > historicalMaxDaily) historicalMaxDaily = monthlyDaily;
            }
          }
        }
      } catch(e) { historicalMaxDaily = avgMonthlyInflow / 30 || 0; }

      // 2. Seasonal Strength (current month performance vs historical)
      try {
        var currentMonth = now.getMonth();
        var seasonalAvg = 0, seasonalCount = 0;
        if (Array.isArray(actuals)) {
          for (var y = 0; y < 3; y++) { // last 3 years if available
            var idx = currentMonth - (y * 12);
            if (idx >= 0 && actuals[idx] && actuals[idx] > 0) {
              seasonalAvg += actuals[idx];
              seasonalCount++;
            }
          }
        }
        if (seasonalCount > 0) {
          seasonalAvg /= seasonalCount;
          var currentMonthly = actuals[currentMonth] || 0;
          seasonalStrength = 1.0;
          seasonalStrength = 1.0; // cap 0.7-1.3
        }
      } catch(e) { seasonalStrength = 1.0; }

      // 3. Trend Strength (exponential effect of trendSlope)
      if (Math.abs(trendSlope) > 0.05) {
        trendStrength = 1 + (trendSlope * 0.5); // +25% for +0.1 slope, -25% for -0.1
        trendStrength = Math.max(0.75, Math.min(1.25, trendStrength));
      }

      // 4. Data Completeness (penalize missing months)
      try {
        var totalMonths = 12;
        var filledMonths = 0;
        if (Array.isArray(actuals)) {
          for (var m = 0; m < 12; m++) {
            if (actuals[m] && actuals[m] > 0) filledMonths++;
          }
        }
        dataCompleteness = filledMonths / totalMonths;
        dataCompleteness = Math.max(0.8, dataCompleteness); // minimum 0.8
      } catch(e) { dataCompleteness = 0.9; }
      // Historical trend: compare recent 3-month avg to previous 3-month avg (if available)
      var trendSlope = 0; // positive => improving, negative => worsening
      try{
        var nowMonth = new Date().getMonth(); // 0-11
        function getActual(i){ return parseFloat(clean(actuals[i])) || 0; }
        var recent = [], prev = [];
        for (var t=1; t<=3; t++){
          var idx = nowMonth - t;
          if (idx >= 0) recent.push(getActual(idx));
          var pidx = nowMonth - t - 3;
          if (pidx >= 0) prev.push(getActual(pidx));
        }
        var recentAvg = recent.length ? recent.reduce((a,b)=>a+b,0)/recent.length : 0;
        var prevAvg = prev.length ? prev.reduce((a,b)=>a+b,0)/prev.length : 0;
        if (prevAvg > 0) trendSlope = (recentAvg - prevAvg) / prevAvg; else if (recentAvg > 0) trendSlope = 1; else trendSlope = 0;
      }catch(e){ trendSlope = 0; }
      var riskFactor = Math.abs(monthlyVariance) / (avgMonthlyTarget || 1);
      var sustainabilityIndex = balance >= 0 ? (balance / (target * 0.1)) * 100 : -100;

      // Performance Categories - will be defined after risk calculation for alignment

      // Trend Analysis
      var trendDirection = momentumRate > 1.2 ? "ACCELERATING" :
                          momentumRate > 0.8 ? "STEADY" :
                          momentumRate > 0.6 ? "SLOWING" : "DECLINING";

      // Enhanced Risk Assessment with Comprehensive Logic (0-10 scale)
      var now = new Date();
      var currentYear = now.getFullYear();
      var startOfYear = new Date(currentYear, 0, 1);
      var daysElapsed = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24)) + 1; // include current day
      var totalDaysInYear = (currentYear % 4 === 0 && (currentYear % 100 !== 0 || currentYear % 400 === 0)) ? 366 : 365;
      var daysRemaining = Math.max(0, totalDaysInYear - daysElapsed);
  var yearProgress = daysElapsed / totalDaysInYear; // fraction of year elapsed
  var expectedProgress = Math.min(1, yearProgress * 1.2); // expected progress with buffer

      // PRIMARY CHECK: consider balance and forecast — only zero risk when remaining need is covered
      var remainingNeeded = Math.max(0, (primaryTarget - ytd));
      var forecastCovers = forecastedYearEnd >= primaryTarget;
      var balanceCovers = balance >= remainingNeeded;
      var sufficientProgress = completionRate >= (expectedProgress * 100 * 0.9); // 90% of expected
      var sustainableMomentum = momentumRate >= 0.9;

      // Zero risk only when forecast guarantees the target OR balance covers remaining need AND progress/momentum look sustainable
      if (forecastCovers) {
        riskScore = 0;
        riskLevel = "NONE";
        var riskDescription = "NO RISK - FORECAST MEETS TARGET";
      } else if (balanceCovers && (sufficientProgress || sustainableMomentum)) {
        riskScore = 0.5; // Near zero risk when balance covers and progress/momentum is sufficient, but not zero to account for remaining time
        riskLevel = "MINIMAL";
        var riskDescription = "NEAR ZERO RISK - BALANCE COVERS REMAINING NEED AND PROGRESS IS SUSTAINABLE";
      } else {
        // Financial position
        var deficit = Math.max(0, -balance); // amount short
        var deficitPct = primaryTarget > 0 ? (deficit / primaryTarget) * 100 : 100;

        // 1) Financial Risk (0-3 points)
        var financialRisk = 0;
        if (deficitPct <= 5) financialRisk = 0.3;
        else if (deficitPct <= 15) financialRisk = 0.8;
        else if (deficitPct <= 30) financialRisk = 1.6;
        else if (deficitPct <= 50) financialRisk = 2.4;
        else financialRisk = 3.0;

        // 2) Time Pressure Risk (0-3 points) - increased for conservatism
        // fraction of year remaining (naming legacy: timePressure -> more time = higher)
        var timePressure = daysRemaining / (totalDaysInYear || 1);
        var timeRisk = 0;
        if (timePressure < 0.05) timeRisk = 3.0;
        else if (timePressure < 0.15) timeRisk = 2.5;
        else if (timePressure < 0.30) timeRisk = 1.5;
        else if (timePressure < 0.50) timeRisk = 1.0;
        else if (timePressure < 0.75) timeRisk = 0.5;
        else timeRisk = 0;

        // 3) Completion Risk (0-2.5 points) - increased for conservatism
        var completionRisk = 0;
        if (completionRate < 25) completionRisk = 2.5;
        else if (completionRate < 50) completionRisk = 1.8;
        else if (completionRate < 75) completionRisk = 1.2;
        else if (completionRate < 90) completionRisk = 0.8;
        else if (completionRate < 95) completionRisk = 0.3;
        else completionRisk = 0;

        // 4) Efficiency Risk (0-1.5 points)
        var efficiencyRisk = 0;
        if (efficiency < 50) efficiencyRisk = 1.5;
        else if (efficiency < 70) efficiencyRisk = 1.0;
        else if (efficiency < 90) efficiencyRisk = 0.6;
        else efficiencyRisk = 0;

        // 5) Momentum Risk (0-1 point)
        var momentumRisk = 0;
        if (momentumRate < 0.5) momentumRisk = 1.0;
        else if (momentumRate < 0.8) momentumRisk = 0.6;
        else if (momentumRate < 1.0) momentumRisk = 0.25;

        // 6) Variance Stability Risk (0-0.5)
        var avgVar = Math.abs(monthlyVariance || 0);
        var varianceRisk = 0;
        if (avgVar > (avgMonthlyTarget || 1) * 0.3) varianceRisk = 0.5;
        else if (avgVar > (avgMonthlyTarget || 1) * 0.2) varianceRisk = 0.3;
        else if (avgVar > (avgMonthlyTarget || 1) * 0.1) varianceRisk = 0.1;

        // 7) Forecast Accuracy Risk (0-0.5) — downside only
var forecastRisk = 0;
var downside = Math.max(0, -forecastAccuracy);
if (downside > 20) forecastRisk = 0.5;
else if (downside > 10) forecastRisk = 0.25;


        // 8) Data Consistency Risk (0-0.5) — consider only elapsed months
var zeroMonths = 0;
try{
  var monthsElapsed = new Date().getMonth() + 1; // 1..12
  if (Array.isArray(actuals)){
    for (var mi=0; mi<monthsElapsed; mi++){
      if (!actuals[mi] || actuals[mi] === 0) zeroMonths++;
    }
  }
}catch(e){ zeroMonths = 0; }

        var consistencyRisk = (zeroMonths > 6 ? 0.5 : zeroMonths > 3 ? 0.3 : 0) * (1 / dataCompleteness); // adjust for data completeness

        // 9) Catch-up Feasibility Risk (0-1 point) - based on historical max daily
        var feasibilityRisk = 0;
        if (historicalMaxDaily > 0 && requiredDaily > 0) {
          var feasibilityRatio = requiredDaily / historicalMaxDaily;
          if (feasibilityRatio > 2.0) feasibilityRisk = 1.0;
          else if (feasibilityRatio > 1.5) feasibilityRisk = 0.7;
          else if (feasibilityRatio > 1.2) feasibilityRisk = 0.4;
          else if (feasibilityRatio > 1.0) feasibilityRisk = 0.2;
        }

        // Aggregate base score (max ~11.5) - increased weighting for conservatism
        // Apply stronger weighting to financial, time, and completion components
        var weightedFinancial = financialRisk * 1.2;
        var weightedTime = timeRisk * 1.3;
        var weightedCompletion = completionRisk * 1.1;
        var baseScore = weightedFinancial + weightedTime + weightedCompletion + efficiencyRisk + momentumRisk + varianceRisk + forecastRisk + consistencyRisk + feasibilityRisk;

  // credit good momentum
if (typeof momentumRate !== "undefined" && momentumRate >= 1.1) { baseScore = Math.max(0, baseScore - 0.2); }
// Urgency multiplier: more conservative when more time remains, adjusted by contextual factors
  var timeFrac = daysRemaining / (totalDaysInYear || 1);
  var urgencyCap = timeFrac > 0.33 ? 0.35 : 1.0; // increased cap for low time remaining
  var urgencyMultiplier = 1 + (1 - Math.max(0.03, timePressure)) * urgencyCap;
  if (momentumRate < 0.7) urgencyMultiplier += 0.15; // penalty for collapsing momentum
  // Trend adjustment: reduce risk if recent trend is improving, increase if worsening
  if (trendSlope > 0.15) urgencyMultiplier *= 0.9; // improve reduces urgency
  else if (trendSlope < -0.15) urgencyMultiplier *= 1.15; // worsening increases urgency
  // Seasonal adjustment: if current month is weaker than seasonal average, increase urgency
  if (seasonalStrength < 0.9) urgencyMultiplier *= 1.1;
  // Trend strength adjustment
  urgencyMultiplier *= trendStrength;

        // Required daily catch-up (for the rest of the year)
        var requiredDaily = daysRemaining > 0 ? ((target - ytd) / daysRemaining) : Infinity;

        // Base raw score before final adjustments
        var rawScore = Math.min(10, baseScore * urgencyMultiplier);

  // Additional conservative adjustments for severe indicators
        var adjustment = 0;
        // If efficiency is very low, increase risk
        if (efficiency < 40) adjustment += 0.8;
        else if (efficiency < 60) adjustment += 0.4;

        // If forecast is very pessimistic (large negative error), increase risk
        if (forecastAccuracy < -30) adjustment += 0.8;
        else if (forecastAccuracy < -15) adjustment += 0.4;

        // Sustainability index negative or zero -> raise risk
        if (sustainabilityIndex <= 0) adjustment += 0.5;

        // If required daily is unrealistic relative to average monthly inflow, penalize
        if (avgMonthlyInflow > 0) {
          if (requiredDaily > avgMonthlyInflow * 0.5) adjustment += 0.8; // needs daily > half of avg monthly inflow -> risky
          else if (requiredDaily > avgMonthlyInflow * 0.25) adjustment += 0.4;
        } else if (requiredDaily === Infinity) {
          adjustment += 1.0;
        }

        // Data quality adjustment: if data is incomplete, slightly increase risk for uncertainty
        adjustment += (1 - dataCompleteness) * 0.3;

        // Hard overrides for very bad profiles (force higher risk when warranted)
        var minForcedRisk = 0;
        if (completionRate < 40 && yearProgress >= 0.6 && deficitPct > 20) {
          minForcedRisk = Math.max(minForcedRisk, 6.8);
        }
        if (deficitPct > 50 && (efficiency < 50 || forecastAccuracy < -25)) {
          minForcedRisk = Math.max(minForcedRisk, 8.0);
        }
        // Force high risk if near end of year and target not achieved
        if (yearProgress >= 0.95 && completionRate < 95) {
          minForcedRisk = Math.max(minForcedRisk, 9.5);
        }
        // Prevent forcing 10/10 when several months remain: cap forced minimum if time left is significant
        if (timeFrac > 0.33 && minForcedRisk > 8.0) minForcedRisk = 8.0;

        var preAdjustScore = Math.min(10, rawScore + adjustment);
        var finalScore = Math.max(preAdjustScore, minForcedRisk);

        riskScore = Math.max(0, Math.min(10, finalScore)); // final 0-10

        // Classification and human-friendly description
        var riskLevel, riskDescription;
        if (riskScore >= 9.0) { riskLevel = "EXTREME"; riskDescription = "CRITICAL EMERGENCY - IMMEDIATE INTERVENTION REQUIRED"; }
        else if (riskScore >= 8.0) { riskLevel = "VERY HIGH"; riskDescription = "SEVERE RISK - URGENT ACTION NEEDED"; }
        else if (riskScore >= 7.0) { riskLevel = "HIGH"; riskDescription = "MAJOR RISK - STRONG INTERVENTION REQUIRED"; }
        else if (riskScore >= 6.0) { riskLevel = "MODERATE HIGH"; riskDescription = "ELEVATED RISK - MONITOR CLOSELY"; }
        else if (riskScore >= 5.0) { riskLevel = "MODERATE"; riskDescription = "MODERATE RISK - ATTENTION NEEDED"; }
        else if (riskScore >= 4.0) { riskLevel = "LOW MODERATE"; riskDescription = "MANAGEABLE RISK - WATCH CAREFULLY"; }
        else if (riskScore >= 3.0) { riskLevel = "LOW"; riskDescription = "MINOR RISK - REQUIRES ATTENTION"; }
        else if (riskScore >= 2.0) { riskLevel = "VERY LOW"; riskDescription = "NEGLIGIBLE RISK - MINOR CONCERNS"; }
        else if (riskScore >= 1.0) { riskLevel = "MINIMAL"; riskDescription = "VERY LOW RISK - ON TRACK"; }
        else { riskLevel = "NONE"; riskDescription = "NO RISK - PERFECTLY ON TARGET"; }
      }

      // Performance Categories - aligned with risk levels for consistency
      var performanceLevel = (completionRate >= 90 && riskScore <= 2.0) ? "EXCEPTIONAL" :
                            (completionRate >= 75 && riskScore <= 4.0) ? "STRONG" :
                            (completionRate >= 50 && riskScore <= 6.0) ? "MODERATE" :
                            (completionRate >= 25 && riskScore <= 8.0) ? "CONCERNING" : "CRITICAL";

      // Build concise executive summary for quick understanding
      var actionRecommendation = "";
      if (riskScore <= 2) actionRecommendation = "Maintain momentum; no major changes needed.";
      else if (riskScore <= 4) actionRecommendation = "Monitor progress and make minor adjustments.";
      else if (riskScore <= 6) actionRecommendation = "Plan targeted improvements and efficiency gains.";
      else if (riskScore <= 8) actionRecommendation = "Escalate actions; reallocate resources strategically.";
      else actionRecommendation = "Urgent intervention required to meet targets.";
      var summary = "SUMMARY:\n" +
        "• Performance: " + performanceLevel + "\n" +
        "• Risk: " + riskLevel + " (" + riskScore.toFixed(1) + "/10)\n" +
        "• Completion: " + completionRate.toFixed(1) + "%\n" +
        "• Recommended Action: " + actionRecommendation + "\n";

      // Build comprehensive analysis
      var analysis = "";
      var DIVIDER = "═══════════════════════════════════════════════\n\n";

      // Executive Summary
      analysis += DIVIDER;
      analysis += "📊 EXECUTIVE SUMMARY\n";
      analysis += "• Performance Level: " + performanceLevel + "\n";
      analysis += "• Risk Level: " + riskLevel + " (" + riskDescription + ")\n";
      analysis += "• Risk Score: " + riskScore.toFixed(1) + "/10\n";
      // Conservative sustainability wording (user requested removal of precise index)
      analysis += "• Sustainability: Review required\n\n";

      // Core Metrics Dashboard
      analysis += DIVIDER;
      analysis += "📈 CORE METRICS DASHBOARD\n";
      analysis += "• Target Achievement: " + completionRate.toFixed(1) + "%\n";
      analysis += "• Monthly Efficiency: " + efficiency.toFixed(1) + "%\n";
      analysis += "• Momentum Rate: " + momentumRate.toFixed(2) + "x\n";
      analysis += "• Risk Score: " + riskScore.toFixed(1) + "/10 (" + riskLevel + ")\n";
      analysis += "• Forecast Accuracy: " + (forecastAccuracy >= 0 ? "+" : "") + forecastAccuracy.toFixed(1) + "%\n";
      var runRatePct = primaryTarget > 0 ? ((avgMonthlyInflow * 12) / primaryTarget) * 100 : 0;
      analysis += "• Run‑Rate to Target: " + runRatePct.toFixed(1) + "%\n";

      // TIME-BASED ANALYSIS - clearly separate from previous section
      analysis += DIVIDER;
      analysis += "⏰ TIME-BASED ANALYSIS\n";
      var timeElapsedPercent = (yearProgress * 100).toFixed(1);
      var timeRemainingPercent = ((1 - yearProgress) * 100).toFixed(1);
      var expectedByNow = (expectedProgress * 100).toFixed(1);
      var gapFromExpected = (expectedByNow - completionRate).toFixed(1);

      analysis += "• Time Elapsed: " + daysElapsed + " days (" + timeElapsedPercent + "% of year)\n";
      analysis += "• Time Remaining: " + (totalDaysInYear - daysElapsed) + " days (" + timeRemainingPercent + "% of year)\n";
      analysis += "• Expected Progress: " + expectedByNow + "% (by now)\n";
      analysis += "• Current vs Expected: " + completionRate.toFixed(1) + "% vs " + expectedByNow + "%\n";

      if (gapFromExpected > 0) {
        analysis += "• GAP ANALYSIS: " + gapFromExpected + "% behind schedule!\n";
        analysis += "• REQUIRED DAILY: " + ((primaryTarget - ytd) / (totalDaysInYear - daysElapsed)).toFixed(0) + " AED/day to catch up\n";
        analysis += "• TIME PRESSURE: Only " + (totalDaysInYear - daysElapsed) + " days left - " + (gapFromExpected > 20 ? "CRITICAL" : gapFromExpected > 10 ? "HIGH" : "MODERATE") + " urgency!\n";
      } else {
        analysis += "• ON TRACK: Ahead of schedule by " + Math.abs(gapFromExpected) + "%\n";
        analysis += "• MOMENTUM ADVANTAGE: " + (totalDaysInYear - daysElapsed) + " days to build on current progress\n";
      }

      analysis += "• YEAR-END RISK: " + riskLevel + " (" + riskScore.toFixed(1) + "/10) - " + riskDescription + "\n\n";

      // AED-FOCUSED METRICS (requested): balance shortage/surplus, daily needed vs actual daily,
      // future risk 1-3 months (AED), remaining to target (AED), year-end forecast gap (AED)
      try {
        var primaryTarget = adjustedTarget > 0 ? adjustedTarget : target;
        var remainingAED = Math.max(0, primaryTarget - ytd);
        // daily figures (approximate) - use 30-day month for avg daily inflow
        var avgDailyInflow = avgMonthlyInflow / 30 || 0;
        var requiredDaily = daysRemaining > 0 ? (remainingAED / daysRemaining) : Infinity;
        // Future risk projection if inflows stay constant (1,2,3 months)
        var fr = [];
        for (var m = 1; m <= 3; m++){
          var covered = avgMonthlyInflow * m;
          var short = Math.max(0, remainingAED - covered);
          fr.push(short);
        }
        // Year-end forecast gap (missing AED if forecastedYearEnd < primaryTarget)
        var yearEndGap = Math.max(0, primaryTarget - forecastedYearEnd);
        var yearEndGapPct = primaryTarget > 0 ? (yearEndGap / primaryTarget) * 100 : 0;

        analysis += DIVIDER;
        analysis += "💰 AED METRICS\n";
        analysis += "• Future Risk (if pace continues): 1M: AED " + fmt(fr[0]||0) + ", 2M: AED " + fmt(fr[1]||0) + ", 3M: AED " + fmt(fr[2]||0) + "\n";
  // analysis += "• Balance: " + (balance >= 0 ? "Surplus of AED " + (typeof fmtAED === 'function' ? fmtAED(balance) : Math.round(balance)) : "Shortage of AED " + (typeof fmtAED === 'function' ? fmtAED(Math.abs(balance)) : Math.round(Math.abs(balance)))) + "\n";
        analysis += "• Remaining to Target: AED " + (typeof fmtAED === 'function' ? fmtAED(remainingAED) : Math.round(remainingAED)) + " (using " + (adjustedTarget > 0 ? "Adjusted Target" : "Target") + ")\n";
        analysis += "• Daily Needed vs Actual Daily: Required = " + (isFinite(requiredDaily) ? ("AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(requiredDaily)) : Math.round(requiredDaily))) : "N/A") + "; Avg daily inflow = AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(avgDailyInflow)) : Math.round(avgDailyInflow)) + "\n";
        analysis += "• Future Risk (if inflows unchanged): 1m short = AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(fr[0])) : Math.round(fr[0])) + ", 2m short = AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(fr[1])) : Math.round(fr[1])) + ", 3m short = AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(fr[2])) : Math.round(fr[2])) + "\n";
        analysis += "• Year-End Forecast Gap: AED " + (typeof fmtAED === 'function' ? fmtAED(Math.round(yearEndGap)) : Math.round(yearEndGap)) + " (" + (yearEndGapPct >= 0 ? "+" : "") + yearEndGapPct.toFixed(1) + "% of target)\n\n";
      } catch(e) { /* silently omit AED block on error */ }

      // Performance Insights
      analysis += DIVIDER;
      analysis += "🔍 PERFORMANCE INSIGHTS\n";

      // Completion Rate Analysis
      if (completionRate >= 90) {
        analysis += "• EXCEPTIONAL ACHIEVEMENT: Target completion rate of " + completionRate.toFixed(1) + "% exceeds expectations!\n";
      } else if (completionRate >= 75) {
        analysis += "• STRONG PERFORMANCE: " + completionRate.toFixed(1) + "% completion shows solid progress.\n";
      } else if (completionRate >= 50) {
        analysis += "• MODERATE PROGRESS: " + completionRate.toFixed(1) + "% completion requires attention.\n";
      } else {
        analysis += "• CRITICAL SITUATION: Only " + completionRate.toFixed(1) + "% target achieved - immediate action needed!\n";
      }

      // Efficiency Analysis
      if (efficiency >= 110) {
        analysis += "• EXCEPTIONAL EFFICIENCY: " + (efficiency - 100).toFixed(1) + "% above target efficiency!\n";
      } else if (efficiency >= 90) {
        analysis += "• GOOD EFFICIENCY: Performing at " + efficiency.toFixed(1) + "% of target efficiency.\n";
      } else {
        analysis += "• EFFICIENCY CONCERNS: Only " + efficiency.toFixed(1) + "% of target efficiency achieved.\n";
      }

      // Momentum Analysis
      if (momentumRate > 1.2) {
        analysis += "• ACCELERATING MOMENTUM: Performance is " + (momentumRate - 1).toFixed(1) + "x faster than expected!\n";
      } else if (momentumRate < 0.8) {
        analysis += "• SLOWING MOMENTUM: Performance pace is concerning.\n";
      }

      // Risk Analysis
      if (riskLevel === "EXTREME") {
        analysis += "• EXTREME RISK (" + riskScore.toFixed(1) + "/10): Critical situation with severe time deficit and performance issues!\n";
        analysis += "• CRITICAL GAP: " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind expected progress\n";
      } else if (riskLevel === "VERY HIGH") {
        analysis += "• VERY HIGH RISK (" + riskScore.toFixed(1) + "/10): Significantly behind schedule with major performance concerns!\n";
        analysis += "• CRITICAL GAP: " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind expected progress\n";
      } else if (riskLevel === "HIGH") {
        analysis += "• HIGH RISK (" + riskScore.toFixed(1) + "/10): Significant monthly variance indicates operational instability.\n";
        analysis += "• MODERATE GAP: " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind expected progress\n";
      } else if (riskLevel === "MODERATE") {
        analysis += "• MODERATE RISK (" + riskScore.toFixed(1) + "/10): Moderate variance requires monitoring.\n";
        analysis += "• SMALL GAP: " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind expected progress\n";
      } else if (riskLevel === "LOW") {
        analysis += "• LOW RISK (" + riskScore.toFixed(1) + "/10): Some variance requires attention.\n";
      } else {
        analysis += "• NEGLIGIBLE RISK (" + riskScore.toFixed(1) + "/10): Performance is on track!\n";
      }

      // Forecast Analysis
      if (Math.abs(forecastAccuracy) > 15) {
        analysis += "• FORECAST ALERT: Year-end projection deviates significantly from target.\n";
      }

      analysis += "\n";

  // Strategic Recommendations
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "🎯 STRATEGIC RECOMMENDATIONS\n";

      if (completionRate < 80) {
        analysis += "• IMMEDIATE FOCUS: Accelerate inflow in remaining months\n";
        analysis += "• TARGET REVIEW: Assess and adjust monthly targets if needed\n";
        analysis += "• EFFICIENCY BOOST: Identify and implement efficiency improvements\n";
      }

      if (efficiency < 90) {
        analysis += "• PROCESS OPTIMIZATION: Review operational processes for bottlenecks\n";
        analysis += "• RESOURCE ALLOCATION: Consider resource reallocation strategies\n";
        analysis += "• TRAINING FOCUS: Evaluate training and skill development needs\n";
      }

      if (riskLevel === "EXTREME") {
        analysis += "- EMERGENCY INTERVENTION: Implement immediate recovery plan - " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind schedule!\n";
        analysis += "- TIME-BASED RECOVERY: Focus on accelerated inflow for remaining " + (totalDaysInYear - daysElapsed) + " days\n";
        analysis += "- CRITICAL TARGETS: Set aggressive daily targets to catch up\n";
      }
      if (riskLevel === "VERY HIGH") {
        analysis += "- EMERGENCY INTERVENTION: Implement immediate recovery plan - " + (expectedProgress * 100 - completionRate).toFixed(1) + "% behind schedule!\n";
        analysis += "- TIME-BASED RECOVERY: Focus on accelerated inflow for remaining " + (totalDaysInYear - daysElapsed) + " days\n";
        analysis += "- CRITICAL TARGETS: Set aggressive daily targets to catch up\n";
      }
      if (riskLevel === "HIGH") {
        analysis += "- VARIANCE ANALYSIS: Investigate causes of high monthly fluctuations\n";
        analysis += "- RISK MITIGATION: Implement stabilization measures\n";
        analysis += "- MONITORING: Establish enhanced performance monitoring\n";
      }
      if (riskLevel === "MODERATE") {
        analysis += "- TREND ANALYSIS: Monitor progress closely and identify improvement opportunities\n";
        analysis += "- PREVENTIVE MEASURES: Implement measures to prevent further slippage\n";
      }
      if (riskLevel === "LOW") {
        analysis += "- PERFORMANCE REVIEW: Regular monitoring and adjustment of strategies\n";
        analysis += "- EFFICIENCY FOCUS: Optimize processes for better results\n";
      }

      if (balance < 0) {
        analysis += "- CASH FLOW MANAGEMENT: Address negative balance immediately\n";
        analysis += "- DEFICIT REDUCTION: Develop deficit reduction strategy\n";
        analysis += "- CONTINGENCY PLANNING: Prepare contingency measures\n";
      }

      analysis += "\n";

  // PREDICTIVE ANALYTICS
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "🔮 PREDICTIVE ANALYTICS\n";

      // Enhanced Projected Year-End Calculation
      var timeWeight = Math.max(0.1, Math.min(1.0, timeRemainingPercent / 100)); // Weight for time remaining
      var momentumWeight = Math.max(0.5, Math.min(2.0, momentumRate)); // Momentum factor
      var riskAdjustment = Math.max(-20, Math.min(20, (5 - riskScore) * 2)); // Risk-based adjustment

      // Consider historical consistency and seasonal factors
      var historicalConsistency = Math.abs(momentumRate - 1.0) < 0.3 ? 1.2 : Math.abs(momentumRate - 1.0) < 0.6 ? 1.0 : 0.8;
      var seasonalFactor = yearProgress > 0.75 ? 0.9 : yearProgress > 0.5 ? 1.0 : 1.1; // Q4 slowdown, Q1/Q2 boost

      var projectedCompletion = completionRate +
                               (momentumWeight - 1) * timeWeight * 25 +
                               riskAdjustment +
                               (historicalConsistency - 1) * 5 +
                               (seasonalFactor - 1) * 10;

      projectedCompletion = Math.min(120, Math.max(0, projectedCompletion)); // Cap at 120% for extreme cases

      analysis += "- Projected Year-End: " + projectedCompletion.toFixed(1) + "%\n";

      // Enhanced Confidence Level Calculation
      var confidenceFactors = {
        timePressure: timeRemainingPercent < 25 ? 0.7 : timeRemainingPercent < 50 ? 0.9 : 1.0,
        momentumStability: Math.abs(momentumRate - 1.0) < 0.2 ? 1.0 : Math.abs(momentumRate - 1.0) < 0.5 ? 0.8 : 0.6,
        riskLevel: riskScore < 3 ? 1.0 : riskScore < 6 ? 0.8 : riskScore < 8 ? 0.6 : 0.4,
        dataCompleteness: yearProgress > 0.1 ? 1.0 : 0.7, // Penalize very early data
        gapSeverity: Math.abs(gapFromExpected) < 5 ? 1.0 : Math.abs(gapFromExpected) < 15 ? 0.8 : 0.6
      };

      var confidenceScore = (confidenceFactors.timePressure * 0.2 +
                           confidenceFactors.momentumStability * 0.25 +
                           confidenceFactors.riskLevel * 0.2 +
                           confidenceFactors.dataCompleteness * 0.15 +
                           confidenceFactors.gapSeverity * 0.2) * 100;

      var confidenceLevel;
      if (confidenceScore >= 85) confidenceLevel = "VERY HIGH";
      else if (confidenceScore >= 70) confidenceLevel = "HIGH";
      else if (confidenceScore >= 55) confidenceLevel = "MEDIUM";
      else if (confidenceScore >= 40) confidenceLevel = "LOW";
      else confidenceLevel = "VERY LOW";

      analysis += "- Confidence Level: " + confidenceLevel + " (" + confidenceScore.toFixed(0) + "%)\n";

      // Enhanced Risk Outlook with time-based considerations
      var riskOutlook;
      var timeUrgency = timeRemainingPercent < 25 ? "CRITICAL" :
                       timeRemainingPercent < 50 ? "HIGH" : "MODERATE";

      if (riskLevel === "EXTREME" || (riskLevel === "VERY HIGH" && timeUrgency === "CRITICAL")) {
        riskOutlook = "CRITICAL - IMMEDIATE ACTION REQUIRED";
      } else if (riskLevel === "VERY HIGH" || (riskLevel === "HIGH" && timeUrgency === "CRITICAL")) {
        riskOutlook = "CRITICAL - TIME-SENSITIVE RECOVERY NEEDED";
      } else if (riskLevel === "HIGH" || (riskLevel === "MODERATE" && timeUrgency === "CRITICAL")) {
        riskOutlook = "UNCERTAIN - CLOSE MONITORING REQUIRED";
      } else if (riskLevel === "MODERATE") {
        riskOutlook = "MODERATE - WATCH FOR CHANGES";
      } else if (riskLevel === "LOW") {
        riskOutlook = "LOW - STABLE WITH OPPORTUNITIES";
      } else {
        riskOutlook = "STABLE - MAINTAIN CURRENT TRAJECTORY";
      }

      analysis += "- Risk Outlook: " + riskOutlook + "\n\n";

  // Benchmarking & Comparison
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "📊 BENCHMARKING & COMPARISON\n";
      analysis += "- Industry Standard: 85-95% target achievement\n";
      analysis += "- Your Performance: " + (completionRate >= 85 ? "ABOVE" : completionRate >= 75 ? "AT" : "BELOW") + " industry standard\n";
      analysis += "- Efficiency Benchmark: 90-110% of target\n";
      analysis += "- Your Efficiency: " + (efficiency >= 90 ? "MEETS" : "BELOW") + " benchmark\n\n";

  // Action Priority Matrix
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "⚡ ACTION PRIORITY MATRIX\n";
      var priorities = [];
      if (completionRate < 70) priorities.push("URGENT: Target Achievement");
      if (efficiency < 80) priorities.push("HIGH: Operational Efficiency");
      if (riskLevel === "EXTREME") priorities.push("CRITICAL: Emergency Recovery");
      if (riskLevel === "VERY HIGH") priorities.push("CRITICAL: Time-Based Recovery");
      if (riskLevel === "HIGH") priorities.push("HIGH: Risk Management");
      if (balance < 0) priorities.push("URGENT: Financial Position");
      if (momentumRate < 0.8) priorities.push("HIGH: Momentum Recovery");

      if (priorities.length > 0) {
        priorities.forEach(function(priority) {
          analysis += "- " + priority + "\n";
        });
      } else {
        analysis += "- MAINTAIN CURRENT STRATEGIES: Performance is strong\n";
      }

      analysis += "\n";

      // Success Metrics
      var successes = [];
      if (completionRate >= 75) successes.push("Target Achievement");
      if (efficiency >= 90) successes.push("Operational Efficiency");
      if (riskLevel === "LOW" || riskLevel === "NEGLIGIBLE") successes.push("Risk Management");
      if (momentumRate >= 1.0) successes.push("Growth Momentum");

      if (successes.length > 0) {
        successes.forEach(function(success) {
          analysis += "- " + success + "\n";
        });
    }

    // Move FOCUS ON IMPROVEMENT line to just before the double line
  analysis += "\n═══════════════════════════════════════════════\n";
  analysis += "- FOCUS ON IMPROVEMENT: Several areas need attention\n\n";

      // --- DIAGNOSTIC HELP: show why risk was set to ZERO (if it was) ---
      try {
        if (typeof riskScore !== 'undefined' && riskScore === 0) {
          analysis += "DIAGNOSTIC: ZERO-RISK TRACE\n";
          analysis += "• balance: " + balance + " | forecastedYearEnd: " + forecastedYearEnd + " | remainingNeeded: " + remainingNeeded + "\n";
          analysis += "• completionRate: " + completionRate.toFixed(1) + "% | yearProgress: " + (yearProgress*100).toFixed(1) + "% | momentumRate: " + momentumRate.toFixed(2) + "x\n";
          var zeroReason = (forecastCovers ? 'FORECAST_COVERS' : (balanceCovers && (sufficientProgress || sustainableMomentum) ? 'BALANCE_AND_SUSTAINABLE' : 'UNDEFINED'));
          analysis += "• zero-risk condition: " + zeroReason + "\n\n";
        }
      } catch(e) { /* silent */ }

  // (additional one-line insights removed to keep analysis compact)

  // ADVANCED ANALYTICS SECTION
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "🧠 ADVANCED ANALYTICS\n";

      // Seasonal Pattern Analysis
      analysis += "• SEASONAL PATTERNS: ";
      try {
        var seasonalAvg = [];
        for (var m = 0; m < 12; m++) {
          var monthVals = [];
          // Look for patterns across available data
          if (actuals[m] && actuals[m] > 0) monthVals.push(actuals[m]);
          if (m < actuals.length - 12 && actuals[m + 12] && actuals[m + 12] > 0) monthVals.push(actuals[m + 12]);
          seasonalAvg[m] = monthVals.length ? monthVals.reduce((a,b)=>a+b,0)/monthVals.length : 0;
        }
        var maxMonth = seasonalAvg.indexOf(Math.max(...seasonalAvg));
        var minMonth = seasonalAvg.indexOf(Math.min(...seasonalAvg.filter(x=>x>0)));
        if (maxMonth >= 0) analysis += "Strongest: " + months[maxMonth] + " | ";
        if (minMonth >= 0) analysis += "Weakest: " + months[minMonth] + "\n";
        else analysis += "Insufficient data for seasonal analysis\n";
      } catch(e) { analysis += "Data insufficient for seasonal analysis\n"; }

      // Performance Velocity
      var velocity = completionRate / (yearProgress * 100);
      analysis += "• PERFORMANCE VELOCITY: " + (velocity * 100).toFixed(1) + "% (";
      if (velocity > 1.1) analysis += "ACCELERATED";
      else if (velocity > 0.9) analysis += "ON TRACK";
      else if (velocity > 0.7) analysis += "SLOWING";
      else analysis += "CRITICAL";
      analysis += ")\n";

      // Risk-Adjusted Return
      var riskAdjustedReturn = completionRate / (riskScore + 1);
      analysis += "• RISK-ADJUSTED RETURN: " + riskAdjustedReturn.toFixed(1) + "%\n";

      // Predictive Confidence Intervals
      analysis += "• PREDICTIVE CONFIDENCE: ";
      var predictiveConfidence = confidenceScore; // Use the same confidence score from predictive analytics
      analysis += predictiveConfidence.toFixed(0) + "% (";

      var confidenceCategory;
      if (predictiveConfidence >= 85) confidenceCategory = "VERY HIGH";
      else if (predictiveConfidence >= 70) confidenceCategory = "HIGH";
      else if (predictiveConfidence >= 55) confidenceCategory = "MEDIUM";
      else if (predictiveConfidence >= 40) confidenceCategory = "LOW";
      else confidenceCategory = "VERY LOW";

      analysis += confidenceCategory + ")\n";

  // AI INSIGHTS & RECOMMENDATIONS
  analysis += "\n═══════════════════════════════════════════════\n\n";
  analysis += "🤖 AI INSIGHTS & RECOMMENDATIONS\n";

      // Scenario-based recommendations based on risk score
      if (riskScore <= 3) {
        analysis += "✅ Maintain Current Strategies:\n";
        analysis += "• Continue successful practices driving strong results\n";
        analysis += "• Scale proven methodologies across all units\n\n";
        analysis += "🚀 Leverage Surplus Capacity:\n";
        analysis += "• Explore growth opportunities beyond the current target\n";
        analysis += "• Allocate resources to new initiatives\n\n";
        analysis += "🔍 Monitor Lightly:\n";
        analysis += "• Routine checks to sustain momentum\n";
        analysis += "• Focus on fine-tuning efficiency rather than major change\n\n";
        analysis += "Tone: confident, expansion-oriented.\n";
      } else if (riskScore >= 4 && riskScore <= 6) {
        analysis += "✅ Maintain Core Strengths:\n";
        analysis += "• Protect inflow channels that are performing well\n\n";
        analysis += "⚠️ Adjust Key Weaknesses:\n";
        analysis += "• Improve efficiency (closing the 5–10% gap to benchmark)\n";
        analysis += "• Tighten controls on variance and fluctuations\n\n";
        analysis += "🔍 Proactive Monitoring:\n";
        analysis += "• Enhanced monthly review cycles\n";
        analysis += "• Early-warning triggers if variance exceeds set thresholds\n\n";
        analysis += "Tone: balanced — \"keep what works, but intervene where slippage is visible.\"\n";
      } else if (riskScore >= 7) {
        analysis += "⚠️ Urgent Stabilization:\n";
        analysis += "• Implement corrective action immediately to address forecast gaps\n";
        analysis += "• Prioritize resource reallocation to high-impact areas\n\n";
        analysis += "🚧 Structural Adjustments:\n";
        analysis += "• Review and possibly reset monthly targets\n";
        analysis += "• Conduct variance root-cause analysis and corrective process redesign\n\n";
        analysis += "🔍 Intensive Monitoring:\n";
        analysis += "• Weekly dashboards and leadership oversight\n";
        analysis += "• Risk mitigation protocols activated\n";
      }

      analysis += "\n═══════════════════════════════════════════════\n";
      analysis += "Generated: " + new Date().toLocaleString('en-GB') + "\n";
      analysis += "\n";

      // Prepend concise summary to the full analysis before cleanup
      try {
        analysis = summary + "\n\n" + analysis;
      } catch(e) { /* ignore if summary undefined */ }
      // Normalize repeated separators: collapse any repeated '═' divider blocks into a single block
      try {
        analysis = analysis.replace(/(\n═+\n\s*)+/g, '\n═══════════════════════════════════════════════\n\n');
        // Collapse long sequences of blank lines into a single blank line (two newlines)
        analysis = analysis.replace(/\n{3,}/g, '\n\n');
        // Trim trailing spaces/tabs at end of each line
        analysis = analysis.replace(/[ \t]+$/gm, '');
        // Remove extra blank lines between consecutive list items (bullets or dashes)
        analysis = analysis.replace(/(\n(?:[-•]\s*[^\n]+))\n\s*\n(?=(?:[-•]\s*[^\n]+))/g, '$1\n');
        // Ensure there's not more than one blank line between sections
        analysis = analysis.replace(/\n{2,}/g, '\n\n');
      } catch(e) { /* non-fatal */ }

      return analysis;
    } catch(e) {
      return "AI Analysis temporarily unavailable. Please check data inputs.\nError: " + e.message;
    }
  }

  async function exportPDF(){
    if (!hasEntries()){
      alert('No entries to report yet. Add some targets/actuals/notes first.');
      return;
    }
  fillReport();
  var area = document.getElementById('reportArea');
  // Add extra bottom padding to prevent last-page distortion
  // Add a temporary invisible spacer div to the bottom
  var spacer = document.createElement('div');
  spacer.style.height = '256px';
  spacer.style.visibility = 'hidden';
  area.appendChild(spacer);
  // Save current states so we can restore them later
  var prevBodyClass = document.body.className;
  var prevAreaDisplay = area.style.display;

  // Add overlay to mask any potential flicker
  const overlay = document.createElement('div');
  overlay.id = 'pdf-export-overlay';
  overlay.style.position = 'fixed';
  overlay.style.left = '0';
  overlay.style.top = '0';
  overlay.style.right = '0';
  overlay.style.bottom = '0';
  overlay.style.background = 'rgba(255,255,255,0.95)';
  overlay.style.zIndex = '2147483647';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.fontFamily = 'Poppins, system-ui, sans-serif';
  overlay.style.color = '#222';
  overlay.style.fontSize = '18px';
  overlay.textContent = 'Exporting PDF... Please wait.';
  document.body.appendChild(overlay);

  // Monkeypatch body.classList methods to ignore 'pdf-mode' while exporting
  const bodyClassList = document.body.classList;
  const origAdd = bodyClassList.add.bind(bodyClassList);
  const origToggle = bodyClassList.toggle.bind(bodyClassList);
  try {
    bodyClassList.add = function(...args){ if (args.includes('pdf-mode')) return; return origAdd(...args); };
    bodyClassList.toggle = function(token, force){ if (token === 'pdf-mode') return false; return origToggle(token, force); };
  } catch(e) { /* ignore if not allowed */ }

  // Force DOM reflow before rendering
  await new Promise(r => setTimeout(r, 100));
    // Enter PDF-safe mode for consistent layout
  document.body.classList.add('pdf-mode');
  area.style.display = 'block';
  // programmatically increase top spacing to ensure header moves down in exported PDF
  var prevAreaPadding = area.style.paddingTop;
  try { area.style.paddingTop = '40px'; } catch(e) { /* ignore */ }
    // Inject temporary PDF-mode styles to force lighter fonts and softer rules during capture
    (function(){
      const pdfStyleId = 'pdf-temp-style';
      if (!document.getElementById(pdfStyleId)){
        const styleEl = document.createElement('style');
        styleEl.id = pdfStyleId;
  styleEl.innerText = '\n.pdf-mode #repAIAnalysis, .pdf-mode .analysis { font-weight: 300 !important; font-size: 13px !important; line-height: 1.3 !important; }\n.pdf-mode #repAIAnalysis, .pdf-mode #repAIAnalysis * { font-family: "Poppins", sans-serif !important; }\n.pdf-mode #repAIAnalysis { padding: 12px !important; margin: 8px 0 !important; }\n.pdf-mode #repGeneralNotes { font-size: 13px !important; line-height: 1.3 !important; margin: 8px 0 !important; }\n.pdf-mode hr { border: 0 !important; height: 1px !important; background: rgba(0,0,0,0.06) !important; margin: 12px 0 !important; }\n.pdf-mode #repAIAnalysis hr { display: none !important; }\n.pdf-mode .report-page { padding: 20px !important; margin: 0 !important; }\n.pdf-mode #reportArea { padding-top: 40px !important; }\n.pdf-mode #reportArea h3:first-of-type { margin-top: 30px !important; font-size: 0.8em !important; }\n';
        document.head.appendChild(styleEl);
      }
    })();
    setTimeout(function(){ document.body.classList.add('pdf-mode'); }, 0);
  // Inline Poppins woff2 fonts (so PDF captures exact glyphs), then wait for fonts to register
  try {
    await inlinePoppinsFonts();
    if (document.fonts && document.fonts.ready) {
      await Promise.race([
        document.fonts.ready,
        new Promise(res => setTimeout(res, 1200))
      ]);
    }
  } catch(e){ /* ignore font timing errors */ }

    // Force inline header font-size to ensure PDF capture respects the reduction
    var hdr = area.querySelector('#reportArea h3') || area.querySelector('h3');
    var prevHdrFontSize = hdr ? hdr.style.fontSize : undefined;
    try { if (hdr) hdr.style.fontSize = '0.9em'; } catch(e){}

    try {
    // Render to canvas (higher scale for crisper text in PDF)
  const canvas = await html2canvas(area, {backgroundColor: '#ffffff', scale: 2.5});
    const imgData = canvas.toDataURL('image/png');

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation:'p', unit:'pt', format:'a4' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Fit width, scale height proportionally
    const leftPad = 20; // increased left/right margin
    const imgWidth = pageWidth - (leftPad * 2);
    const ratio = canvas.height / canvas.width;
    let imgHeight = imgWidth * ratio;

    // Top margin for the first image placement
    let y = 20;
    // If the content height fits on a single page (accounting for 60pt total vertical margins)
    if (imgHeight <= pageHeight - 60){
      pdf.addImage(imgData, 'PNG', leftPad, y, imgWidth, imgHeight);
    } else {
      // Multi-page slicing
      let sY = 0;
      // minimal overlap to avoid visible seams
      var sliceOverlapPx = 10;
      const chunkHeight = Math.floor(canvas.width * ((pageHeight - 60) / imgWidth)); // convert PDF height back to canvas px
      const effectiveChunk = Math.max(80, chunkHeight - sliceOverlapPx);
      var lastAddedPartHeight = 0;
      while (sY < canvas.height){
        const part = document.createElement('canvas');
        part.width = canvas.width;
        var remaining = canvas.height - sY;
        part.height = Math.min(effectiveChunk + sliceOverlapPx, remaining);
        const ctx = part.getContext('2d');
        ctx.drawImage(canvas, 0, sY, canvas.width, part.height, 0, 0, canvas.width, part.height);
        const partData = part.toDataURL('image/png');
        if (sY > 0) pdf.addPage();
        pdf.addImage(partData, 'PNG', leftPad, 20, imgWidth, (pageHeight - 60));
        lastAddedPartHeight = part.height;
        sY += effectiveChunk;
      }
      // Remove a trailing mostly empty page
      try {
        if (lastAddedPartHeight > 0 && lastAddedPartHeight <= (sliceOverlapPx + 4)) {
          var totalPages = pdf.getNumberOfPages ? pdf.getNumberOfPages() : (pdf.internal && pdf.internal.getNumberOfPages ? pdf.internal.getNumberOfPages() : null);
          if (totalPages) pdf.deletePage(totalPages);
        }
      } catch(e) { /* non-fatal */ }
    }
      pdf.save('ENBD_Performance_Report.pdf');
    } finally {
  // cleanup temporary PDF mode styles/classes and spacer; restore previous display/class
      try {
        const tmp = document.getElementById('pdf-temp-style');
        if (tmp) tmp.remove();
      } catch(e){}
      try { if (spacer && spacer.parentNode) spacer.parentNode.removeChild(spacer); } catch(e){}
      // restore area display and body class
      try { area.style.display = prevAreaDisplay; } catch(e){}
  try { if (typeof prevAreaPadding !== 'undefined') area.style.paddingTop = prevAreaPadding; } catch(e){}
  try { if (hdr && typeof prevHdrFontSize !== 'undefined') hdr.style.fontSize = prevHdrFontSize; } catch(e){}
      try { document.body.className = prevBodyClass; } catch(e){}
      // restore original classList methods
      try { bodyClassList.add = origAdd; bodyClassList.toggle = origToggle; } catch(e){}
      // remove overlay
      try { if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay); } catch(e){}
    }
  }

  function exportExcel(){
    if (!hasEntries()){
      alert('No entries to export yet.');
      return;
    }
    // Build rows
    const rows = [['Month','Target','Expected','Actual','Variance','Balance','Project','Notes','Key Dates']];
    const accs = (function(){
      var acc=0, arr=[];
      for (var i=0;i<12;i++){ acc += (clean(actuals[i]) - clean(monthlyTargets[i])); arr.push(acc); }
      return arr;
    })();
    for (var i=0;i<12;i++){
      const t = clean(monthlyTargets[i]);
      const e = clean(expected[i]);
      const a = clean(actuals[i]);
      const n = (notes[i]||'').trim();
      const p = (projects[i]||'').trim();
      const kd = (Array.isArray(keyDates[i]) ? keyDates[i].filter(Boolean).join(', ') : '');
      if (t>0 || e>0 || a>0 || n || p || kd){
        rows.push([
          monthName(i), t, e, a, (a - t), accs[i], p, n, kd
        ]);
      }
    }
    // Add a quick summary sheet too
    const summary = [
      ['Owner', owners[currentOwner]?.name || currentOwner],
      ['Year', elements.yearInput ? elements.yearInput.value : (''+currentYear) ],
      ['Early Target', elements.dashYearlyTarget ? elements.dashYearlyTarget.textContent : '0'],
      ['YTD Actual Inflow', elements.dashYtdAccomplished ? elements.dashYtdAccomplished.textContent : '0'],
      ['Remaining', elements.dashRemaining ? elements.dashRemaining.textContent : '0'],
      ['Next Needed', (function(){ var m=document.getElementById('nextBadgeMonth');var a=document.getElementById('nextBadgeAmount');var d=document.getElementById('nextBadgeDays'); var month=(m&&m.textContent||'').trim(); var amount=(a&&a.textContent||'').trim(); var days=(d&&d.textContent||'').trim(); return month&&amount ? (month+' — '+amount+(days?(' ('+days+')'):'') ) : '—'; })() ]
    ];

    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(summary);
    const ws2 = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws1, 'Summary');
    XLSX.utils.book_append_sheet(wb, ws2, 'Report');
    XLSX.writeFile(wb, 'ENBD_Performance_Report.xlsx');
  }

  // Wire buttons (reuse existing ones if present)
  const pdfBtn = document.getElementById('btnExportPDF');
  // Remove duplicate PDF event listener - handled elsewhere
  // if (pdfBtn) pdfBtn.onclick = exportPDF;

  const aiBtn = document.getElementById('btnAIAnalysis');
  if (aiBtn) aiBtn.onclick = function(){
    fillReport();
    var aiAnalysis = generateAIAnalysis();
    const modal = document.getElementById('aiAnalysisModal');
    const content = document.getElementById('aiAnalysisContent');
    const ts = document.getElementById('analysisTimestamp');
    if (modal && content) {
      // set timestamp first
      if (ts) ts.textContent = new Date().toLocaleString('en-GB');
      // robust owner resolution
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
  const noteEl = document.getElementById('shareOptionalNote');
  const noteEl2 = document.getElementById('shareOptionalNote2');
  const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
  const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
  const notesCombined = [note1, note2].filter(Boolean).join('<br>');
  const header = `📊 ENBD Performance Analysis Report<br>Owner: ${ownerName}<br>Generated: ` + (ts ? ts.textContent : new Date().toLocaleString('en-GB')) + '<br>';
  let noteHtml = '';
  if (notesCombined) noteHtml = `<div id="liveNoteDisplay" style="color:#c62828; font-weight:600; margin:32px 0 32px 0; white-space:pre-wrap;">${notesCombined}</div>`;
  // Store the original analysis in a global variable for live updates
  window.__originalAIAnalysis = aiAnalysis;
  content.innerHTML = header + noteHtml + '<br><div style="white-space:pre-wrap;">' + (aiAnalysis || '') + '</div>';
  // Live update of note in modal
  function updateLiveNoteDisplay() {
    const content = document.getElementById('aiAnalysisContent');
    const ts = document.getElementById('analysisTimestamp');
    const ownerEl = document.getElementById('ownerNameDisplay');
    let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
    if (!ownerName) {
      const sel = document.getElementById('ownerSelect');
      if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
    }
    ownerName = ownerName || currentOwner || 'Owner';
    const noteEl = document.getElementById('shareOptionalNote');
    const noteEl2 = document.getElementById('shareOptionalNote2');
    const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
    const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
    const notesCombined = [note1, note2].filter(Boolean).join('<br>');
    const header = `📊 ENBD Performance Analysis Report<br>Owner: ${ownerName}<br>Generated: ` + (ts ? ts.textContent : new Date().toLocaleString('en-GB')) + '<br>';
    let noteHtml = '';
  if (notesCombined) noteHtml = `<div id="liveNoteDisplay" style="color:#c62828; font-weight:600; margin:32px 0 32px 0; white-space:pre-wrap;">${notesCombined}</div>`;
  // Always use the original analysis for live updates
  let aiAnalysis = window.__originalAIAnalysis || '';
  content.innerHTML = header + noteHtml + '<br><div style="white-space:pre-wrap;">' + aiAnalysis + '</div>';
  }
  const noteInput1 = document.getElementById('shareOptionalNote');
  const noteInput2 = document.getElementById('shareOptionalNote2');
  if (noteInput1) noteInput1.addEventListener('input', updateLiveNoteDisplay);
  if (noteInput2) noteInput2.addEventListener('input', updateLiveNoteDisplay);
      modal.classList.add('visible');
      // ensure focus for accessibility
      content.setAttribute('tabindex', '-1');
      content.focus();
    } else {
      alert('AI Analysis:\n\n' + aiAnalysis);
    }
  };

  // Scenario Planning Button Handler
  const scenarioBtn = document.getElementById('btnScenarioPlanning');
  if (scenarioBtn) scenarioBtn.onclick = function(){
    openScenarioPlanner();
  };

function openScenarioPlanner() {
  console.log('Opening Scenario Planner');
  const modal = document.getElementById('scenarioModal');
  if (!modal) {
    console.error('Scenario modal not found');
    return;
  }
  // Reset inputs
  document.getElementById('scn-monthly-inc').value = 0;
  document.getElementById('scn-oneoff').value = 0;
  document.getElementById('scn-newtarget').value = '';
  document.getElementById('scn-growth').value = 0;
  // Set the months-ahead input to the default remaining months in the year
  try {
    const monthsElapsed = (new Date()).getMonth();
    const defaultMonths = 12 - monthsElapsed;
    const monthsInput = document.getElementById('scn-months-ahead');
    if (monthsInput) monthsInput.value = defaultMonths;
  } catch(e) {}
  // Render everything
  updateScenarioUI();
  modal.classList.add('visible');
  // Wire close/reset
  document.getElementById('scn-close').onclick = ()=>modal.classList.remove('visible');
  document.getElementById('scn-reset').onclick = ()=>{
    document.getElementById('scn-monthly-inc').value = 0;
    document.getElementById('scn-oneoff').value = 0;
    document.getElementById('scn-newtarget').value = '';
    document.getElementById('scn-growth').value = 0;
    // Reset months-ahead to default as well
    try {
      const monthsElapsed = (new Date()).getMonth();
      const defaultMonths = 12 - monthsElapsed;
      const monthsInput = document.getElementById('scn-months-ahead');
      if (monthsInput) monthsInput.value = defaultMonths;
    } catch(e) {}
    updateScenarioUI();
  };
  // Wire live update
  ['scn-monthly-inc','scn-oneoff','scn-newtarget','scn-growth','scn-months-ahead'].forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.oninput = updateScenarioUI;
  });

  // Wire inline months-ahead reset to default
  const resetInlineBtn = document.getElementById('scn-reset-inline');
  if (resetInlineBtn) {
    resetInlineBtn.onclick = () => {
      try {
        const monthsElapsed = (new Date()).getMonth();
        const defaultMonths = 12 - monthsElapsed;
        const monthsInput = document.getElementById('scn-months-ahead');
        if (monthsInput) monthsInput.value = defaultMonths;
      } catch(e) {}
      updateScenarioUI();
    };
  }
}

function formatCurrency(n) {
  return Number(n || 0).toLocaleString('en-US', { maximumFractionDigits: 0 });
}function updateScenarioUI() {
  // Get data - exclude current month since data entry is at month end
  const monthsElapsed = (new Date()).getMonth(); // Exclude current month
  const monthsLeftDefault = 12 - monthsElapsed; // Remaining months in the year
  // Determine months ahead from user input (min 1, max monthsLeftDefault)
  let monthsAheadInput = 0;
  try {
    const inputVal = document.getElementById('scn-months-ahead')?.value;
    monthsAheadInput = parseInt(inputVal, 10);
  } catch(e) { monthsAheadInput = 0; }
  let monthsLeft = monthsLeftDefault;
  if (!isNaN(monthsAheadInput) && monthsAheadInput > 0) {
    monthsLeft = Math.min(monthsLeftDefault, Math.max(1, monthsAheadInput));
  }
  // Sync the input value if user asked for more months than remaining in the year
  try {
    const monthsInput = document.getElementById('scn-months-ahead');
    if (monthsInput && parseInt(monthsInput.value, 10) !== monthsLeft) {
      monthsInput.value = monthsLeft;
    }
  } catch(e) {}
  const ytd = owners[currentOwner].actuals.slice(0, monthsElapsed).reduce((a,b)=>a+b,0);
  const avgMonthly = monthsElapsed ? ytd/monthsElapsed : 0;
  const currentTarget = owners[currentOwner].monthlyTargets.reduce((a,b)=>a+b,0);
  // Inputs
  const monthlyInc = parseFloat(document.getElementById('scn-monthly-inc').value)||0;
  const oneoff = parseFloat(document.getElementById('scn-oneoff').value)||0;
  const newTarget = parseFloat(document.getElementById('scn-newtarget').value)||currentTarget;
  const growthRate = (parseFloat(document.getElementById('scn-growth').value)||0)/100;
  
  // Note: months ahead display is now an editable input. Value is synchronized above.
  // Projected if nothing changes
  let projectedEnd = ytd;
  for (let i=0; i<monthsLeft; i++) {
    projectedEnd += avgMonthly * (1 + growthRate * i); // Apply growth over time
  }
  // Projected with changes
  let projectedEndScenario = ytd;
  for (let i=0; i<monthsLeft; i++) {
    projectedEndScenario += (avgMonthly + monthlyInc) * (1 + growthRate * i);
  }
  projectedEndScenario += oneoff;
  // Gaps
  const gapCurrent = newTarget - projectedEnd;
  const gapScenario = newTarget - projectedEndScenario;
  // Conditional results
  let currentResult = '';
  if (gapCurrent > 0) {
    currentResult = `AED Shortfall: <span style='color:#c62828;font-weight:600;'>${formatCurrency(gapCurrent)}</span>.`;
  } else {
    currentResult = `Surplus: <span style='color:#388e3c;font-weight:600;'>${formatCurrency(-gapCurrent)}</span> AED!`;
  }
  let scenarioResult = '';
  if (gapScenario > 0) {
    scenarioResult = `AED Shortfall: <span style='color:#c62828;font-weight:600;'>${formatCurrency(gapScenario)}</span>.`;
  } else {
    scenarioResult = `Surplus: <span style='color:#388e3c;font-weight:600;'>${formatCurrency(-gapScenario)}</span> AED!`;
  }
  
  // Enhanced average monthly display
  const currentAvgDisplay = formatCurrency(avgMonthly);
  const newAvgDisplay = formatCurrency(avgMonthly + monthlyInc);
  const avgIncrease = monthlyInc > 0 ? ` (+${formatCurrency(monthlyInc)})` : monthlyInc < 0 ? ` (${formatCurrency(monthlyInc)})` : '';
  
  // Render enhanced summaries with clear average monthly data
  document.getElementById('scn-current-summary').innerHTML =
    `<div style="background: rgba(25,118,210,0.08); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
      <div style="font-size: 17px; font-weight: 600; color: #1976d2; margin-bottom: 8px;">📊 Current Performance</div>
      <div style="font-size: 15px; margin-bottom: 4px;"><b>Average Monthly:</b> ${currentAvgDisplay} AED</div>
      <div style="font-size: 15px; margin-bottom: 8px;"><b>Year-to-Date:</b> ${formatCurrency(ytd)} AED (${monthsElapsed} months)</div>
      <div style="font-size: 15px;">Projected year-end: <b>${formatCurrency(projectedEnd)}</b> AED<br>${currentResult}</div>
    </div>`;
    
  document.getElementById('scn-projection-summary').innerHTML =
    `<div style="background: rgba(198,40,40,0.08); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
      <div style="font-size: 17px; font-weight: 600; color: #c62828; margin-bottom: 8px;">🎯 With Your Changes</div>
      <div style="font-size: 15px; margin-bottom: 4px;"><b>Average Monthly:</b> ${newAvgDisplay} AED${avgIncrease}</div>
      <div style="font-size: 15px; margin-bottom: 4px;"><b>One-off Addition:</b> ${formatCurrency(oneoff)} AED</div>
      <div style="font-size: 15px; margin-bottom: 8px;"><b>Growth Rate:</b> ${(growthRate * 100).toFixed(1)}% per month</div>
      <div style="font-size: 15px;">Projected year-end: <b>${formatCurrency(projectedEndScenario)}</b> AED<br>${scenarioResult}</div>
    </div>`;
  
  // Display action options
  const actionOptions = calculateActionOptions(gapScenario, monthsLeft, avgMonthly);
  const optionsHtml = actionOptions.map(option => `<div style="margin: 4px 0; padding: 6px; background: rgba(25,118,210,0.08); border-radius: 6px; font-size: 14px;">${option}</div>`).join('');
  document.getElementById('scn-action-options').innerHTML = optionsHtml;
  
  // Chart
  renderScenarioChart({monthsElapsed, ytd, avgMonthly, monthsLeft, monthlyInc, oneoff, growthRate, projectedEnd, projectedEndScenario, newTarget});
}

function calculateActionOptions(gap, monthsLeft, avgMonthly) {
  /*
   * Enhanced Action Options logic
   *
   * The original function offered a handful of simple suggestions.  The new version
   * expands the range of strategies and assumes all inflows occur at the end of
   * each month rather than daily.  If the gap is already closed or the time
   * horizon is zero or negative, a success message is returned immediately.
   */
  const options = [];
  // Guard against non-positive gap or zero months remaining
  if (gap <= 0 || monthsLeft <= 0) {
    options.push(`✅ Target already achievable without extra action.`);
    return options;
  }

  const m = monthsLeft;
  // Avoid division by tiny avgMonthly when computing percentages
  const base = Math.max(1, Math.round(avgMonthly));
  const pct = (x) => Math.round((x / base) * 100);

  // 1) Flat monthly increase across all remaining months
  const flatMonthly = Math.ceil(gap / m);
  options.push(`📈 Flat: +${flatMonthly.toLocaleString()} AED / month for ${m} month(s) (${pct(flatMonthly)}% ↑)`);

  // 2) One-off inflow at year end
  options.push(`💰 One-off: ${gap.toLocaleString()} AED as a single deposit (year-end).`);

  // 3) 50/50 split: half monthly, half one-off
  const splitMonthly = Math.ceil((gap * 0.5) / m);
  const splitOneoff = Math.ceil(gap * 0.5);
  options.push(`🔄 Split 50/50: +${splitMonthly.toLocaleString()} AED / month + one-off ${splitOneoff.toLocaleString()} AED.`);

  // 4) Laddered monthly increases: step up each month
  const seriesSum = (k) => k * (k + 1) / 2;
  const ladderStep = Math.ceil(gap / seriesSum(m));
  options.push(`📶 Laddered: +${ladderStep.toLocaleString()} AED in month 1, +${(2*ladderStep).toLocaleString()} in month 2, … (step = ${ladderStep.toLocaleString()})`);

  // 5) Front-loaded: heavier next month, rest evenly thereafter
  if (m >= 2) {
    const frontChunk = Math.ceil(gap * 0.40);
    const rest = Math.max(0, gap - frontChunk);
    const frontMonthly = Math.ceil(rest / (m - 1));
    options.push(`⏩ Front-loaded: one-off ${frontChunk.toLocaleString()} AED next month + ${frontMonthly.toLocaleString()} AED / month for ${m - 1} month(s).`);
  }

  // 6) Back-loaded: smaller now, larger later
  if (m >= 2) {
    const lastChunk = Math.ceil(gap * 0.40);
    const rest2 = Math.max(0, gap - lastChunk);
    const backMonthly = Math.ceil(rest2 / (m - 1));
    options.push(`⏭️ Back-loaded: ${backMonthly.toLocaleString()} AED / month for ${m - 1} month(s) + ${lastChunk.toLocaleString()} AED in final month.`);
  }

  // 7) Skip next month: postpone contributions until the month after next
  if (m >= 2) {
    const catchMonths = m - 1;
    const catchMonthly = Math.ceil(gap / catchMonths);
    options.push(`⏸️ Skip next month: +${catchMonthly.toLocaleString()} AED / month for ${catchMonths} month(s) starting the month after next.`);
  }

  // 8) Single push next month only
  options.push(`🎯 Single push: Add ${gap.toLocaleString()} AED next month only.`);

  // 9) Bi-monthly pushes
  const slotsBi = Math.ceil(m / 2);
  const biAmt = Math.ceil(gap / slotsBi);
  options.push(`📆 Bi-monthly: ${biAmt.toLocaleString()} AED every 2 months (${slotsBi} push(es)).`);

  // 10) Quarterly pushes
  const slotsQ = Math.ceil(m / 3);
  const qAmt = Math.ceil(gap / Math.max(1, slotsQ));
  options.push(`📅 Quarterly: ${qAmt.toLocaleString()} AED every 3 months (${slotsQ} push(es)).`);

  // 11) Efficiency uplift: assume +15% efficiency
  const effGain = Math.ceil(base * 0.15);
  const effContribution = effGain * m;
  const effRem = Math.max(0, gap - effContribution);
  options.push(`⚡ Efficiency: +15% efficiency (+${effGain.toLocaleString()} AED/month) covers ${effContribution.toLocaleString()} AED; remaining ${effRem.toLocaleString()} AED.`);

  // 12) Safety buffer: cover gap + extra 10%
  const safeGap = Math.ceil(gap * 1.10);
  const safeMonthly = Math.ceil(safeGap / m);
  options.push(`🛡️ Safety: +10% buffer → ${safeGap.toLocaleString()} AED total ⇒ ${safeMonthly.toLocaleString()} AED / month.`);

  // 13) Hybrid: heavy next month and lighter afterwards
  if (m >= 2) {
    const nextOnly = Math.ceil(gap * 0.60);
    const monthlyRest = Math.ceil((gap - nextOnly) / (m - 1));
    options.push(`🧩 Hybrid: ${nextOnly.toLocaleString()} AED next month + ${monthlyRest.toLocaleString()} AED / month for ${m - 1} month(s).`);
  }

  return options;
};
function renderScenarioChart(opts) {
  try {
    // Simple line chart: current trend vs. scenario
    const ctx = document.getElementById('scn-chart');
    if (!ctx) {
      console.error('Chart canvas not found');
      return;
    }
    if (window._scnChart) window._scnChart.destroy();
    
    const currentAvg = formatCurrency(opts.avgMonthly);
    const newAvg = formatCurrency(opts.avgMonthly + opts.monthlyInc);
    const growthDisplay = (opts.growthRate * 100).toFixed(1) + '%';
    
    const labels = [];
    const base = [];
    const scenario = [];
    let runningBase = opts.ytd;
    let runningScenario = opts.ytd;
    for (let i=1; i<=opts.monthsLeft; i++) {
      labels.push('M'+(opts.monthsElapsed+i));
      runningBase += opts.avgMonthly * (1 + opts.growthRate * i);
      runningScenario += (opts.avgMonthly + opts.monthlyInc) * (1 + opts.growthRate * i);
      if (i===1 && opts.oneoff) runningScenario += opts.oneoff;
      base.push(Math.round(runningBase));
      scenario.push(Math.round(runningScenario));
    }
    window._scnChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: `Current Trend (${currentAvg}/month)`,
            data: base,
            borderColor: '#1976d2',
            backgroundColor: 'rgba(25,118,210,0.08)',
            fill: false,
            tension: 0.2,
            pointRadius: 4,
            pointHoverRadius: 6
          },
          {
            label: `With Changes (${newAvg}/month + ${growthDisplay} growth)`,
            data: scenario,
            borderColor: '#c62828',
            backgroundColor: 'rgba(198,40,40,0.08)',
            fill: false,
            tension: 0.2,
            pointRadius: 4,
            pointHoverRadius: 6
          },
          {
            label: 'Target',
            data: Array(opts.monthsLeft).fill(opts.newTarget),
            borderColor: '#888',
            borderDash: [6, 4],
            pointRadius: 0,
            fill: false,
            type: 'line'
          }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { 
            display: true,
            labels: {
              usePointStyle: true,
              font: { size: 12 }
            }
          },
          tooltip: {
            callbacks: {
              title: function(context) {
                return `Month ${opts.monthsElapsed + context[0].dataIndex + 1}`;
              },
              label: function(context) {
                const dataset = context.dataset;
                const value = context.parsed.y;
                const month = context.dataIndex + 1;
                
                if (dataset.label.includes('Current Trend')) {
                  const monthlyContribution = opts.avgMonthly * (1 + opts.growthRate * month);
                  return [
                    `Current Trend: ${formatCurrency(value)} AED`,
                    `Monthly Contribution: ${formatCurrency(monthlyContribution)} AED`,
                    `Average Monthly: ${currentAvg} AED`
                  ];
                } else if (dataset.label.includes('With Changes')) {
                  const monthlyContribution = (opts.avgMonthly + opts.monthlyInc) * (1 + opts.growthRate * month);
                  const oneOffText = month === 1 && opts.oneoff ? ` + ${formatCurrency(opts.oneoff)} one-off` : '';
                  return [
                    `With Changes: ${formatCurrency(value)} AED${oneOffText}`,
                    `Monthly Contribution: ${formatCurrency(monthlyContribution)} AED`,
                    `Average Monthly: ${newAvg} AED`
                  ];
                } else {
                  return `Target: ${formatCurrency(value)} AED`;
                }
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: function(value) {
                return formatCurrency(value);
              }
            }
          },
          x: {
            title: {
              display: true,
              text: 'Remaining Months'
            }
          }
        },
        interaction: {
          mode: 'index',
          intersect: false
        }
      }
    });
  } catch (e) {
    console.error('Error rendering scenario chart:', e);
  }
}

  // Monthly Notes Button Handler
  const monthlyNotesBtn = document.getElementById('btnMonthlyNotes');
  if (monthlyNotesBtn) monthlyNotesBtn.onclick = function(){
    // Open the monthly notes modal via helper
    if (typeof openMonthlyNotesModal === 'function') {
      openMonthlyNotesModal();
    }
  };

  const excelBtn = document.getElementById('btnExportExcel');
  if (excelBtn) excelBtn.onclick = exportExcel;

  const repBtn = document.getElementById('btnGenerateReport');
  if (repBtn) repBtn.onclick = exportPDF; // Report button triggers the PDF flow

  // AI Analysis Modal Handlers
  const closeAIAnalysisBtn = document.getElementById('closeAIAnalysisBtn');
  if (closeAIAnalysisBtn) {
    closeAIAnalysisBtn.onclick = function() {
      const modal = document.getElementById('aiAnalysisModal');
      if (modal) modal.classList.remove('visible');
    };
  }

  // Close modal when clicking outside
  const scenarioModal = document.getElementById('scenarioModal');
  if (scenarioModal) {
    scenarioModal.onclick = function(e) {
      if (e.target === scenarioModal) {
        scenarioModal.classList.remove('visible');
      }
    };
  }

  const monthlyNotesModal = document.getElementById('monthlyNotesModal');
  if (monthlyNotesModal) {
    monthlyNotesModal.onclick = function(e) {
      if (e.target === monthlyNotesModal) {
        monthlyNotesModal.classList.remove('visible');
      }
    };
  }

  // Scenario Planning Modal Handlers
  const closeScenarioBtn = document.getElementById('closeScenarioBtn');
  if (closeScenarioBtn) {
    closeScenarioBtn.onclick = function() {
      hideModal(elements.scenarioModal);
    };
  }

  const resetScenarioBtn = document.getElementById('resetScenarioBtn');
  if (resetScenarioBtn) {
    resetScenarioBtn.onclick = function() {
      resetScenarioInputs();
      showToast('Scenario inputs reset!', 'info');
    };
  }

  const applyScenarioBtn = document.getElementById('applyScenarioBtn');
  if (applyScenarioBtn) {
    applyScenarioBtn.onclick = function() {
      applyScenarioChanges();
      showToast('Scenario applied successfully!', 'success');
    };
  }

  // Enhanced Scenario Sharing with Amazing Layout
  const shareEntireScenarioBtn = document.getElementById('shareEntireScenarioBtn');
  if (shareEntireScenarioBtn) {
    shareEntireScenarioBtn.onclick = function() {
      const scenarioModal = document.getElementById('scenarioModal');
      if (scenarioModal) {
        // Create a comprehensive sharing layout
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerName) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
        }
        ownerName = ownerName || currentOwner || 'Owner';
        const year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());

        // Get all scenario data
        const currentSummary = document.getElementById('scn-current-summary')?.innerHTML || '';
        const projectionSummary = document.getElementById('scn-projection-summary')?.innerHTML || '';
        const actionOptionsDivs = document.querySelectorAll('#scn-action-options > div');
        const actionOptions = Array.from(actionOptionsDivs).map(div => div.textContent.trim()).join('\n');
        // Obtain months ahead from the editable input
        const monthsAheadInputEl = document.getElementById('scn-months-ahead');
        const monthsAhead = monthsAheadInputEl ? (monthsAheadInputEl.value || '') : '';

        // Build comprehensive sharing content
        const header = `🎯 ENBD Scenario Planner — Complete Analysis\nOwner: ${ownerName}\nYear: ${year}\nGenerated: ${new Date().toLocaleString('en-GB')}\n\n`;

        let content = header;
        content += `📊 SCENARIO OVERVIEW\n`;
        content += `Months Ahead: ${monthsAhead}\n\n`;

        content += `📈 CURRENT TREND\n`;
        content += currentSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `🎯 WITH YOUR CHANGES\n`;
        content += projectionSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `💡 ACTION OPTIONS TO REACH TARGET\n`;
        // Ensure each action option is on its own line
        const formattedActionOptions = actionOptions.trim().split('\n').filter(line => line.trim()).map(line => line.trim()).join('\n');
        content += formattedActionOptions + '\n\n';

        content += `═══════════════════════════════════════════════\n`;
        content += `Generated by ENBD Performance Tracker\n`;
        content += `For comprehensive financial planning and analysis\n`;

        // Open WhatsApp with the complete scenario
        window.open('https://wa.me/?text=' + encodeURIComponent(content), '_blank');
        showToast('Opening WhatsApp with complete scenario...', 'info');
      }
    };
  }

  const copyEntireScenarioBtn = document.getElementById('copyEntireScenarioBtn');
  if (copyEntireScenarioBtn) {
    copyEntireScenarioBtn.onclick = async function() {
      const scenarioModal = document.getElementById('scenarioModal');
      if (scenarioModal) {
        // Create comprehensive sharing content
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerName) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
        }
        ownerName = ownerName || currentOwner || 'Owner';
        const year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());

        // Get all scenario data
        const currentSummary = document.getElementById('scn-current-summary')?.innerHTML || '';
        const projectionSummary = document.getElementById('scn-projection-summary')?.innerHTML || '';
        const actionOptionsDivs = document.querySelectorAll('#scn-action-options > div');
        const actionOptions = Array.from(actionOptionsDivs).map(div => div.textContent.trim()).join('\n');
        // Obtain months ahead from the editable input
        const _monthsAheadInputEl1 = document.getElementById('scn-months-ahead');
        const monthsAhead = _monthsAheadInputEl1 ? (_monthsAheadInputEl1.value || '') : '';

        // Build comprehensive sharing content
        const header = `🎯 ENBD Scenario Planner — Complete Analysis\nOwner: ${ownerName}\nYear: ${year}\nGenerated: ${new Date().toLocaleString('en-GB')}\n\n`;

        let content = header;
        content += `📊 SCENARIO OVERVIEW\n`;
        content += `Months Ahead: ${monthsAhead}\n\n`;

        content += `📈 CURRENT TREND\n`;
        content += currentSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `🎯 WITH YOUR CHANGES\n`;
        content += projectionSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `💡 ACTION OPTIONS TO REACH TARGET\n`;
        // Ensure each action option is on its own line
        const formattedActionOptions = actionOptions.trim().split('\n').filter(line => line.trim()).map(line => line.trim()).join('\n');
        content += formattedActionOptions + '\n\n';

        content += `═══════════════════════════════════════════════\n`;
        content += `Generated by ENBD Performance Tracker\n`;
        content += `For comprehensive financial planning and analysis\n`;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(content).then(() => showToast('Complete scenario copied to clipboard!', 'success'));
        } else {
          const ta = document.createElement('textarea');
          ta.value = content;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          showToast('Complete scenario copied to clipboard!', 'success');
        }
      }
    };
  }

  const exportEntireScenarioBtn = document.getElementById('exportEntireScenarioBtn');
  if (exportEntireScenarioBtn) {
    exportEntireScenarioBtn.onclick = function() {
      const scenarioModal = document.getElementById('scenarioModal');
      if (scenarioModal) {
        // Create comprehensive sharing content
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerName) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
        }
        ownerName = ownerName || currentOwner || 'Owner';
        const year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());

        // Get all scenario data
        const currentSummary = document.getElementById('scn-current-summary')?.innerHTML || '';
        const projectionSummary = document.getElementById('scn-projection-summary')?.innerHTML || '';
        const actionOptionsDivs = document.querySelectorAll('#scn-action-options > div');
        const actionOptions = Array.from(actionOptionsDivs).map(div => div.textContent.trim()).join('\n');
        // Read months ahead from the editable input field
        const _monthsAheadInputEl2 = document.getElementById('scn-months-ahead');
        const monthsAhead = _monthsAheadInputEl2 ? (_monthsAheadInputEl2.value || '') : '';

        // Build comprehensive sharing content
        const header = `🎯 ENBD Scenario Planner — Complete Analysis\nOwner: ${ownerName}\nYear: ${year}\nGenerated: ${new Date().toLocaleString('en-GB')}\n\n`;

        let content = header;
        content += `📊 SCENARIO OVERVIEW\n`;
        content += `Months Ahead: ${monthsAhead}\n\n`;

        content += `📈 CURRENT TREND\n`;
        content += currentSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `🎯 WITH YOUR CHANGES\n`;
        content += projectionSummary.replace(/<[^>]*>/g, '').trim() + '\n\n';

        content += `💡 ACTION OPTIONS TO REACH TARGET\n`;
        // Ensure each action option is on its own line
        const formattedActionOptions = actionOptions.trim().split('\n').filter(line => line.trim()).map(line => line.trim()).join('\n');
        content += formattedActionOptions + '\n\n';

        content += `═══════════════════════════════════════════════\n`;
        content += `Generated by ENBD Performance Tracker\n`;
        content += `For comprehensive financial planning and analysis\n`;

        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ENBD_Scenario_Analysis_${(new Date()).toISOString().split('T')[0]}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Complete scenario exported as text file!', 'success');
      }
    };
  }

  // Initialize scenario inputs and add event listeners
  const scenarioInputs = ['growthRate', 'targetAdjustment', 'monthlyIncrease', 'scenarioMonths'];
  scenarioInputs.forEach(id => {
    const input = document.getElementById(id);
    if (input) {
      // Update display value
      const valueSpan = document.getElementById(id + 'Value');
      if (valueSpan) {
        valueSpan.textContent = input.value + (id === 'scenarioMonths' ? ' months' : '%');
      }

      input.addEventListener('input', function() {
        if (valueSpan) {
          valueSpan.textContent = this.value + (id === 'scenarioMonths' ? ' months' : '%');
        }
        updateScenarioResults();
      });
      input.addEventListener('change', function() {
        if (valueSpan) {
          valueSpan.textContent = this.value + (id === 'scenarioMonths' ? ' months' : '%');
        }
        updateScenarioResults();
      });

      // Ensure input is interactive
      input.disabled = false;
      input.style.pointerEvents = 'auto';
      input.style.opacity = '1';
    }
  });

  // Initialize scenario planning when button is clicked
  const btnScenarioPlanning = document.getElementById('btnScenarioPlanning');
  if (btnScenarioPlanning) {
    btnScenarioPlanning.onclick = function() {
      console.log('Scenario button clicked');
      openScenarioPlanner();
    };
  }

  // Initialize Monthly Notes when button is clicked
  const btnMonthlyNotesInit = document.getElementById('btnMonthlyNotes');
  if (btnMonthlyNotesInit) {
    btnMonthlyNotesInit.onclick = function() {
      console.log('Monthly notes button clicked');
      if (typeof openMonthlyNotesModal === 'function') {
        openMonthlyNotesModal();
      }
    };
  }

  // Monthly notes modal has its own close/export handlers attached within openMonthlyNotesModal()

  const exportAIAnalysisBtn = document.getElementById('exportAIAnalysisBtn');
  if (exportAIAnalysisBtn) {
    exportAIAnalysisBtn.onclick = function() {
      const content = document.getElementById('aiAnalysisContent');
      const ts = document.getElementById('analysisTimestamp');
      // Resolve owner name robustly from display, owners data, or select option
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (content && content.textContent) {
        const noteEl = document.getElementById('shareOptionalNote');
        const noteEl2 = document.getElementById('shareOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';
        let header = `📊 ENBD Performance Analysis Report\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
  let noteText = notesCombined ? ('\n\n==== ' + notesCombined.toUpperCase() + ' ====\n\n') : '';
  let analysisText = window.__originalAIAnalysis || '';
  const assembled = header + noteText + analysisText;
        const blob = new Blob([assembled], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ENBD_AI_Analysis_${(new Date()).toISOString().split('T')[0]}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Exported analysis as text', 'success');
      }
    };
  }

  // AI Analysis Sharing Handlers
  const copyAIAnalysisBtn = document.getElementById('copyAIAnalysisBtn');
  if (copyAIAnalysisBtn) {
    copyAIAnalysisBtn.onclick = async function() {
      const content = document.getElementById('aiAnalysisContent');
      const ts = document.getElementById('analysisTimestamp');
      // robust owner resolution
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (content && content.textContent) {
        const noteEl = document.getElementById('shareOptionalNote');
        const noteEl2 = document.getElementById('shareOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';
        let header = `📊 ENBD Performance Analysis Report\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
  let noteText = notesCombined ? ('\n\n==== ' + notesCombined.toUpperCase() + ' ====\n\n') : '';
  let analysisText = window.__originalAIAnalysis || '';
  const fullText = header + noteText + analysisText;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(fullText).then(() => showToast('Analysis copied to clipboard!', 'success'));
        } else {
          const ta = document.createElement('textarea');
          ta.value = fullText;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          showToast('Analysis copied to clipboard!', 'success');
        }
      }
    };
  }

  const shareWhatsAppBtn = document.getElementById('shareWhatsAppBtn');
  if (shareWhatsAppBtn) {
    shareWhatsAppBtn.onclick = function() {
      const content = document.getElementById('aiAnalysisContent');
      const ts = document.getElementById('analysisTimestamp');
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (content && content.textContent) {
        const noteEl = document.getElementById('shareOptionalNote');
        const noteEl2 = document.getElementById('shareOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';
        let header = `📊 ENBD Performance Analysis Report\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
  let noteText = notesCombined ? ('\n\n==== ' + notesCombined.toUpperCase() + ' ====\n\n') : '';
  let analysisText = window.__originalAIAnalysis || '';
  const assembled = header + noteText + analysisText;
        window.open('https://wa.me/?text=' + encodeURIComponent(assembled), '_blank');
        showToast('Opening WhatsApp...', 'info');
      }
    };
  }

  const shareTwitterBtn = document.getElementById('shareTwitterBtn');
  if (shareTwitterBtn) {
    shareTwitterBtn.onclick = function() {
      // Twitter sharing removed
    };
  }

  const shareLinkedInBtn = document.getElementById('shareLinkedInBtn');
  if (shareLinkedInBtn) {
    shareLinkedInBtn.onclick = function() {
      // LinkedIn sharing removed
    };
  }

  // Email share handler (build mailto with subject/body including optional note)
  const shareEmailBtn = document.getElementById('shareEmailBtn');
  if (shareEmailBtn) {
    shareEmailBtn.onclick = function() {
      const content = document.getElementById('aiAnalysisContent');
      const ts = document.getElementById('analysisTimestamp');
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (content && content.textContent) {
        const noteEl = document.getElementById('shareOptionalNote');
        const noteEl2 = document.getElementById('shareOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';
        let header = `📊 ENBD Performance Analysis Report\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
        let noteText = notesCombined ? (notesCombined.toUpperCase() + '\n') : '';
        let analysisText = window.__originalAIAnalysis || '';
        const assembled = header + noteText + '\n' + analysisText;
        const subject = 'ENBD Performance Analysis';
        const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(assembled)}`;
        window.location.href = mailto;
        showToast('Opening email client...', 'info');
      }
    };
  }

  // Toast notification helper function
  function showToast(message, type = 'success') {
    const toast = document.getElementById('toastNotification');
    if (toast) {
      toast.textContent = message;
      toast.className = 'toast-notification ' + (type === 'error' ? 'error' : type === 'info' ? 'info' : '');
      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }
  }

  // Share preview helper: shows assembled text and stores desired action
  let __sharePreviewAction = null;
  function showSharePreview(text, action) {
    __sharePreviewAction = action;
    // Rebuild text from DOM to guarantee latest optional note and content
    const contentEl = document.getElementById('aiAnalysisContent');
    const ts = document.getElementById('analysisTimestamp');
    const ownerEl = document.getElementById('ownerNameDisplay');
    let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
    if (!ownerName) {
      const sel = document.getElementById('ownerSelect');
      if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
    }
    ownerName = ownerName || currentOwner || 'Owner';
    const header = `ENBD Performance Analysis Report\nOwner: ${ownerName}\nGenerated: ` + (ts ? ts.textContent : new Date().toLocaleString('en-GB')) + '\n\n';
  const noteEl = document.getElementById('shareOptionalNote');
  const noteEl2 = document.getElementById('shareOptionalNote2');
  const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
  const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
  // Only show what user typed, never a fixed template or warning
  const notesCombined = [note1, note2].filter(Boolean).join('\n');
  const noteText = notesCombined ? ('Note: ' + notesCombined + '\n\n') : '';
  const assembled = header + noteText + (contentEl && contentEl.textContent ? contentEl.textContent : (text || ''));
  const modal = document.getElementById('sharePreviewModal');
  const pre = document.getElementById('sharePreviewContent');
  const notesDiv = document.getElementById('sharePreviewNotes');
  // Show only user-typed notes, never a default
  if (notesDiv) notesDiv.textContent = notesCombined;
  if (pre) pre.textContent = assembled;
  if (modal) {
    modal.style.display = 'block';
    modal.classList.add('visible');
  }
  }

  function hideSharePreview() {
    const modal = document.getElementById('sharePreviewModal');
    if (modal) {
      modal.classList.remove('visible');
      modal.style.display = 'none';
    }
    __sharePreviewAction = null;
  }

  // Wire preview buttons
  const sharePreviewCancel = document.getElementById('sharePreviewCancel');
  const sharePreviewProceed = document.getElementById('sharePreviewProceed');
  if (sharePreviewCancel) sharePreviewCancel.addEventListener('click', hideSharePreview);
  if (sharePreviewProceed) sharePreviewProceed.addEventListener('click', function() {
    // Instead of performing the action directly, close the preview and show the compact action picker
    const pre = document.getElementById('sharePreviewContent');
    const text = pre ? pre.textContent : '';
    if (!text) { hideSharePreview(); return; }
    // store assembled text on the picker for later use
    const picker = document.getElementById('shareActionPicker');
    if (picker) {
      picker.dataset.payload = text;
      picker.style.display = 'block';
    }
    hideSharePreview();
  });

  // Picker wiring: buttons to perform final action
  const picker = document.getElementById('shareActionPicker');
  if (picker) {
    const btnCopy = document.getElementById('pickerCopy');
    const btnWa = document.getElementById('pickerWhatsApp');
    const btnEmail = document.getElementById('pickerEmail');
    const btnExport = document.getElementById('pickerExport');
    const btnCancel = document.getElementById('pickerCancel');
    function performPayloadAction(type) {
      const payload = picker.dataset.payload || '';
      try {
        if (type === 'copy') {
          if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(payload).then(() => showToast('Analysis copied to clipboard!', 'success'));
          else { const ta = document.createElement('textarea'); ta.value = payload; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); showToast('Analysis copied to clipboard!', 'success'); }
        } else if (type === 'wa') {
          window.open('https://wa.me/?text=' + encodeURIComponent(payload), '_blank'); showToast('Opening WhatsApp...', 'info');
        } else if (type === 'export') {
          const blob = new Blob([payload], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `ENBD_AI_Analysis_${(new Date()).toISOString().split('T')[0]}.txt`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showToast('Exported analysis as text', 'success');
        } else if (type === 'email') {
          const subject = 'ENBD Performance Analysis'; const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(payload)}`; window.location.href = mailto;
        }
      } catch (e) { console.error(e); showToast('Sharing failed', 'error'); }
      picker.style.display = 'none';
      delete picker.dataset.payload;
    }
    if (btnCopy) btnCopy.addEventListener('click', () => performPayloadAction('copy'));
    if (btnWa) btnWa.addEventListener('click', () => performPayloadAction('wa'));
    if (btnEmail) btnEmail.addEventListener('click', () => performPayloadAction('email'));
    if (btnExport) btnExport.addEventListener('click', () => performPayloadAction('export'));
    if (btnCancel) btnCancel.addEventListener('click', () => { picker.style.display = 'none'; delete picker.dataset.payload; });
  }

  // Clear notes button wiring
  const shareNoteClearBtn = document.getElementById('shareNoteClear');
  if (shareNoteClearBtn) {
    shareNoteClearBtn.addEventListener('click', function() {
      const n1 = document.getElementById('shareOptionalNote');
      const n2 = document.getElementById('shareOptionalNote2');
  if (n1) n1.value = '';
  if (n2) n2.value = '';
  // Also clear the live note display in the modal if present
  const liveNote = document.getElementById('liveNoteDisplay');
  if (liveNote) liveNote.remove();
  // Optionally, trigger the live update function if it exists
  if (typeof updateLiveNoteDisplay === 'function') updateLiveNoteDisplay();
  if (n1) n1.focus();
    });
  }

  // Heat Map Sharing Handlers
  const copyHeatMapBtn = document.getElementById('copyHeatMapBtn');
  if (copyHeatMapBtn) {
    copyHeatMapBtn.onclick = async function() {
      const heatmapGrid = document.getElementById('heatmapGrid');
      const ts = document.getElementById('heatmapTimestamp');
      // robust owner resolution
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (heatmapGrid) {
        const noteEl = document.getElementById('shareHeatMapOptionalNote');
        const noteEl2 = document.getElementById('shareHeatMapOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';

        // Build heat map data summary
        let heatmapData = '🔥 Heat Map Performance Summary:\n\n';
        const cells = heatmapGrid.querySelectorAll('.heatmap-cell');
        cells.forEach((cell, index) => {
          const month = cell.querySelector('.cell-month').textContent;
          const completion = cell.querySelector('.cell-value').textContent;
          const tooltip = cell.querySelector('.cell-tooltip');
          let details = '';
          if (tooltip) {
            const lines = tooltip.innerHTML.split('<br>');
            details = lines.map(line => line.replace(/<[^>]*>/g, '').trim()).join(' | ');
          }
          heatmapData += `${month}: ${completion} (${details})\n`;
        });

        let header = `🔥 ENBD Performance Heat Map\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
        let noteText = notesCombined ? ('\n\n==== ' + notesCombined.toUpperCase() + ' ====\n\n') : '';
        const fullText = header + noteText + heatmapData;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(fullText).then(() => showToast('Heat map copied to clipboard!', 'success'));
        } else {
          const ta = document.createElement('textarea');
          ta.value = fullText;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          showToast('Heat map copied to clipboard!', 'success');
        }
      }
    };
  }

  const shareHeatMapWhatsAppBtn = document.getElementById('shareHeatMapWhatsAppBtn');
  if (shareHeatMapWhatsAppBtn) {
    shareHeatMapWhatsAppBtn.onclick = function() {
      const heatmapGrid = document.getElementById('heatmapGrid');
      const ts = document.getElementById('heatmapTimestamp');
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (heatmapGrid) {
        const noteEl = document.getElementById('shareHeatMapOptionalNote');
        const noteEl2 = document.getElementById('shareHeatMapOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';

        // Build heat map data summary
        let heatmapData = '🔥 Heat Map Performance Summary:\n\n';
        const cells = heatmapGrid.querySelectorAll('.heatmap-cell');
        cells.forEach((cell, index) => {
          const month = cell.querySelector('.cell-month').textContent;
          const completion = cell.querySelector('.cell-value').textContent;
          const tooltip = cell.querySelector('.cell-tooltip');
          let details = '';
          if (tooltip) {
            const lines = tooltip.innerHTML.split('<br>');
            details = lines.map(line => line.replace(/<[^>]*>/g, '').trim()).join(' | ');
          }
          heatmapData += `${month}: ${completion} (${details})\n`;
        });

        let header = `🔥 ENBD Performance Heat Map\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
        let noteText = notesCombined ? ('\n\n==== ' + notesCombined.toUpperCase() + ' ====\n\n') : '';
        const assembled = header + noteText + heatmapData;
        window.open('https://wa.me/?text=' + encodeURIComponent(assembled), '_blank');
        showToast('Opening WhatsApp...', 'info');
      }
    };
  }

  const shareHeatMapEmailBtn = document.getElementById('shareHeatMapEmailBtn');
  if (shareHeatMapEmailBtn) {
    shareHeatMapEmailBtn.onclick = function() {
      const heatmapGrid = document.getElementById('heatmapGrid');
      const ts = document.getElementById('heatmapTimestamp');
      const ownerEl = document.getElementById('ownerNameDisplay');
      let ownerName = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
      if (!ownerName) {
        const sel = document.getElementById('ownerSelect');
        if (sel && sel.options && sel.selectedIndex >= 0) ownerName = sel.options[sel.selectedIndex].text;
      }
      ownerName = ownerName || currentOwner || 'Owner';
      if (heatmapGrid) {
        const noteEl = document.getElementById('shareHeatMapOptionalNote');
        const noteEl2 = document.getElementById('shareHeatMapOptionalNote2');
        const note1 = (noteEl && noteEl.value && noteEl.value.trim()) ? noteEl.value.trim() : '';
        const note2 = (noteEl2 && noteEl2.value && noteEl2.value.trim()) ? noteEl2.value.trim() : '';
        const notesCombined = [note1, note2].filter(Boolean).join('\n');
        const tsText = ts ? ts.textContent : new Date().toLocaleString('en-GB');
        const ownerEl = document.getElementById('ownerNameDisplay');
        let ownerNameText = (ownerEl && ownerEl.textContent && ownerEl.textContent.trim() && ownerEl.textContent.trim() !== 'Owner') ? ownerEl.textContent.trim() : (owners && owners[currentOwner] ? owners[currentOwner].name : null);
        if (!ownerNameText) {
          const sel = document.getElementById('ownerSelect');
          if (sel && sel.options && sel.selectedIndex >= 0) ownerNameText = sel.options[sel.selectedIndex].text;
        }
        ownerNameText = ownerNameText || currentOwner || 'Owner';

        // Build heat map data summary
        let heatmapData = '🔥 Heat Map Performance Summary:\n\n';
        const cells = heatmapGrid.querySelectorAll('.heatmap-cell');
        cells.forEach((cell, index) => {
          const month = cell.querySelector('.cell-month').textContent;
          const completion = cell.querySelector('.cell-value').textContent;
          const tooltip = cell.querySelector('.cell-tooltip');
          let details = '';
          if (tooltip) {
            const lines = tooltip.innerHTML.split('<br>');
            details = lines.map(line => line.replace(/<[^>]*>/g, '').trim()).join(' | ');
          }
          heatmapData += `${month}: ${completion} (${details})\n`;
        });

        let header = `🔥 ENBD Performance Heat Map\nOwner: ${ownerNameText}\nGenerated: ${tsText}\n`;
        let noteText = notesCombined ? (notesCombined.toUpperCase() + '\n') : '';
        const assembled = header + noteText + '\n' + heatmapData;
        const subject = 'ENBD Performance Heat Map';
        const mailto = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(assembled)}`;
        window.location.href = mailto;
        showToast('Opening email client...', 'info');
      }
    };
  }

  const exportHeatMapBtn = document.getElementById('exportHeatMapBtn');
  if (exportHeatMapBtn) {
    exportHeatMapBtn.onclick = function() {
      const heatmapModal = document.getElementById('heatmapModal');
      if (heatmapModal && window.html2canvas) {
        // Temporarily show the modal for export
        const wasVisible = heatmapModal.style.display !== 'none';
        if (!wasVisible) {
          heatmapModal.style.display = 'block';
          heatmapModal.classList.add('visible');
        }

        html2canvas(heatmapModal, {
          backgroundColor: '#ffffff',
          scale: 2,
          useCORS: true
        }).then(canvas => {
          const link = document.createElement('a');
          link.download = `ENBD_HeatMap_${new Date().toISOString().split('T')[0]}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();

          // Hide modal if it was hidden before
          if (!wasVisible) {
            heatmapModal.style.display = 'none';
            heatmapModal.classList.remove('visible');
          }

          showToast('Heat map exported successfully!', 'success');
        }).catch(err => {
          console.error('Export failed:', err);
          showToast('Export failed', 'error');
        });
      } else {
        showToast('Export library not available', 'error');
      }
    };
  }

  const closeHeatMapBtn = document.getElementById('closeHeatMapBtn');
  if (closeHeatMapBtn) {
    closeHeatMapBtn.onclick = function() {
      const heatmapModal = document.getElementById('heatmapModal');
      if (heatmapModal) {
        heatmapModal.classList.remove('visible');
        heatmapModal.style.display = 'none';
      }
    };
  }

  // Heat Map note clear handler
  const shareHeatMapNoteClear = document.getElementById('shareHeatMapNoteClear');
  if (shareHeatMapNoteClear) {
    shareHeatMapNoteClear.addEventListener('click', function() {
      const n1 = document.getElementById('shareHeatMapOptionalNote');
      const n2 = document.getElementById('shareHeatMapOptionalNote2');
      if (n1) n1.value = '';
      if (n2) n2.value = '';
      if (n1) n1.focus();
    });
  }

  // Heat Map preview modal handlers
  const shareHeatMapPreviewCancel = document.getElementById('shareHeatMapPreviewCancel');
  const shareHeatMapPreviewProceed = document.getElementById('shareHeatMapPreviewProceed');
  if (shareHeatMapPreviewCancel) {
    shareHeatMapPreviewCancel.addEventListener('click', function() {
      const modal = document.getElementById('shareHeatMapPreviewModal');
      if (modal) {
        modal.style.display = 'none';
      }
    });
  }
  if (shareHeatMapPreviewProceed) {
    shareHeatMapPreviewProceed.addEventListener('click', function() {
      const modal = document.getElementById('shareHeatMapPreviewModal');
      if (modal) {
        modal.style.display = 'none';
        // Show action picker
        const picker = document.getElementById('shareHeatMapActionPicker');
        if (picker) {
          picker.style.display = 'block';
        }
      }
    });
  }

  // Heat Map action picker handlers
  const pickerHeatMapCopy = document.getElementById('pickerHeatMapCopy');
  const pickerHeatMapWhatsApp = document.getElementById('pickerHeatMapWhatsApp');
  const pickerHeatMapEmail = document.getElementById('pickerHeatMapEmail');
  const pickerHeatMapExport = document.getElementById('pickerHeatMapExport');
  const pickerHeatMapCancel = document.getElementById('pickerHeatMapCancel');

  if (pickerHeatMapCopy) {
    pickerHeatMapCopy.addEventListener('click', function() {
      const picker = document.getElementById('shareHeatMapActionPicker');
      if (picker) picker.style.display = 'none';
      if (copyHeatMapBtn) copyHeatMapBtn.click();
    });
  }
  if (pickerHeatMapWhatsApp) {
    pickerHeatMapWhatsApp.addEventListener('click', function() {
      const picker = document.getElementById('shareHeatMapActionPicker');
      if (picker) picker.style.display = 'none';
      if (shareHeatMapWhatsAppBtn) shareHeatMapWhatsAppBtn.click();
    });
  }
  if (pickerHeatMapEmail) {
    pickerHeatMapEmail.addEventListener('click', function() {
      const picker = document.getElementById('shareHeatMapActionPicker');
      if (picker) picker.style.display = 'none';
      if (shareHeatMapEmailBtn) shareHeatMapEmailBtn.click();
    });
  }
  if (pickerHeatMapExport) {
    pickerHeatMapExport.addEventListener('click', function() {
      const picker = document.getElementById('shareHeatMapActionPicker');
      if (picker) picker.style.display = 'none';
      if (exportHeatMapBtn) exportHeatMapBtn.click();
    });
  }
  if (pickerHeatMapCancel) {
    pickerHeatMapCancel.addEventListener('click', function() {
      const picker = document.getElementById('shareHeatMapActionPicker');
      if (picker) picker.style.display = 'none';
    });
  }
  function resetScenarioInputs() {
    console.log('Resetting scenario inputs...');
    document.getElementById('growthRate').value = 5;
    document.getElementById('targetAdjustment').value = 0;
    document.getElementById('monthlyIncrease').value = 0;
    document.getElementById('scenarioMonths').value = 12;

    // Update display values
    document.getElementById('growthRateValue').textContent = '5%';
    document.getElementById('targetAdjustmentValue').textContent = '0%';
    document.getElementById('monthlyIncreaseValue').textContent = '0%';
    document.getElementById('scenarioMonthsValue').textContent = '12 months';

    updateScenarioResults();
  }

  function updateScenarioResults() {
    const growthRate = parseFloat(document.getElementById('growthRate').value) / 100;
    const targetAdjustment = parseFloat(document.getElementById('targetAdjustment').value) / 100;
    const monthlyIncrease = parseFloat(document.getElementById('monthlyIncrease').value);
    const months = parseInt(document.getElementById('scenarioMonths').value);

    // Calculate current totals
    const currentTotal = sumActuals.reduce((sum, val) => sum + val, 0);
    const currentTarget = monthlyTargets.reduce((sum, val) => sum + val, 0);

    // Update base scenario display
    document.getElementById('baseTarget').textContent = formatCurrency(currentTarget);
    document.getElementById('baseYtd').textContent = formatCurrency(currentTotal);
    document.getElementById('baseCompletion').textContent = Math.round((currentTotal / currentTarget) * 100) + '%';

    // Project future performance
    let projectedTotal = currentTotal;
    let projectedTarget = currentTarget * (1 + targetAdjustment);
    let monthlyData = [];

    for (let i = 1; i <= months; i++) {
      // Apply growth rate and monthly increase
      projectedTotal *= (1 + growthRate);
      projectedTotal += monthlyIncrease;

      // Adjust target if needed
      projectedTarget *= (1 + targetAdjustment / months);

      const completionRate = (projectedTotal / projectedTarget) * 100;
      monthlyData.push({
        month: i,
        projected: Math.round(projectedTotal),
        target: Math.round(projectedTarget),
        completion: Math.round(completionRate * 100) / 100
      });
    }

    // Update display
    document.getElementById('projectedTarget').textContent = formatCurrency(projectedTarget);
    document.getElementById('projectedYearEnd').textContent = formatCurrency(projectedTotal);
    document.getElementById('projectedCompletion').textContent = `${Math.round((projectedTotal / projectedTarget) * 100)}%`;
    document.getElementById('gapAnalysis').textContent = formatCurrency(projectedTarget - projectedTotal);

    // Update scenario chart
    updateScenarioChart(monthlyData);
  }

  function applyScenarioChanges() {
    const growthRate = parseFloat(document.getElementById('growthRate').value) / 100;
    const targetAdjustment = parseFloat(document.getElementById('targetAdjustment').value) / 100;
    const monthlyIncrease = parseFloat(document.getElementById('monthlyIncrease').value);

    // Apply changes to actual data (for demonstration)
    for (let i = 0; i < sumActuals.length; i++) {
      sumActuals[i] *= (1 + growthRate);
      sumActuals[i] += monthlyIncrease;
    }

    // Update targets
    for (let i = 0; i < monthlyTargets.length; i++) {
      monthlyTargets[i] *= (1 + targetAdjustment);
    }

    // Refresh all displays
    updateDashboard();
    updateCharts();
  }

  function updateScenarioChart(data) {
    const ctx = document.getElementById('scenarioChart');
    if (!ctx) return;

    const chartData = {
      labels: data.map(d => `Month ${d.month}`),
      datasets: [{
        label: 'Projected Performance',
        data: data.map(d => d.projected),
        borderColor: '#4CAF50',
        backgroundColor: 'rgba(76, 175, 80, 0.1)',
        fill: true
      }, {
        label: 'Adjusted Target',
        data: data.map(d => d.target),
        borderColor: '#FF9800',
        backgroundColor: 'rgba(255, 152, 0, 0.1)',
        fill: true
      }]
    };

    if (window.scenarioChartInstance) {
      window.scenarioChartInstance.destroy();
    }

    window.scenarioChartInstance = new Chart(ctx, {
      type: 'line',
      data: chartData,
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'Scenario Projection'
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: function(value) {
                return formatCurrency(value);
              }
            }
          }
        }
      }
    });
  }

  // Enhanced Heat Map with Tooltips and Animations
  function generateHeatMap() {
    console.log('Generating enhanced heat map...');
    const heatmapGrid = document.getElementById('heatmapGrid');
    if (!heatmapGrid) {
      console.error('Heat map grid not found!');
      return;
    }

    heatmapGrid.innerHTML = '';
    console.log('Heat map data:', sumActuals, monthlyTargets);

    // Calculate performance metrics for each month
    const performanceData = [];
    for (let i = 0; i < sumActuals.length; i++) {
      const actual = sumActuals[i];
      const target = monthlyTargets[i];
      const completion = (actual / target) * 100;
      const variance = actual - target;

      performanceData.push({
        month: i + 1,
        completion: completion,
        variance: variance,
        actual: actual,
        target: target
      });
    }

    // Create heat map cells with enhanced tooltips
    performanceData.forEach((data, index) => {
      const cell = document.createElement('div');
      cell.className = 'heatmap-cell';
      cell.style.backgroundColor = getHeatMapColor(data.completion);

      // Add animation delay for staggered effect
      cell.style.animationDelay = `${index * 0.1}s`;

      cell.innerHTML = `
        <div class="cell-month">M${data.month}</div>
        <div class="cell-value">${Math.round(data.completion)}%</div>
        <div class="cell-tooltip">
          <div class="tooltip-header">Month ${data.month} Performance</div>
          <div class="tooltip-content">
            <div class="tooltip-row">
              <span class="tooltip-label">Actual:</span>
              <span class="tooltip-value">${formatCurrency(data.actual)}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Target:</span>
              <span class="tooltip-value">${formatCurrency(data.target)}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Variance:</span>
              <span class="tooltip-value ${data.variance >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.variance)}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">Completion:</span>
              <span class="tooltip-value">${Math.round(data.completion)}%</span>
            </div>
            <div class="tooltip-status">
              Status: <span class="status-text ${getStatusClass(data.completion)}">${getStatusText(data.completion)}</span>
            </div>
          </div>
        </div>
      `;

      // Enhanced click handler with animation
      cell.addEventListener('click', function() {
        // Add click animation
        this.style.transform = 'scale(0.9)';
        setTimeout(() => {
          this.style.transform = '';
        }, 150);

        // Show detailed view
        showHeatMapDetails(data, index);
      });

      // Enhanced tooltip functionality
      let tooltipTimeout;
      cell.addEventListener('mouseenter', function(e) {
        clearTimeout(tooltipTimeout);
        const tooltip = this.querySelector('.cell-tooltip');
        if (tooltip) {
          tooltip.style.display = 'block';
          tooltip.style.opacity = '1';
          tooltip.style.transform = 'translateY(0)';

          // Position tooltip
          const rect = this.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;

          let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
          let top = rect.top - tooltipRect.height - 10;

          // Adjust if tooltip goes off screen
          if (left < 10) left = 10;
          if (left + tooltipRect.width > viewportWidth - 10) {
            left = viewportWidth - tooltipRect.width - 10;
          }
          if (top < 10) {
            top = rect.bottom + 10;
          }

          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
        }
      });

      cell.addEventListener('mouseleave', function() {
        const tooltip = this.querySelector('.cell-tooltip');
        if (tooltip) {
          tooltip.style.opacity = '0';
          tooltipTimeout = setTimeout(() => {
            tooltip.style.display = 'none';
          }, 300);
        }
      });

      heatmapGrid.appendChild(cell);
    });

    // Update timestamp
    const timestamp = document.getElementById('heatmapTimestamp');
    if (timestamp) {
      timestamp.textContent = new Date().toLocaleString('en-GB');
    }
  }

  function getHeatMapColor(completion) {
    if (completion >= 100) return '#4CAF50'; // Green for over target
    if (completion >= 90) return '#8BC34A'; // Light green
    if (completion >= 80) return '#FFC107'; // Yellow
    if (completion >= 70) return '#FF9800'; // Orange
    return '#F44336'; // Red for under 70%
  }

  function showHeatMapDetails(data, index) {
    // Create a detailed view or show additional information
    const details = `
      Month ${data.month} Performance Details:
      • Actual: ${formatCurrency(data.actual)}
      • Target: ${formatCurrency(data.target)}
      • Completion: ${Math.round(data.completion)}%
      • Variance: ${formatCurrency(data.variance)}
      • Status: ${data.completion >= 100 ? 'Over Target' : data.completion >= 90 ? 'Good' : data.completion >= 80 ? 'Moderate' : 'Needs Attention'}
    `;

    // Show details in a toast or alert
    showToast(details, data.completion >= 90 ? 'success' : data.completion >= 80 ? 'info' : 'error');

    // You could also open a detailed modal or highlight the cell
    console.log('Heat map cell clicked:', data);
  }

  function getStatusClass(completion) {
    if (completion >= 100) return 'excellent';
    if (completion >= 90) return 'good';
    if (completion >= 80) return 'moderate';
    if (completion >= 70) return 'concern';
    return 'critical';
  }

  function getStatusText(completion) {
    if (completion >= 100) return 'Excellent (Over Target)';
    if (completion >= 90) return 'Good Performance';
    if (completion >= 80) return 'Moderate Performance';
    if (completion >= 70) return 'Needs Attention';
    return 'Critical (Below 70%)';
  }
})();
</script>
<script>
// Small runtime tweak: improve on-screen clarity for analysis text
(function(){
  try{
    var id = 'repai-on-screen-style';
    if (!document.getElementById(id)){
      var s = document.createElement('style');
      s.id = id;
      s.innerText = '\n#repAIAnalysis { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-weight: 300 !important; transform: translateZ(0); text-rendering: optimizeLegibility; }\n';
      document.head.appendChild(s);
    }
  }catch(e){}
})();
</script>
<script>
// ====== Injected: Multi-section PDF export + clean Print ======
(function(){
  function $(sel){ return document.querySelector(sel); }
  function hasLibs(){
    return (window.html2canvas && window.jspdf && window.jspdf.jsPDF);
  }

  async function addElementToPdfMultiPage(pdf, el, margin){
    margin = margin || 20;
    const canvas = await html2canvas(el, {backgroundColor: '#ffffff', scale: 2});
    const imgData = canvas.toDataURL('image/png');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
  const imgWidth = pageWidth - margin * 2; // margin is provided; ensure callers use larger margin where desired
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
    heightLeft -= (pageHeight - margin * 2);

    while (heightLeft > 0) {
      pdf.addPage();
      position = margin - (imgHeight - heightLeft);
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= (pageHeight - margin * 2);
    }
  }

  
  // Create visible clones for inputs/selects/textareas so html2canvas captures values
  function makeFormClones(root){
    const clones = [];
    const fields = root.querySelectorAll('input, textarea, select');
    fields.forEach(el => {
      let text = '';
      if (el.tagName === 'SELECT') {
        const opt = el.options[el.selectedIndex];
        text = opt ? opt.text : '';
      } else if (el.type === 'date') {
        text = el.value; // as-is (formatted by user)
      } else {
        text = el.value;
      }
      const cs = getComputedStyle(el);
      const span = document.createElement('span');
      span.className = 'exportClone';
      span.textContent = text;
      // basic visual mimic
      span.style.minWidth = el.offsetWidth + 'px';
      span.style.minHeight = el.offsetHeight + 'px';
      span.style.padding = cs.padding;
      span.style.margin = cs.margin;
      span.style.border = cs.border;
      span.style.font = cs.font;
      span.style.lineHeight = cs.lineHeight;
      span.style.textAlign = cs.textAlign;
      span.style.background = cs.backgroundColor;
      span.style.color = cs.color;
      span.style.borderRadius = cs.borderRadius;
      // insert right after the element
      el.insertAdjacentElement('afterend', span);
      clones.push(span);
    });
    document.body.classList.add('__exporting');
    return () => {
      clones.forEach(n => n.remove());
      document.body.classList.remove('__exporting');
    };
  }

  function wirePDFAndPrint(){
    const btnPDF = document.getElementById('btnExportPDF');
    const btnPrint = document.getElementById('btnPrint');
    const ownerNameEl = document.getElementById('ownerNameDisplay');
    const yearInputEl = document.getElementById('yearInput');

    // Remove duplicate PDF event listener - handled by main event listener
    // if (btnPDF) {
    //   btnPDF.addEventListener('click', async () => {
    //     if (!hasLibs()) return alert('PDF libraries not loaded.');
    //     const { jsPDF } = window.jspdf;
    //     const pdf = new jsPDF('p', 'pt', 'a4');
    //     const wrapEl = document.querySelector('.wrap');
    // if (wrapEl) { const undo = makeFormClones(wrapEl); await addElementToPdfMultiPage(pdf, wrapEl, 32); undo(); }
    //     const reportEl = document.getElementById('reportArea');
    //     if (reportEl) {
    //       const prev = reportEl.style.display;
    //       try { if (typeof generateReport === 'function') generateReport(); } catch(e) {}
    //       reportEl.style.display = 'block';
    //       const undoR = makeFormClones(reportEl);
    //       pdf.addPage();
    //       await addElementToPdfMultiPage(pdf, reportEl, 16); // reduced margin for report to show all columns
    //       undoR();
    //       reportEl.style.display = prev || 'none';
    //     }
    //     // --- Robust filename builder ---
    // function __sanitizeOwnerText(txt){
    //   txt = (txt || '').trim();
    //   // Remove vertical bars and surrounding spaces
    //   txt = txt.replace(/\s*\|\s*/g, ' ');
    //   // Remove any 4-digit years (1900-2099) that may be embedded in the owner display
    //   txt = txt.replace(/\b(19|20)\d{2}\b/g, '').trim();
    //   // Collapse multiple spaces
    //   txt = txt.replace(/\s{2,}/g, ' ');
    //   // Replace spaces with underscores
    //   txt = txt.replace(/\s+/g, '_');
    //   // Remove characters unsafe for filenames
    //   txt = txt.replace(/[^A-Za-z0-9_\-]/g, '');
    //   // Collapse multiple underscores
    //   txt = txt.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
    //   return txt || 'Owner';
    // }
    // const rawOwner = elements.ownerNameDisplay?.textContent || 'Owner';
    // const ownerName = __sanitizeOwnerText(rawOwner);
    // const yr = (yearInputEl?.value || new Date().getFullYear());
    // pdf.save(`${ownerName}_${yr}.pdf`);
    //   });
    // }

    if (btnPrint) {
      btnPrint.addEventListener('click', () => {
        const reportEl = document.getElementById('reportArea');
        let revert = false;
        if (reportEl && getComputedStyle(reportEl).display === 'none') {
          reportEl.style.display = 'block';
          revert = true;
        }
        requestAnimationFrame(() => {
          window.print();
          if (revert) reportEl.style.display = 'none';
        });
      });
    }
  }

  // Wait until DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wirePDFAndPrint);
  } else {
    wirePDFAndPrint();
  }
})();
// ====== End Injected ======
</script>
<script>
/* Exact clock-face layout for month numbers (12,1,2,...,11) */
(function(){
  // Optional tiny adjustments (if needed later)
  var X_OFFSET = 0;   // px, + right / - left
  var Y_OFFSET = 7;   // px, + down / - up
  var R_OFFSET = 20;   // px, + outward / - inward
  var FONT_FAMILY = "Poppins, sans-serif";
  var FONT_SIZE = 5; // px

  function drawClockFace(){
    var overlay = document.getElementById("gaugeMonthsOverlay");
    if(!overlay) return;
    var ctx = overlay.getContext("2d");
    if(!ctx) return;

    var w = overlay.width, h = overlay.height;
    var cx = w/2, cy = h/2;
    var padding = 9;
    var baseRadius = (Math.min(w,h)/2 - padding + R_OFFSET) * 1.40;
    var labels = [12,1,2,3,4,5,6,7,8,9,10,11];

    ctx.clearRect(0,0,w,h);
    ctx.save();
    try {
      var color = getComputedStyle(document.body).getPropertyValue('--text').trim();
      ctx.fillStyle = color || "#222";
    } catch(e){ ctx.fillStyle = "#222"; }
    ctx.font = FONT_SIZE + "px " + FONT_FAMILY;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // --- Auto-clamp radius so text never gets clipped ---
    var radius = baseRadius;
    var margin = 6; // keep a little breathing room
    function anyOutOfBounds(r){
      for (var i=0;i<12;i++){
        var angle = (-Math.PI/2) + (i * (Math.PI/6));
        var x = cx + (r * Math.cos(angle)) + X_OFFSET;
        var y = cy + (r * Math.sin(angle)) + Y_OFFSET;
        // Approximate text extents
        var txt = String(labels[i]);
        var wtxt = Math.max(6, ctx.measureText(txt).width);
        var htxt = FONT_SIZE; // rough height
        if (x - wtxt/2 < margin || x + wtxt/2 > (w - margin) ||
            y - htxt/2 < margin || y + htxt/2 > (h - margin)) {
          return true;
        }
      }
      return false;
    }
    var safety = 0;
    while (radius > 4 && anyOutOfBounds(radius) && safety < 200){
      radius -= 0.5; // shrink until all fit
      safety++;
    }

    // Draw with clamped radius
    for (var i=0;i<12;i++){
      var angle = (-Math.PI/2) + (i * (Math.PI/6));
      var x = cx + (radius * Math.cos(angle)) + X_OFFSET;
      var y = cy + (radius * Math.sin(angle)) + Y_OFFSET;
      ctx.fillText(String(labels[i]), x, y);
    }
    ctx.restore();
  }

  function boot(){ try { drawClockFace(); } catch(e){ console.warn(e); } }

  // Draw after page load & on resize
  if (document.readyState === "loading"){
    window.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
  window.addEventListener("resize", boot);

  // Redraw after potential UI actions that affect canvas/theme
  document.addEventListener("click", function(e){
    var id = (e.target && e.target.id) || "";
    if (id === "darkToggle" || id === "monthlyLockToggle" || id === "monthlyLockToggle2"){
      setTimeout(boot, 50);
    }
  });

  // Fallback: if something else repaints, periodically enforce for a short time
  var enforceCount = 0;
  var enforceTimer = setInterval(function(){
    drawClockFace();
    enforceCount++;
    if (enforceCount > 30) clearInterval(enforceTimer);
  }, 150);
})();
</script>
<script>
(function(){
  function px(n){ return n.toString() + "px"; }

  // If it's too wide, shrink; else, gently try to grow up to maxFont (but not exceed original CSS intent)
    var font = Math.min(current, maxFont);
    amount.style.fontSize = px(font);
    var guard = 0;
    if (tooWide()){
      while (font > minFont && tooWide() && guard < 60){
        font -= 0.5;
        amount.style.fontSize = px(font);
        guard++;
      }
    } else {
      while (font < maxFont && !tooWide() && guard < 30){
        font += 0.5;
        amount.style.fontSize = px(font);
        guard++;
        if (tooWide()){ // back off one step if exceeded
          font -= 0.5;
          amount.style.fontSize = px(font);
          break;
        }
      }
    }
  }

  // Refit on load/resize/theme toggles
  function bootFit(){ try {  } catch(e){ console.warn(e); } }
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bootFit);
  } else {
    bootFit();
  }
  window.addEventListener("resize", bootFit);
  document.addEventListener("click", function(e){
    var id = (e.target && e.target.id) || "";
    if (id === "darkToggle" || id === "monthlyLockToggle" || id === "monthlyLockToggle2"){
      setTimeout(bootFit, 50);
    }
  });
})();
</script>
<script>
(function(){
  function getYearFraction(now){
    try {
      var year = now.getFullYear();
      var start = new Date(year, 0, 1, 0, 0, 0, 0);           // Jan 1 local
      var next  = new Date(year + 1, 0, 1, 0, 0, 0, 0);       // Jan 1 of next year
      var frac = (now - start) / (next - start);
      if (!isFinite(frac) || frac < 0) frac = 0;
      if (frac > 1) frac = 1;
      return frac;
    } catch(e){ return 0; }
  }

  function drawYearProgressArc(){
    // The base circle canvas
    var canvas = document.getElementById("gaugeOverlay") || document.getElementById("gaugeBase") || document.getElementById("gaugeCanvas");
    // If no dedicated overlay, try using the same canvas used for the green arc originally
    // or fallback to the months overlay if needed (but prefer not to mix)
    var main = canvas || document.querySelector("canvas#gauge");
    // As a robust fallback, if unavailable, try the months overlay - we will not erase number labels
    var monthsOverlay = document.getElementById("gaugeMonthsOverlay");

    // We need the context that draws the progress ring (green). If we can't reliably find it,
    // we'll create a dedicated overlay on top of the base ring and draw there so we don't disturb labels.
    var overlayId = "gaugeYearProgress";
    var overlay = document.getElementById(overlayId);
    var host = monthsOverlay ? monthsOverlay.parentElement : (canvas ? canvas.parentElement : document.body);
    if (!overlay && host){
      overlay = document.createElement("canvas");
      overlay.id = overlayId;
      overlay.width = monthsOverlay ? monthsOverlay.width : (canvas ? canvas.width : 200);
      overlay.height = monthsOverlay ? monthsOverlay.height : (canvas ? canvas.height : 200);
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.pointerEvents = "none";
      host.appendChild(overlay);
    }
    if (!overlay) return;

    // Size overlay to match months overlay if present
    if (monthsOverlay){
      overlay.width = monthsOverlay.width;
      overlay.height = monthsOverlay.height;
    }

    var ctx = overlay.getContext("2d");
    var w = overlay.width, h = overlay.height;
    var cx = w/2, cy = h/2;
    var padding = 8; // leave room so it doesn't overlap numbers
    var radius = Math.min(w,h)/2 - padding;

    // Clear previous
    ctx.clearRect(0,0,w,h);

    // Background ring (light/neutral)
    ctx.save();
    ctx.lineWidth = 12;
    ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--muted') || "rgba(0,0,0,0.1)";
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // Compute year fraction
    var now = new Date();
    var frac = getYearFraction(now);

    var fracBoost = Math.min(1, frac * 1.20);
// Foreground green arc
    ctx.save();
    ctx.lineWidth = 12;
    // Try to use theme success color if defined
    var themeGreen = getComputedStyle(document.body).getPropertyValue('--success').trim();
    ctx.strokeStyle = themeGreen || "#2ecc71";
    ctx.lineCap = "round";

    var startAngle = -Math.PI/2;            // top (12 o'clock)
    var endAngle = startAngle + fracBoost * Math.PI * 2;

    ctx.beginPath();
    ctx.arc(cx, cy, radius, startAngle, endAngle, false);
    ctx.stroke();
    ctx.restore();
  }

  function boot(){
    drawYearProgressArc();
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }

  window.addEventListener("resize", boot);

  // Re-run at midnight to keep it fresh automatically (and also every 6 hours as a fallback)
  setInterval(boot, 6 * 60 * 60 * 1000);
})();
</script>
<script>
// Neutralize any legacy financial progress arc functions if still present
(function(){
  var nop = function(){};
  ['drawProgress','drawProgressArc','drawFinancialProgress','renderProgress','renderProgressArc'].forEach(function(name){
    try { if (typeof window[name] === 'function') window[name] = nop; } catch(e){}
  });
})();
</script>
<script>
// === Move PDF / Report / Print next to Import/Export toolbar ===
(function(){
  function moveButtons(){
    try{
      var top = document.getElementById('topToolbar');
      if(!top) return;
      var pdf = document.getElementById('btnExportPDF');
      var rep = document.getElementById('btnGenerateReport');
      var prn = document.getElementById('btnPrint');
      // If they currently live under chart header, append them after Excel/Import.
      if (pdf && rep && prn && top && !top.__movedExtras){
        // ensure same visual style (green with black font)
        [pdf,rep,prn].forEach(function(b){
          b.classList.add('small');
          b.style.background = 'var(--very-light-green)';
          b.style.color = 'var(--text-bold)';
          b.style.border = '1px solid rgba(111,174,117,0.2)';
        });

        // append after existing toolbar buttons
        top.appendChild(pdf);
        top.appendChild(rep);
        top.appendChild(prn);
        top.__movedExtras = true;
      }
    }catch(e){ console.warn('moveButtons err', e); }
  }
  document.addEventListener('DOMContentLoaded', moveButtons);
})();
</script>
<script>
// === Fancy Year Toggle + Show-All-by-default enforcement (additive, safe) ===
(function(){
  function byId(id){ return document.getElementById(id); }
  function setYearFancy(y){
    var yEl = byId('yearFancy');
    if(yEl) yEl.textContent = String(y);
  }
  function setYearInput(y){
    var inp = byId('yearInput');
    if(!inp) return;
    // Clamp between 2000 and 2100
    y = Math.min(2100, Math.max(2000, parseInt(y, 10) || new Date().getFullYear()));
    if(String(inp.value) !== String(y)) {
      inp.value = y;
      // Trigger any listeners attached in the original script
      var ev = new Event('change', {bubbles: true});
      inp.dispatchEvent(ev);
      // Some pages used input instead of change
      var ev2 = new Event('input', {bubbles: true});
      inp.dispatchEvent(ev2);
    }
    setYearFancy(y);
  }

  function initFancyYear(){
    var yearInput = byId('yearInput');
    if(!yearInput) return;
    // Initial sync
    var initial = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10);
    if(!initial) initial = new Date().getFullYear();
    setYearFancy(initial);

    // Keep fancy label in sync when typing
    ['change','input'].forEach(function(t){
      yearInput.addEventListener(t, function(e){
        var v = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10);
        if(!v) v = new Date().getFullYear();
        setYearFancy(v);
      });
    });

    // Star button to toggle year up/down (Shift+click = prev)
    // Disabled duplicate star click handler to prevent double-year increments
/* \1 */

  function enforceChartShowAll(){
    try {
      var btnAll = document.getElementById('btnToggleAll');
      if(btnAll){
        // Click twice to be extra sure (some UIs toggle states)
        btnAll.click();
        setTimeout(function(){ try{ btnAll.click(); }catch(e){} }, 10);
      }
      // If the original script uses a flag, try to flip it here too
      if (typeof window.showUpcomingOnly !== 'undefined') {
        window.showUpcomingOnly = false;
      }
    } catch(e){ console.warn('enforceChartShowAll:', e); }
  }

  // Delay until DOM + original scripts have had a chance to wire listeners
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      setTimeout(function(){
        initFancyYear();
        enforceChartShowAll();
      }, 0);
    });
  } else {
    setTimeout(function(){
      initFancyYear();
      enforceChartShowAll();
    }, 0);
  }
})();
</script>
<script>
(function(){
  function byId(id){ return document.getElementById(id); }
  function setYearFancy(y){
    var yEl = byId('yearFancy');
    if(yEl) yEl.textContent = String(y);
  }
  function setYearInput(y){
    var inp = byId('yearInput');
    if(!inp) return;
    y = Math.min(2100, Math.max(2000, parseInt(y, 10) || new Date().getFullYear()));
    if(String(inp.value) !== String(y)) {
      inp.value = y;
      var ev = new Event('change', {bubbles: true});
      inp.dispatchEvent(ev);
      var ev2 = new Event('input', {bubbles: true});
      inp.dispatchEvent(ev2);
    }
    setYearFancy(y);
  }

  function initEnhancedYearControls(){
    var yearInput = byId('yearInput');
    if(!yearInput) return;

    var current = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10);
    if(!current) current = new Date().getFullYear();
    setYearFancy(current);

    // Keep fancy label in sync
    ['change','input'].forEach(function(t){
      yearInput.addEventListener(t, function(){
        var v = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10) || new Date().getFullYear();
        setYearFancy(v);
      });
    });

    // Buttons
    var btnNext = byId('yearToggleBtn');
    var btnPrev = byId('yearPrevBtn');

    if(btnNext){
      // Click -> next; Shift/Ctrl/Alt-Click OR Double-Click -> prev (extra safety)
      btnNext.addEventListener('click', function(e){
        var cur = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10) || new Date().getFullYear();
        if (e.shiftKey || e.ctrlKey || e.altKey) {
          setYearInput(cur - 1);
        } else {
          setYearInput(cur + 1);
        }
      });
      btnNext.addEventListener('dblclick', function(e){
        var cur = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10) || new Date().getFullYear();
        setYearInput(cur - 1);
      });
    }
    if(btnPrev){
      btnPrev.addEventListener('click', function(){
        var cur = parseInt(yearInput.value || (window.currentYear || new Date().getFullYear()), 10) || new Date().getFullYear();
        setYearInput(cur - 1);
      });
    }

    // Keyboard on the year label
    var yEl = byId('yearFancy');
    if(yEl){
      yEl.addEventListener('keydown', function(e){
        if(e.key === 'ArrowRight'){ setYearInput((parseInt(yearInput.value,10)||new Date().getFullYear()) + 1); }
        if(e.key === 'ArrowLeft'){ setYearInput((parseInt(yearInput.value,10)||new Date().getFullYear()) - 1); }
        if(e.key === 'Home'){ setYearInput(new Date().getFullYear()); }
      });
      yEl.title = "Click ☆ for previous, ★ for next • Arrow keys to navigate • Home to jump to current year";
    }
  }

  function ensureAllMonthsShown(){
    try {
      var btnAll = document.getElementById('btnToggleAll');
      if(btnAll){ btnAll.click(); setTimeout(function(){ try{ btnAll.click(); }catch(e){} }, 10); }
      if (typeof window.showUpcomingOnly !== 'undefined') window.showUpcomingOnly = false;
    } catch(e){}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      setTimeout(function(){
        initEnhancedYearControls();
        ensureAllMonthsShown();
      }, 0);
    });
  } else {
    setTimeout(function(){
      initEnhancedYearControls();
      ensureAllMonthsShown();
    }, 0);
  }
})();
</script>
<script>
// Ensure "Monthly Performance 📈" shows Actual, Target, and other series by DEFAULT.
(function(){
  function showAllDatasets(){
    try {
      // Support Chart.js v3/v4 differences
      if (window.Chart) {
        // v4 keeps a Map of instances; v3 had an array.
        var instances = window.Chart.instances || window.Chart._instances || [];
        var charts = [];
        if (instances instanceof Map) {
          charts = Array.from(instances.values());
        } else if (Array.isArray(instances)) {
          charts = instances;
        } else if (typeof instances === 'object') {
          charts = Object.values(instances);
        }
        charts.forEach(function(ch){
          try{
            // Skip non-Monthly charts if canvas label hints exist
            var id = (ch.canvas && ch.canvas.id) ? ch.canvas.id.toLowerCase() : '';
            var title = (ch.config && ch.config.options && ch.config.options.plugins && ch.config.options.plugins.title && ch.config.options.plugins.title.text) || '';
            var isMonthly = /monthly|performance/i.test(id) || /monthly|performance/i.test(String(title));
            if(!isMonthly) return;

            if (ch.data && Array.isArray(ch.data.datasets)) {
              ch.data.datasets.forEach(function(ds){ ds.hidden = false; });
              ch.update();
            }
          }catch(e){}
        });
      }
    } catch(e) { console.warn('showAllDatasets error:', e); }
  }

  function flipUITogglesOn(){
    try {
      // Common checkbox ids/classes used for series toggles
      var selectors = [
        '#toggleActual', '#toggleTarget', '#toggleShortage', '#toggleRemaining',
        '.series-toggle', 'input[name*=series]', 'input[data-series]', 'button[data-series]'
      ];
      selectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try{
            // If it's a checkbox or switch
            if (el.type === 'checkbox' || el.getAttribute('role') === 'switch') {
              if (!el.checked) {
                el.checked = true;
                el.dispatchEvent(new Event('change', {bubbles:true}));
                el.dispatchEvent(new Event('input', {bubbles:true}));
              }
            } else if (el.tagName === 'BUTTON') {
              // Heuristic: buttons toggling 'active' state
              if (!el.classList.contains('active')) {
                // click once to turn on
                el.click();
              }
            }
          }catch(e){}
        });
      });
    } catch(e){ console.warn('flipUITogglesOn error:', e); }
  }

  function runAll(){
    showAllDatasets();
    flipUITogglesOn();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      // Run immediately, then after a short delay (to catch charts that init late)
      runAll();
      setTimeout(runAll, 120);
      setTimeout(runAll, 400);
    });
  } else {
    runAll();
    setTimeout(runAll, 120);
    setTimeout(runAll, 400);
  }
})();
</script>
<script>
(function(){
  // Utility: copy text to clipboard
  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      toast('Copied summary to clipboard ✅');
    }catch(e){
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      toast('Copied summary to clipboard ✅');
    }
  }

  // Utility: make PNG from an element via html2canvas
  async function saveElementPNG(el, filename){
    if (!window.html2canvas){
      alert('html2canvas is required for chart export.');
      return;
    }
    // Enter pdf-mode-like stabilization for consistent layout
    document.body.classList.add('pdf-mode');
    await new Promise(r => setTimeout(r, 50));
    const canvas = await html2canvas(el, {backgroundColor: '#ffffff', scale: 2});
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(()=>document.body.classList.remove('pdf-mode'), 100);
    toast('Saved PNG ✅');
  }

  // Tiny toast
  function toast(msg){
    try{
      var t = document.createElement('div');
      t.textContent = msg;
      t.style.position = 'fixed';
      t.style.bottom = '20px';
      t.style.left = '50%';
      t.style.transform = 'translateX(-50%)';
      t.style.background = 'rgba(0,0,0,0.8)';
      t.style.color = '#fff';
      t.style.padding = '8px 12px';
      t.style.borderRadius = '10px';
      t.style.zIndex = 9999;
      document.body.appendChild(t);
      setTimeout(()=>{ t.remove(); }, 1400);
    }catch(e){}
  }

  // Build WhatsApp-friendly text summary from current UI
  function buildWhatsAppSummary(){
    try{
      var ownerSel = document.getElementById('ownerSelect');
      var ownerName = ownerSel ? (ownerSel.options[ownerSel.selectedIndex]?.text || ownerSel.value) : (window.currentOwner || '—');
      var year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());

      var target = document.getElementById('dashYearlyTarget')?.textContent?.trim() || '0';
      var ytd = document.getElementById('dashYtdAccomplished')?.textContent?.trim() || '0';
      var remaining = document.getElementById('dashRemaining')?.textContent?.trim() || '0';

      // Next needed (if visible in ribbon)
      var nextMonth = document.getElementById('nextMonthPill')?.textContent?.trim();
      var nextAmount = document.getElementById('nextAmount')?.textContent?.trim();
      var nextDays = document.getElementById('nextDays')?.textContent?.trim();
      var nextLine = '';
      if (nextMonth && nextAmount){
        nextLine = `${nextMonth} — ${nextAmount}${nextDays ? ' ('+nextDays+')' : ''}`;
      }

      // Next Year Preview small line
      var tiny = document.getElementById('nextJanTiny');
      var nyLine = tiny ? tiny.textContent.trim() : '';

      // Assemble
      const msg = [
        `📊 ENBD Tracker — ${year} | Owner: ${ownerName}`,
        `🎯 Target: ${target} AED`,
        `💰 YTD Actual Inflow: ${ytd} AED`,
        `📉 Remaining: ${remaining} AED`,
        nextLine || '',
        nyLine ? ('🔮 ' + nyLine) : ''
      ].filter(Boolean).join('\n');
      return msg;
    }catch(e){
      return '📊 ENBD Tracker — Summary unavailable';
    }
  }

  // Find likely monthly chart and gauge elements
  function getMonthlyChartElement(){
    // Prefer a canvas with id including "monthly" or "performance"
    var c = document.querySelector('canvas[id*="monthly"], canvas[id*="performance"]');
    if (c) return c.parentElement || c;
    // Fallback: a chart container class
    var d = document.querySelector('.monthly-chart, .chart-area, #monthlyChartContainer');
    return d || document.body;
  }
  function getYearlyCircleElement(){
    // The gauge wrapper should exist
    var g = document.querySelector('.gaugeWrapper') || document.getElementById('gaugeContainer') || document.getElementById('gauge');
    return g || document.body;
  }

  function wireShareMenu(){
    var btn = document.getElementById('btnShareWhatsApp');
    var menu = document.getElementById('shareDropdown');
    if (!btn || !menu) return;

    // Toggle dropdown
    btn.addEventListener('click', function(e){
      e.stopPropagation();
      menu.style.display = (menu.style.display === 'none' || !menu.style.display) ? 'block' : 'none';
    });
    // Close when clicking elsewhere
    document.addEventListener('click', function(){
      if (menu.style.display === 'block') menu.style.display = 'none';
    });

    // Actions
    menu.querySelectorAll('.shareAction').forEach(function(item){
      item.addEventListener('click', async function(e){
        var action = this.getAttribute('data-action');
        menu.style.display = 'none';
        if (action === 'text'){
          const msg = buildWhatsAppSummary();
          await copyToClipboard(msg);
        } else if (action === 'monthly'){
          const el = getMonthlyChartElement();
          await saveElementPNG(el, 'Monthly_Performance.png');
        } else if (action === 'yearly'){
          const el = getYearlyCircleElement();
          await saveElementPNG(el, 'Year_Progress.png');
        }
      });
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wireShareMenu);
  } else {
    wireShareMenu();
  }
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }

  function makeShareMenu(){
    var wrap = document.createElement('div');
    wrap.className = 'shareMenuWrapper';
    wrap.style.position = 'relative';
    wrap.style.display = 'inline-block';
    wrap.style.marginLeft = '8px';
    wrap.innerHTML = '<button id="btnShareWhatsApp" class="ghost small" title="Share to WhatsApp" style="display:inline-flex;align-items:center;gap:6px;">📲 Share <span style="font-size: 13px;">▾</span></button>' +
                     '<div id="shareDropdown" class="shadow" style="display:none;position:absolute;left:50%;transform:translateX(-50%);top:110%;background:var(--card);border:1px solid rgba(0,0,0,0.08);border-radius:10px;padding:4px;min-width:180px;max-width:200px;z-index:999;">' +
                     '<button class="shareAction" data-action="text" style="width:100%;text-align:left;padding:8px;border:none;background:none;cursor:pointer;">📝 Share Text (copy)</button>' +
                     '<button class="shareAction" data-action="monthly" style="width:100%;text-align:left;padding:8px;border:none;background:none;cursor:pointer;">📈 Share Monthly Chart (PNG)</button>' +
                     '<button class="shareAction" data-action="yearly" style="width:100%;text-align:left;padding:8px;border:none;background:none;cursor:pointer;">📅 Share Yearly Circle (PNG)</button>' +
                     '</div>';
    return wrap;
  }

  // Helpers (scoped; no global pollution)
  async function copyToClipboard(text){
    try{ await navigator.clipboard.writeText(text); toast('Copied summary to clipboard ✅'); }
    catch(e){
      const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); ta.remove(); toast('Copied summary to clipboard ✅');
    }
  }
  async function saveElementPNG(el, filename){
    if (!window.html2canvas){ alert('html2canvas is required for chart export.'); return; }
    document.body.classList.add('pdf-mode'); await new Promise(r=>setTimeout(r,60));
    const canvas = await html2canvas(el, {backgroundColor: '#ffffff', scale: 2});
    const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = filename;
    document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>document.body.classList.remove('pdf-mode'), 80);
    toast('Saved PNG ✅');
  }
  function toast(msg){
    var t=document.createElement('div'); t.textContent=msg; t.style.position='fixed'; t.style.bottom='20px'; t.style.left='50%';
    t.style.transform='translateX(-50%)'; t.style.background='rgba(0,0,0,0.8)'; t.style.color='#fff'; t.style.padding='8px 12px';
    t.style.borderRadius='10px'; t.style.zIndex=9999; document.body.appendChild(t); setTimeout(()=>t.remove(), 1400);
  }
  function monthName(i){ return (window.monthName ? window.monthName(i) : ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || '—'); }
  function buildWhatsAppSummary(){
    try{
      var ownerSel = document.getElementById('ownerSelect');
      var ownerName = ownerSel ? (ownerSel.options[ownerSel.selectedIndex]?.text || ownerSel.value) : (window.currentOwner || '—');
      var year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());
      var target = (document.getElementById('dashYearlyTarget')?.textContent || '0').trim();
      var ytd = (document.getElementById('dashYtdAccomplished')?.textContent || '0').trim();
      var remaining = (document.getElementById('dashRemaining')?.textContent || '0').trim();
      var nextMonth = document.getElementById('nextMonthPill')?.textContent?.trim();
      var nextAmount = document.getElementById('nextAmount')?.textContent?.trim();
      var nextDays = document.getElementById('nextDays')?.textContent?.trim();
      var nextLine = (nextMonth && nextAmount) ? `${nextMonth} — ${nextAmount}${nextDays ? ' ('+nextDays+')' : ''}` : '';
      var tiny = document.getElementById('nextJanTiny');
      var nyLine = tiny ? tiny.textContent.trim() : '';
      return [
        `📊 ENBD Tracker — ${year} | Owner: ${ownerName}`,
        `🎯 Target: ${target} AED`,
        `💰 YTD Actual Inflow: ${ytd} AED`,
        `📉 Remaining: ${remaining} AED`,
        nextLine || '',
        nyLine ? ('🔮 ' + nyLine) : ''
      ].filter(Boolean).join('\\n');
    }catch(e){ return '📊 ENBD Tracker — Summary unavailable'; }
  }
  function getMonthlyChartElement(){
    var c = document.querySelector('#performanceChart, canvas[id*="monthly"], canvas[id*="performance"]');
    return (c && c.parentElement) ? c.parentElement : (document.querySelector('.monthly-chart, .chart-area, #monthlyChartContainer') || document.body);
  }
  function getYearlyCircleElement(){
    return document.querySelector('.gaugeWrapper') || document.getElementById('gaugeContainer') || document.getElementById('gauge') || document.body;
  }

  ready(function(){
    // Find the second toolbar (PDF/Print row)
    var printBtn = document.getElementById('btnPrint');
    if (!printBtn){ return; }
    var row = printBtn.parentElement; // container with PDF/Print
    if (!row){ return; }

    // If a previous share exists, remove it to avoid duplicates
    var old = row.querySelector('.shareMenuWrapper');
    if (old) old.remove();

    var menu = makeShareMenu();
    row.appendChild(menu);

    // Wire dropdown toggle — ensure dropdown is rendered on <body> with fixed positioning
    var btn = menu.querySelector('#btnShareWhatsApp');
    var dd = menu.querySelector('#shareDropdown');

    // position and show dropdown as fixed element appended to body so it won't be clipped
    function positionShareDropdown(){
      try{
        if (!dd || !btn) return;
        // move dropdown to body to avoid overflow/clipping from parent stacks
        if (dd.parentElement !== document.body) document.body.appendChild(dd);
        dd.style.position = 'fixed';
        var rect = btn.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top = rect.bottom + 8; // small gap below button
        dd.style.left = left + 'px';
        dd.style.top = top + 'px';
        dd.style.transform = 'translateX(-50%)';
        dd.style.zIndex = '2147483647';
        dd.style.display = 'block';
        // ensure sensible sizing
        dd.style.minWidth = dd.style.minWidth || '180px';
        dd.style.maxWidth = dd.style.maxWidth || '420px';
      }catch(e){ console.warn('positionShareDropdown failed', e); }
    }

    function hideShareDropdown(){ try{ if (!dd) return; dd.style.display = 'none'; }catch(e){}
    }

    btn.addEventListener('click', function(e){
      e.stopPropagation();
      if (!dd) return;
      if (dd.style.display === 'block') hideShareDropdown();
      else positionShareDropdown();
    });

    // close on outside click
    document.addEventListener('click', function(){ if (dd && dd.style.display === 'block') hideShareDropdown(); });

    // reposition if page moves or resizes
    window.addEventListener('resize', function(){ if (dd && dd.style.display === 'block') positionShareDropdown(); });
    window.addEventListener('scroll', function(){ if (dd && dd.style.display === 'block') positionShareDropdown(); }, true);

    // Wire actions
    dd.querySelectorAll('.shareAction').forEach(function(a){
      a.addEventListener('click', async function(){
        dd.style.display='none';
        var act = this.getAttribute('data-action');
        if (act==='text'){ await copyToClipboard(buildWhatsAppSummary()); }
        if (act==='monthly'){ await saveElementPNG(getMonthlyChartElement(), 'Monthly_Performance.png'); }
        if (act==='yearly'){ await saveElementPNG(getYearlyCircleElement(), 'Year_Progress.png'); }
      });
    });
  });
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }

  // Minimal encode for WhatsApp (preserve line breaks)
  function encodeForWA(text){
    return encodeURIComponent(text).replace(/%0A/g, '%0A');
  }

  function buildSummaryParts(){
    var ownerSel = document.getElementById('ownerSelect');
    var ownerName = ownerSel ? (ownerSel.options[ownerSel.selectedIndex]?.text || ownerSel.value) : (window.currentOwner || '—');
    var year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());
    var target = (document.getElementById('dashYearlyTarget')?.textContent || '0').trim();
    var ytd = (document.getElementById('dashYtdAccomplished')?.textContent || '0').trim();
    var remaining = (document.getElementById('dashRemaining')?.textContent || '0').trim();
    var nextMonth = document.getElementById('nextMonthPill')?.textContent?.trim();
    var nextAmount = document.getElementById('nextAmount')?.textContent?.trim();
    var nextDays = document.getElementById('nextDays')?.textContent?.trim();
    var nextLine = (nextMonth && nextAmount) ? `${nextMonth} — ${nextAmount}${nextDays ? ' ('+nextDays+')' : ''}` : '';
    var tiny = document.getElementById('nextJanTiny');
    var nyLine = tiny ? tiny.textContent.trim() : '';
    return { ownerName, year, target, ytd, remaining, nextLine, nyLine };
  }

  function buildText(brief=true){
    const p = buildSummaryParts();
    if (brief){
      return [
        `📊 *ENBD Tracker* — *${p.year}* | *Owner:* ${p.ownerName}`,
        `🎯 *Target:* ${p.target} AED`,
        `💰 *YTD:* ${p.ytd} AED`,
        `📉 *Remaining:* ${p.remaining} AED`,
        p.nextLine || '',
        p.nyLine ? ('🔮 ' + p.nyLine) : ''
      ].filter(Boolean).join('\\n');
    } else {
      // detailed
      return [
        `📊 *ENBD Performance Summary*`,
        `*Owner:* ${p.ownerName}`,
        `*Year:* ${p.year}`,
        `🎯 *Early Target:* ${p.target} AED`,
        `💰 *YTD Actual Inflow:* ${p.ytd} AED`,
        `📉 *Remaining:* ${p.remaining} AED`,
        p.nextLine ? (`${p.nextLine}`) : '',
        p.nyLine ? (`🔮 *Next Year Preview:* ${p.nyLine.replace('- ','')}`) : ''
      ].filter(Boolean).join('\\n');
    }
  }

  async function copyText(brief=true){
    const msg = buildText(brief);
    try{ await navigator.clipboard.writeText(msg); toast('Copied to clipboard ✅'); }
    catch(e){
      const ta=document.createElement('textarea'); ta.value=msg; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); ta.remove(); toast('Copied to clipboard ✅');
    }
  }

  function openWhatsAppWeb(brief=true, number=null){
    const msg = buildText(brief);
    const base = 'https://wa.me/';
    const path = number ? (String(number).replace(/\D/g,'')) + '?text=' : '?text=';
    const url = base + path + encodeForWA(msg);
    window.open(url, '_blank', 'noopener');
  }

  async function sharePack(){
    // Copy brief text and save monthly chart PNG
    await copyText(true);
    const el = getMonthlyChartElement();
    await saveElementPNG(el, 'Monthly_Performance.png');
  }

  // existing helpers from v25 or define local ones
  function getMonthlyChartElement(){
    var c = document.querySelector('#performanceChart, canvas[id*="monthly"], canvas[id*="performance"]');
    return (c && c.parentElement) ? c.parentElement : (document.querySelector('.monthly-chart, .chart-area, #monthlyChartContainer') || document.body);
  }
  async function saveElementPNG(el, filename){
    if (!window.html2canvas){ alert('html2canvas is required for chart export.'); return; }
    document.body.classList.add('pdf-mode'); await new Promise(r=>setTimeout(r,60));
    const canvas = await html2canvas(el, {backgroundColor: '#ffffff', scale: 2});
    const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = filename;
    document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>document.body.classList.remove('pdf-mode'), 80);
    toast('Saved PNG ✅');
  }
  function toast(msg){
    var t=document.createElement('div'); t.textContent=msg; t.style.position='fixed'; t.style.bottom='20px'; t.style.left='50%';
    t.style.transform='translateX(-50%)'; t.style.background='rgba(0,0,0,0.8)'; t.style.color='#fff'; t.style.padding='8px 12px';
    t.style.borderRadius='10px'; t.style.zIndex=9999; document.body.appendChild(t); setTimeout(()=>t.remove(), 1400);
  }

  ready(function(){
    // Locate existing Share menu; add more actions
    var printBtn = document.getElementById('btnPrint');
    if (!printBtn) return;
    var row = printBtn.parentElement;
    var menuWrap = row && row.querySelector('.shareMenuWrapper');
    if (!menuWrap) return;
    var dropdown = menuWrap.querySelector('#shareDropdown');
    if (!dropdown) return;

    // Clear and rebuild with only Overview text (per user request - removed Send to Number)
    dropdown.innerHTML = ''
      + '<button class="shareAction" data-action="overview-text" style="width:100%;text-align:left;padding:8px;border:none;background:none;cursor:pointer;">🧩 Share Overview (text)</button>';

    dropdown.querySelectorAll('.shareAction').forEach(function(a){
      a.addEventListener('click', async function(){
        dropdown.style.display='none';
        var act = this.getAttribute('data-action');
        if (act === 'overview-text'){
          // copy overview text to clipboard
          try{ await navigator.clipboard.writeText(buildOverviewText()); toast('Overview copied to clipboard ✅'); }
          catch(e){ /* ignore */ }
        }
      });
    });
  });
})();
</script>
<script>
(function(){
  function ready(fn){ if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }

  // Helper to locate a good "overview" section in DOM, or build a temporary one
  
function getOverviewElementOrBuild(){
    // Try common containers around KPI cards
    var ids = ['dashYearlyTarget','dashYtdAccomplished','dashRemaining','gaugeContainer','gauge','gaugeWrapper','nextContainer','topToolbar'];
    var anchors = ids.map(id => document.getElementById(id)).filter(Boolean);
    if (anchors.length){
      // Choose a top-level common ancestor
      var common = anchors[0];
      function getChain(el){
        var chain=[]; while (el){ chain.push(el); el = el.parentElement; } return chain;
      }
      var chain0 = getChain(anchors[0]);
      for (var i=1;i<anchors.length;i++){
        var chainI = getChain(anchors[i]);
        common = chain0.find(n => chainI.includes(n)) || common;
        chain0 = getChain(common);
      }
      // Build a compact overview card
      var box = document.createElement('div');
      box.style.padding = '14px';
      box.style.background = getComputedStyle(document.body).getPropertyValue('--card') || '#fff';
      box.style.border = '1px solid rgba(0,0,0,0.08)';
      box.style.borderRadius = '12px';
      box.style.maxWidth = '980px';
      box.style.color = getComputedStyle(document.body).getPropertyValue('--text') || '#111';

      // Header with logo + title
      var header = document.createElement('div');
      header.style.display='grid';
      header.style.gridTemplateColumns='44px 1fr';
      header.style.gap='10px';
      header.style.alignItems='center';
      header.style.marginBottom='10px';

      // Logo (optional)
      var logoWrap = document.createElement('div');
      logoWrap.style.width='44px'; logoWrap.style.height='44px';
      logoWrap.style.borderRadius='8px'; logoWrap.style.overflow='hidden';
      logoWrap.style.border='1px solid rgba(0,0,0,0.06)';
      var logoURL = (window.brandLogoURL || null);
      var logoImg = null;
      try {
        var existingLogo = document.getElementById('brandLogo');
        if (existingLogo && existingLogo.tagName === 'IMG') { logoURL = existingLogo.src; }
      } catch(e){}
      if (logoURL){
        logoImg = document.createElement('img');
        logoImg.src = logoURL;
        logoImg.alt = 'Logo';
        logoImg.style.width='100%';
        logoImg.style.height='100%';
        logoImg.style.objectFit='cover';
        logoWrap.appendChild(logoImg);
      } else {
        // subtle placeholder
        var ph = document.createElement('div');
        ph.style.width='100%'; ph.style.height='100%';
        ph.style.background='linear-gradient(135deg, rgba(0,0,0,0.04), rgba(0,0,0,0.02))';
        logoWrap.appendChild(ph);
      }

      // Title (Owner + Year)
      var title = document.createElement('div');
      var ownerSel = document.getElementById('ownerSelect');
      var ownerName = ownerSel ? (ownerSel.options[ownerSel.selectedIndex]?.text || ownerSel.value) : (window.currentOwner || '—');
      var year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear());
      var big = document.createElement('div');
      big.textContent = `ENBD — ${year} | Owner: ${ownerName}`;
      big.style.fontSize='16px'; big.style.fontWeight='700';
      var small = document.createElement('div');
      small.textContent = 'Overview Snapshot';
      small.style.fontSize='12px'; small.style.opacity='0.95';
      title.appendChild(big); title.appendChild(small);

      header.appendChild(logoWrap);
      header.appendChild(title);
      box.appendChild(header);

      // KPI row
      var kpiRow = document.createElement('div');
      kpiRow.style.display = 'grid';
      kpiRow.style.gridTemplateColumns = 'repeat(3, 1fr)';
      kpiRow.style.gap = '10px';
      function card(label, value){
        var wrap = document.createElement('div');
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.border = '1px solid rgba(0,0,0,0.06)';
        wrap.style.background = 'var(--card)';
        var t = document.createElement('div');
        t.textContent = label;
        t.style.fontSize = '12px'; t.style.opacity = '0.95';
        var v = document.createElement('div');
        v.textContent = value;
        v.style.fontSize = '20px'; v.style.fontWeight = '700';
        wrap.appendChild(t); wrap.appendChild(v);
        return wrap;
      }
      var tgt = (document.getElementById('dashYearlyTarget')?.textContent || '0').trim();
      var ytd = (document.getElementById('dashYtdAccomplished')?.textContent || '0').trim();
      var rem = (document.getElementById('dashRemaining')?.textContent || '0').trim();
      kpiRow.appendChild(card('Early Target 🎯', `${tgt} AED`));
      kpiRow.appendChild(card('YTD Actual Inflow 💰', `${ytd} AED`));
      kpiRow.appendChild(card('Remaining 📉', `${rem} AED`));
      box.appendChild(kpiRow);

      // Middle row: Year Progress + Next Needed / Next Year
      var mid = document.createElement('div');
      mid.style.display = 'grid';
      mid.style.gridTemplateColumns = '360px 1fr';
      mid.style.gap = '12px';
      mid.style.marginTop = '12px';

      var gaugeWrap = document.createElement('div');
      var gaugeSrc = document.querySelector('.gaugeWrapper') || document.getElementById('gaugeContainer') || document.getElementById('gauge');
      if (gaugeSrc){
        var clone = gaugeSrc.cloneNode(true);
        clone.style.transform = 'scale(0.94)';
        clone.style.transformOrigin = 'top left';
        clone.style.width = getComputedStyle(gaugeSrc).width;
        gaugeWrap.appendChild(clone);
      } else {
        var placeholder = document.createElement('div');
        placeholder.textContent = 'Year Progress 📅';
        placeholder.style.padding = '20px';
        placeholder.style.border = '1px dashed rgba(0,0,0,0.2)';
        placeholder.style.borderRadius = '10px';
        gaugeWrap.appendChild(placeholder);
      }

      var info = document.createElement('div');
      info.style.display = 'grid';
      info.style.gridTemplateRows = 'auto auto';
      info.style.gap = '8px';

      var nextBlock = document.createElement('div');
      nextBlock.style.padding = '10px';
      nextBlock.style.borderRadius = '10px';
      nextBlock.style.border = '1px solid rgba(0,0,0,0.06)';
      nextBlock.style.background = 'var(--card)';
      var nextTitle = document.createElement('div');
      nextTitle.textContent = 'Next needed 🚀';
      nextTitle.style.fontSize='12px'; nextTitle.style.opacity='0.95';
      var nextLine = document.createElement('div');
      var nm = document.getElementById('nextMonthPill')?.textContent?.trim();
      var na = document.getElementById('nextText')?.textContent?.trim();
      var nd = document.getElementById('nextDays')?.textContent?.trim();
      nextLine.textContent = (nm && na) ? `${nm} — ${na}${nd ? ' ('+nd+')' : ''}` : '—';
      nextLine.style.fontSize = '16px'; nextLine.style.fontWeight = '600';
      nextBlock.appendChild(nextTitle); nextBlock.appendChild(nextLine);

      var tinyLine = document.createElement('div');
      tinyLine.style.padding = '10px';
      tinyLine.style.borderRadius = '10px';
      tinyLine.style.border = '1px solid rgba(0,0,0,0.06)';
      tinyLine.style.background = 'var(--card)';
      var tinyTxt = document.getElementById('nextJanTiny')?.innerHTML || '';
      tinyLine.innerHTML = tinyTxt ? ('🔮 ' + tinyTxt) : '🔮 —';

      info.appendChild(nextBlock);
      info.appendChild(tinyLine);

      mid.appendChild(gaugeWrap);
      mid.appendChild(info);
      box.appendChild(mid);

      return { element: box, cleanup: function(){ box.remove(); } };
    }
    // Final fallback: entire body (not ideal)
    return { element: document.body, cleanup: function(){} };
}
function buildOverviewText(){
    // Concise, ordered: Target, YTD, Remaining, Next needed, Next Year
    var target = (document.getElementById('dashYearlyTarget')?.textContent || '0').trim();
    var ytd = (document.getElementById('dashYtdAccomplished')?.textContent || '0').trim();
    var remaining = (document.getElementById('dashRemaining')?.textContent || '0').trim();
    var nm = document.getElementById('nextMonthPill')?.textContent?.trim();
    var na = document.getElementById('nextAmount')?.textContent?.trim();
    var nd = document.getElementById('nextDays')?.textContent?.trim();
    var next = (nm && na) ? `${nm} — ${na}${nd ? ' ('+nd+')' : ''}` : '';
    var tiny = document.getElementById('nextJanTiny')?.textContent?.trim();
    var nextY = tiny ? ('🔮 ' + tiny) : '';
    return [
      `🎯 Target: ${target} AED`,
      `💰 YTD: ${ytd} AED`,
      `📉 Remaining: ${remaining} AED`,
      next,
      nextY
    ].filter(Boolean).join('\\n');
  }

  async function ensureHtml2Canvas(){
    if (window.html2canvas) return window.html2canvas;
    return new Promise((resolve, reject) => {
      var s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
      s.onload = () => { resolve(window.html2canvas); };
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  async function saveOverviewPNG(){
    try{ if (!window.html2canvas) await ensureHtml2Canvas(); }
    catch(e){ alert('Failed to load html2canvas. Please check your connection.'); return; }

    // Gather values (enhanced fallbacks and calculations)
    var owner = (document.getElementById('ownerNameDisplay')?.textContent || window.currentOwner || '—').trim();
    var year = (document.getElementById('yearFancy')?.textContent || document.getElementById('yearInput')?.value || window.currentYear || new Date().getFullYear()).toString();
    var target = (document.getElementById('dashYearlyTarget')?.textContent || '0').trim();
    var ytd = (document.getElementById('dashYtdAccomplished')?.textContent || '0').trim();
    var remaining = (document.getElementById('dashRemaining')?.textContent || '0').trim();
    var opening = (document.getElementById('dashOpeningBalance')?.textContent || '0').trim();
    var avgTarget = (document.getElementById('repAvgMonthlyTarget')?.textContent || document.getElementById('kpiVal_avgMonthly')?.textContent || '').trim();
    var avgInflow = (document.getElementById('repAvgMonthlyInflow')?.textContent || document.getElementById('kpiVal_avgActualMonthly')?.textContent || '').trim();
    
    // Enhanced calculations and fallbacks
    var targetNum = parseFloat(target.replace(/,/g, '')) || 0;
    var ytdNum = parseFloat(ytd.replace(/,/g, '')) || 0;
    var remainingNum = parseFloat(remaining.replace(/,/g, '')) || 0;
    var monthsPassed = new Date().getMonth() + 1; // Current month (1-12)
    var monthsLeft = 12 - monthsPassed;
    
    // Calculate missing averages if not available
    if (!avgTarget || avgTarget === '0' || avgTarget === '') {
      avgTarget = targetNum > 0 ? (targetNum / 12).toLocaleString() : '—';
    }
    if (!avgInflow || avgInflow === '0' || avgInflow === '') {
      avgInflow = monthsPassed > 0 ? (ytdNum / monthsPassed).toLocaleString() : '—';
    }
    
    // Try to calculate monthly variance from available data
    var moVariance = '';
    try {
      if (targetNum > 0 && monthsPassed > 0) {
        var monthlyTarget = targetNum / 12;
        var expectedYtd = monthlyTarget * monthsPassed;
        moVariance = (ytdNum - expectedYtd).toLocaleString();
      }
    } catch(e) {}
    
    var totalDeviation = moVariance; // Use monthly variance as total deviation fallback
    var forecast = '';
    try {
      if (monthsLeft > 0) {
        forecast = (ytdNum + remainingNum).toLocaleString();
      }
    } catch(e) {}
    
    var moNeeded = '';
    try {
      if (monthsLeft > 0) {
        moNeeded = (remainingNum / monthsLeft).toLocaleString();
      }
    } catch(e) {}
    
    // Get additional data from buildOverviewText
    var overviewLines = buildOverviewText().split('\n');
    var nextInfo = '';
    try {
      if (overviewLines.length > 3) {
        nextInfo = overviewLines[3] || '';
      }
      if (overviewLines.length > 4) {
        var nextYear = overviewLines[4] || '';
        if (nextYear) nextInfo += ' | ' + nextYear;
      }
    } catch(e) {}
    
    // Calculate progress percentage
    var progressPercent = 0;
    try {
      if (targetNum > 0) {
        progressPercent = Math.min(100, Math.round((ytdNum / targetNum) * 100));
      }
    } catch(e) {}
    
    // Fallback: try to extract from existing overview text if fields above not present
    try{ if(!target || target==='0') target = (overviewLines[0]||'').replace(/[^0-9,.-]/g,'').trim() || target; }catch(e){}

    // ===== ENHANCED DATA COLLECTION =====
    // Gather additional KPI values
    var kpiData = {};
    var kpiElements = [
      'kpiVal_target', 'kpiVal_ytd', 'kpiVal_rem', 'kpiVal_ob', 'kpiVal_avgMonthly', 
      'kpiVal_avgActualMonthly', 'kpiVal_monthlyVariance', 'kpiVal_deviation', 
      'kpiVal_forecast', 'kpiVal_monthlyNeeded'
    ];
    
    kpiElements.forEach(id => {
      var el = document.getElementById(id);
      if (el) {
        kpiData[id] = el.textContent.trim() || '—';
      }
    });

    // Get chart data if available
    var chartData = {};
    try {
      var gaugeChart = document.getElementById('gaugeChart');
      var performanceChart = document.getElementById('performanceChart');
      var scnChart = document.getElementById('scn-chart');
      
      if (gaugeChart) chartData.gauge = 'Year Progress Gauge Available';
      if (performanceChart) chartData.performance = 'Monthly Performance Chart Available';
      if (scnChart) chartData.scenario = 'Scenario Chart Available';
    } catch(e) {}

    // Get scenario planning data
    var scenarioData = {};
    try {
      var scenarioModal = document.getElementById('scenarioModal');
      if (scenarioModal) {
        scenarioData.available = 'Scenario Planning Available';
        // Try to get scenario inputs
        var inputs = scenarioModal.querySelectorAll('input, select');
        inputs.forEach(input => {
          if (input.id || input.name) {
            scenarioData[input.id || input.name] = input.value || input.textContent || '';
          }
        });
      }
    } catch(e) {}

    // Get months ahead information from input
    var monthsAhead = '';
    try {
      var monthsInputEl = document.getElementById('scn-months-ahead');
      if (monthsInputEl) {
        monthsAhead = monthsInputEl.value ? monthsInputEl.value.toString().trim() : '';
      }
    } catch(e) {}

    // Build an enhanced styled card with more comprehensive data
    var card = document.createElement('div');
    card.className = '__export_overview_card';
    // Optimized width for better compatibility
    card.style.width = '620px'; // Slightly increased for more content
    card.style.padding = '32px';
    card.style.borderRadius = '20px';
    card.style.background = 'linear-gradient(135deg, #003865 0%, #005a9c 25%, #007acc 50%, #0099ff 75%, #33aaff 100%)';
    card.style.color = '#ffffff';
    card.style.fontFamily = "Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial";
    card.style.fontSize = '16px';
    card.style.lineHeight = '1.4';
    card.style.boxShadow = '0 25px 50px rgba(0,0,0,0.4), 0 0 0 2px rgba(255,255,255,0.15), inset 0 1px 0 rgba(255,255,255,0.2)';
    card.style.position = 'relative';
    card.style.overflow = 'hidden';

    // Enhanced pattern overlay
    card.style.backgroundImage = `
      radial-gradient(circle at 20% 20%, rgba(255,255,255,0.15) 0%, transparent 40%),
      radial-gradient(circle at 80% 80%, rgba(255,255,255,0.08) 0%, transparent 40%),
      linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.03) 50%, transparent 70%)
    `;
    card.style.backgroundSize = '80px 80px, 60px 60px, 100px 100px';
    card.style.backgroundPosition = '0 0, 40px 40px, 0 0';

    // Header with enhanced styling
    var header = document.createElement('div');
    header.style.display='flex'; 
    header.style.alignItems='center'; 
    header.style.marginBottom='24px';
    header.style.paddingBottom='20px';
    header.style.borderBottom='3px solid rgba(255,255,255,0.3)';
    var logo = document.createElement('div');
    logo.style.width='72px'; 
    logo.style.height='72px'; 
    logo.style.borderRadius='16px'; 
    logo.style.background='linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%)'; 
    logo.style.marginRight='24px';
    logo.style.boxShadow='0 6px 16px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.8)';
    logo.style.display='flex';
    logo.style.alignItems='center';
    logo.style.justifyContent='center';
    logo.style.fontWeight='800'; 
    logo.style.color='#003865';
    logo.style.fontSize='28px';
    logo.style.textShadow='0 1px 2px rgba(0,0,0,0.1)';
    // optional brand logo if present in DOM
    try{
      var logoEl = document.getElementById('brandLogo');
      if (logoEl && logoEl.tagName === 'IMG' && logoEl.src) {
        var li = document.createElement('img'); 
        li.src = logoEl.src; 
        li.style.width='100%'; 
        li.style.height='100%'; 
        li.style.objectFit='cover'; 
        li.style.borderRadius='16px'; 
        logo.innerHTML=''; 
        logo.appendChild(li);
        logo.style.background = 'transparent';
      } else {
        // placeholder initials
        logo.textContent = owner ? owner.split(' ')[0].slice(0,2).toUpperCase() : 'EN';
      }
    }catch(e){}
    var titleWrap = document.createElement('div');
    var t1 = document.createElement('div'); 
    t1.textContent = 'ENBD Performance Summary'; 
    t1.style.fontSize='28px'; 
    t1.style.fontWeight='800';
    t1.style.marginBottom='6px';
    t1.style.textShadow='0 3px 6px rgba(0,0,0,0.4)';
    t1.style.letterSpacing='0.5px';
    var t2 = document.createElement('div'); 
    t2.textContent = owner + ' • ' + year; 
    t2.style.opacity='0.95'; 
    t2.style.fontSize='18px';
    t2.style.fontWeight='600';
    t2.style.color='rgba(255,255,255,0.9)';
    titleWrap.appendChild(t1); 
    titleWrap.appendChild(t2);
    header.appendChild(logo); 
    header.appendChild(titleWrap);

    // Progress bar
    var progressContainer = document.createElement('div');
    progressContainer.style.marginBottom='24px';
    progressContainer.style.padding='16px';
    progressContainer.style.background='rgba(255,255,255,0.1)';
    progressContainer.style.borderRadius='12px';
    progressContainer.style.border='1px solid rgba(255,255,255,0.2)';
    progressContainer.style.backdropFilter='blur(12px)';
    var progressLabel = document.createElement('div');
    progressLabel.style.display='flex';
    progressLabel.style.justifyContent='space-between';
    progressLabel.style.marginBottom='8px';
    progressLabel.style.fontSize='14px';
    progressLabel.style.fontWeight='600';
    progressLabel.style.textTransform='uppercase';
    progressLabel.style.letterSpacing='0.5px';
    progressLabel.innerHTML = `<span>Progress to Target</span><span>${progressPercent}%</span>`;
    var progressBar = document.createElement('div');
    progressBar.style.width='100%';
    progressBar.style.height='8px';
    progressBar.style.background='rgba(255,255,255,0.2)';
    progressBar.style.borderRadius='4px';
    progressBar.style.overflow='hidden';
    var progressFill = document.createElement('div');
    progressFill.style.width= progressPercent + '%';
    progressFill.style.height='100%';
    progressFill.style.background='linear-gradient(90deg, #00ff88, #00cc66)';
    progressFill.style.borderRadius='4px';
    progressFill.style.transition='width 0.8s ease';
    progressBar.appendChild(progressFill);
    progressContainer.appendChild(progressLabel);
    progressContainer.appendChild(progressBar);

    // Enhanced grid layout with more columns for comprehensive data
    var grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = '1fr 1fr 1fr'; // 3 columns for more data
    grid.style.gap = '12px';
    grid.style.marginTop = '8px';

    function kv(label, value, highlight = false){
      var w = document.createElement('div'); 
      w.style.display='flex'; 
      w.style.flexDirection='column';
      w.style.alignItems='center';
      w.style.background='rgba(255,255,255,0.12)';
      w.style.padding='12px';
      w.style.borderRadius='10px';
      w.style.backdropFilter='blur(12px)';
      w.style.border='1px solid rgba(255,255,255,0.25)';
      w.style.transition='all 0.3s ease';
      w.style.cursor='default';
      if (highlight) {
        w.style.background='rgba(255,255,255,0.18)';
        w.style.border='1px solid rgba(255,255,255,0.4)';
        w.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';
      }
      var l = document.createElement('div'); 
      l.textContent = label; 
      l.style.opacity='0.9'; 
      l.style.fontSize='11px';
      l.style.fontWeight='600';
      l.style.textTransform='uppercase';
      l.style.letterSpacing='0.8px';
      l.style.textAlign='center';
      l.style.marginBottom='6px';
      var v = document.createElement('div'); 
      v.textContent = value || '—'; 
      v.style.fontWeight='800'; 
      v.style.fontSize='16px';
      v.style.textAlign='center';
      v.style.textShadow='0 1px 2px rgba(0,0,0,0.3)';
      w.appendChild(l); 
      w.appendChild(v); 
      return w;
    }

    // Primary KPIs (highlighted)
    grid.appendChild(kv('Yearly Target', target, true));
    grid.appendChild(kv('YTD Inflow', ytd, true));
    grid.appendChild(kv('Remaining', remaining || '(—)'));
    
    // Additional KPIs
    grid.appendChild(kv('Opening Balance', opening || '0'));
    grid.appendChild(kv('Avg. Mo. Target', avgTarget || '—'));
    grid.appendChild(kv('Avg. Mo. Inflow', avgInflow || '—'));
    
    // Performance metrics
    grid.appendChild(kv('Monthly Variance', moVariance || '—'));
    grid.appendChild(kv('Total Deviation', totalDeviation || '—'));
    grid.appendChild(kv('Forecasted Year-End', forecast || '—'));
    
    // Enhanced KPIs from kpiVal elements
    if (kpiData.kpiVal_monthlyNeeded && kpiData.kpiVal_monthlyNeeded !== '—') {
      grid.appendChild(kv('Monthly Needed', kpiData.kpiVal_monthlyNeeded));
    } else {
      grid.appendChild(kv('Monthly Needed', moNeeded || '—'));
    }
    
    if (kpiData.kpiVal_forecast && kpiData.kpiVal_forecast !== '—') {
      grid.appendChild(kv('Year-End Forecast', kpiData.kpiVal_forecast));
    } else {
      grid.appendChild(kv('Next Milestone', nextInfo || '—'));
    }
    
    // Add months ahead if available
    if (monthsAhead) {
      grid.appendChild(kv('Months Ahead', monthsAhead));
    } else {
      grid.appendChild(kv('Current Month', new Date().toLocaleString('default', { month: 'long' })));
    }
    
    // Add chart availability info
    var chartInfo = [];
    if (chartData.gauge) chartInfo.push('📊');
    if (chartData.performance) chartInfo.push('📈');
    if (chartData.scenario) chartInfo.push('🎯');
    if (chartInfo.length > 0) {
      grid.appendChild(kv('Charts Available', chartInfo.join(' ')));
    }
    
    // Add scenario planning info
    if (scenarioData.available) {
      grid.appendChild(kv('Scenario Planning', 'Available'));
    }

    // Enhanced footer with more details
    var foot = document.createElement('div'); 
    foot.style.marginTop='24px'; 
    foot.style.opacity='0.85'; 
    foot.style.fontSize='13px';
    foot.style.textAlign='center';
    foot.style.padding='16px 20px';
    foot.style.background='rgba(255,255,255,0.12)';
    foot.style.borderRadius='12px';
    foot.style.border='1px solid rgba(255,255,255,0.25)';
    foot.style.backdropFilter='blur(12px)';
    
    var footerText = 'Generated from ENBD Tracker • ' + new Date().toLocaleDateString() + ' • ' + new Date().toLocaleTimeString();
    if (Object.keys(chartData).length > 0) {
      footerText += ' • Charts: ' + Object.keys(chartData).length;
    }
    if (scenarioData.available) {
      footerText += ' • Scenarios Available';
    }
    
    foot.textContent = footerText;

    card.appendChild(header);
    card.appendChild(progressContainer);
    card.appendChild(grid);
    card.appendChild(foot);

    // Attach off-screen for rendering (using absolute positioning for better html2canvas compatibility)
    card.style.position='absolute'; card.style.left='0'; card.style.top='0'; card.style.zIndex='-9999';
    document.body.appendChild(card);

    // Small wait to let fonts/images settle
    await new Promise(r=>setTimeout(r,150));

    try{
      const canvas = await window.html2canvas(card, {backgroundColor: null, scale: 3, useCORS: true});
      const a = document.createElement('a');
      const safeOwner = (owner||'owner').replace(/\s+/g,'_');
      a.href = canvas.toDataURL('image/png');
      a.download = `${safeOwner}_${year}_Enhanced_Overview.png`;
      document.body.appendChild(a); a.click(); a.remove();
      toast('Enhanced Overview PNG exported ✅');
    } finally {
      card.remove();
    }
  }

  function extendShareMenu(){
    var printBtn = document.getElementById('btnPrint');
    var row = printBtn && printBtn.parentElement;
    var menu = row && row.querySelector('.shareMenuWrapper #shareDropdown');
    if (!menu) return;

    // Append Overview actions
    var sep = document.createElement('hr');
    sep.style.border='none'; sep.style.borderTop='1px solid rgba(0,0,0,0.1)'; sep.style.margin='6px 0';
    menu.appendChild(sep);

    function addAction(label, action){
      var b=document.createElement('button');
      b.className='shareAction';
      b.textContent=label;
      b.setAttribute('data-action', action);
      b.style.width='100%'; b.style.textAlign='left'; b.style.padding='8px'; b.style.border='none'; b.style.background='none'; b.style.cursor='pointer';
      menu.appendChild(b);
      return b;
    }

    addAction('🧩 Share Overview (PNG)', 'overview-png');

    menu.querySelectorAll('.shareAction').forEach(function(btn){
      if (btn._wired) return;
      btn._wired = true;
      btn.addEventListener('click', async function(){
        menu.style.display='none';
        var act = this.getAttribute('data-action');
        if (act === 'overview-png') await saveOverviewPNG();
        if (act === 'overview-text'){
          const msg = buildOverviewText();
          try { await navigator.clipboard.writeText(msg); } catch(e){}
        }
      });
    });
  }

  ready(extendShareMenu);
})();
</script>
<!-- Month Quick-Share [AUTO-INSERTED] (FixPack v4: index-based extraction) -->
<script>
(function monthShareEnhancer(){
  const $monthsBar = document.getElementById('monthsMini');
  if (!$monthsBar) return;

  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const txt = el => (el ? (el.textContent || '').trim() : '');

  function queryCell(idx, field){
    // Select the cell using data-month + data-field markers created by renderTable()
    return document.querySelector(`td[data-month="${idx}"][data-field="${field}"]`);
  }

  function extractByIndex(idx){
    // Fallback reads if any cell missing
    const owner = txt(document.getElementById('ownerNameDisplay')) || '—';
    const year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '—').replace(/\D+/g,'') || '—';
    const targetEl = queryCell(idx, 'target');
    const expectedEl = queryCell(idx, 'expected');
    const actualEl = queryCell(idx, 'actual');

    // Variance cell is the one right after Bank Inflow; safer: read by row traversing from targetEl's parent <tr>
    let variance = '—';
    try {
      const tr = targetEl ? targetEl.parentElement : null;
      if (tr) {
        // headers order: ... Target, Month, Expected, Bank, Variance, Balance
        const tds = Array.from(tr.children);
        // find the cell that contains an up/down arrow OR matches the formatted variance style
        // but simpler: use position of targetEl and count forward to find Variance (target -> +4)
        const vIdx = tds.indexOf(targetEl) + 4;
        if (vIdx >= 0 && vIdx < tds.length) variance = txt(tds[vIdx]) || '—';
      }
    } catch(e){}

    // Notes are in the "Notes" column, which doesn't have data-field. We can read from tr as well: it's 2 cells before Target.
    let notes = '—';
    try {
      const tr = targetEl ? targetEl.parentElement : null;
      if (tr) {
        const tds = Array.from(tr.children);
        const tIdx = tds.indexOf(targetEl);
        const notesCell = tds[tIdx - 2];
        if (notesCell) notes = txt(notesCell) || '—';
      }
    } catch(e){}

    
    // Try to read Balance as the cell right after Variance relative to Target
    let accVariance = '—';
    try {
      const tr = targetEl ? targetEl.parentElement : null;
      if (tr) {
        const tds = Array.from(tr.children);
        const tIdx = tds.indexOf(targetEl);
        const vIdx = tIdx + 4;
        const avIdx = vIdx + 1;
        if (avIdx >= 0 && avIdx < tds.length) accVariance = (tds[avIdx].getAttribute('data-clean') || tds[avIdx].textContent || '').trim() || '—';
      }
    } catch(e){}
    return {
      owner,
      year,
      month: MONTHS[idx] || `M${idx+1}`,
      target: txt(targetEl) || '—',
      expected: txt(expectedEl) || '—',
      bank: txt(actualEl) || '—',
      variance,
      notes
    };
  }

  function buildPopover(data) {
    const pop = document.createElement('div');
    pop.className = 'month-pop is-fixed';
    pop.setAttribute('role','dialog');
    pop.innerHTML = `
      <div id="month-pop-content">
        <h4>${data.owner} — ${data.year} • ${data.month}</h4>
        <div class="kv">
          <div>Target</div><div>${data.target}</div>
          <div>Expected</div><div>${data.expected}</div>
          <div>Bank</div><div>${data.bank}</div>
          <div>Variance</div><div>${data.variance}</div>
                    <div>Balance</div><div>${data.accVariance || '—'}</div>
<div>Notes</div><div>${data.notes || '—'}</div>
        </div>
        <div class="actions">
          <button class="wa">WhatsApp</button>
          <button class="share">Share…</button>
          <button class="copy ghost">Copy text</button>
          <button class="png ghost">PNG</button>
        </div>
      </div>
    `;
    return pop;
  }

  function positionPopover(pop, anchorEl){
    const ar = anchorEl.getBoundingClientRect();
    const pw = 260, ph = 190;
    let x = ar.right - pw;
    let y = ar.bottom + 6;
    if (x < 8) x = Math.max(8, ar.left);
    if (x + pw > window.innerWidth - 8) x = window.innerWidth - pw - 8;
    if (y + ph > window.innerHeight - 8) y = Math.max(8, ar.top - ph - 6);
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
  }

  function composeText(d){
    return [
      `${d.owner} — ${d.year} (${d.month})`,
      `Target: ${d.target}`,
      `Expected: ${d.expected}`,
      `Bank: ${d.bank}`,
      `Variance: ${d.variance}`,
      `Balance: ${d.accVariance || '—'}`,
      d.notes ? `Notes: ${d.notes}` : ''
    ].filter(Boolean).join('\n');
  }

  function attachIcons(){
    [...$monthsBar.querySelectorAll('.month-pill')].forEach(pill => {
      if (pill.querySelector('.month-share-icon')) return;
      const icon = document.createElement('span');
      icon.className = 'month-share-icon';
      icon.title = 'Share this month';
      icon.setAttribute('aria-label','Share this month');
      icon.textContent = '↗';
      pill.appendChild(icon);

      icon.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        document.querySelectorAll('.month-pop').forEach(n => n.remove());
        const idx = Number(pill.getAttribute('data-month-index') || '0');
        const data = extractByIndex(idx);
        const pop = buildPopover(data);
        document.body.appendChild(pop);
        positionPopover(pop, icon);

        const textPayload = composeText(data);
        const btnWA   = pop.querySelector('.wa');
        const btnSys  = pop.querySelector('.share');
        const btnCopy = pop.querySelector('.copy');
        const btnPNG  = pop.querySelector('.png');

        btnWA.addEventListener('click', () => {
          const url = 'https://wa.me/?text=' + encodeURIComponent(textPayload);
          window.open(url, '_blank', 'noopener');
        });
        btnSys.addEventListener('click', async () => {
          if (navigator.share) {
            try { await navigator.share({ text: textPayload, title: `${data.owner} — ${data.year} ${data.month}` }); } catch(_e){}
          } else {
            const url = 'https://wa.me/?text=' + encodeURIComponent(textPayload);
            window.open(url, '_blank', 'noopener');
          }
        });
        btnCopy.addEventListener('click', async () => {
          try { await navigator.clipboard.writeText(textPayload); btnCopy.textContent = 'Copied'; setTimeout(()=>btnCopy.textContent='Copy text', 1200); }
          catch(_e){ btnCopy.textContent = 'Copy failed'; setTimeout(()=>btnCopy.textContent='Copy text', 1200); }
        });
        btnPNG.addEventListener('click', async () => {
          const card = pop.querySelector('#month-pop-content');
          document.body.classList.add('__exporting');
          try {
            if (typeof html2canvas === 'undefined') { alert('html2canvas not loaded.'); return; }
            const canvas = await html2canvas(card, {backgroundColor: '#ffffff', scale: 2});
            const link = document.createElement('a');
            const safeOwner = (data.owner||'owner').replace(/\s+/g,'_');
            link.download = `${safeOwner}_${data.year}_${data.month}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
          } finally {
            document.body.classList.remove('__exporting');
          }
        });
      });
    });
  }

  attachIcons();
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.month-pop') && !e.target.closest('.month-share-icon')) {
      document.querySelectorAll('.month-pop').forEach(n => n.remove());
    }
  });
  const obs = new MutationObserver(() => attachIcons());
  obs.observe($monthsBar, { childList: true, subtree: true });
})();
</script>
<script>
// === Global Export Theme Helpers (v6) ===
(function(){
  if (window.__exportThemeInstalled) return;
  window.__exportThemeInstalled = true;

  window.withExportTheme = async function(fn){
    document.body.classList.add('__exporting');
    try { return await fn(); }
    finally { document.body.classList.remove('__exporting'); }
  };

  // Print hooks: ensure export theme for native printing
  function addExport(){ document.body.classList.add('__exporting'); }
  function removeExport(){ document.body.classList.remove('__exporting'); }
  if (window.matchMedia) {
    // Some browsers don't fire afterprint reliably; keep both
    window.addEventListener('beforeprint', addExport);
    window.addEventListener('afterprint', removeExport);
  }

  // Patch html2canvas if/when it loads
  const hookHtml2Canvas = () => {
    if (!window.html2canvas || window.html2canvas.__wrapped) return false;
    const original = window.html2canvas;
    const wrapped = function(target, opts){
      const options = Object.assign({ backgroundColor: '#ffffff', scale: 2 }, opts || {});
      return window.withExportTheme(() => original(target, options));
    };
    wrapped.__wrapped = true;
    for (const k in original) { try { wrapped[k] = original[k]; } catch(e){} }
    window.html2canvas = wrapped;
    return true;
  };

  // Try now, and again after load
  hookHtml2Canvas();
  const iv = setInterval(() => { if (hookHtml2Canvas()) clearInterval(iv); }, 300);

  // Optional: provide a global helper to export any element as PNG
  window.exportElementAsPng = async function(el, fileName){
    if (!window.html2canvas) { alert('html2canvas is not available.'); return; }
    await withExportTheme(async () => {
      const canvas = await window.html2canvas(el, {backgroundColor: '#ffffff', scale: 2});
      const link = document.createElement('a');
      link.download = fileName || 'export.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });
  };
})();
</script>
<script>
// === Share Everywhere (v8 - robust) ===
(function(){
  if (window.__shareEverywhereInstalledV8) return;
  window.__shareEverywhereInstalledV8 = true;

  const txt = el => (el ? (el.textContent || '').trim() : '');
  const MONTHS = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];

  function buildCard(title, kvPairs){
    const pop = document.createElement('div');
    pop.className = 'month-pop is-fixed share-card';
    pop.setAttribute('role','dialog');
    const kvHtml = kvPairs.map(([k,v])=>`<div>${k}</div><div>${v ?? '—'}</div>`).join('');
    pop.innerHTML = `
      <div id="month-pop-content">
        <h4>${title}</h4>
        <div class="kv">${kvHtml}</div>
        <div class="actions">
          <button class="wa">WhatsApp</button>
          <button class="share">Share…</button>
          <button class="copy ghost">Copy text</button>
          <button class="png ghost">PNG</button>
        </div>
      </div>`;
    return pop;
  }

  function positionPopover(pop, anchorEl){
    const ar = anchorEl.getBoundingClientRect();
    const pw = 280, ph = 210;
    let x = ar.right - pw;
    let y = ar.bottom + 6;
    if (x < 8) x = Math.max(8, ar.left);
    if (x + pw > innerWidth - 8) x = innerWidth - pw - 8;
    if (y + ph > innerHeight - 8) y = Math.max(8, ar.top - ph - 6);
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
  }

  function wireActions(pop, title, kvPairs){
    const text = [title, ...kvPairs.map(([k,v])=>`${k}: ${v ?? '—'}`)].join('\n');
    const btnWA   = pop.querySelector('.wa');
    const btnSys  = pop.querySelector('.share');
    const btnCopy = pop.querySelector('.copy');
    const btnPNG  = pop.querySelector('.png');

    btnWA.addEventListener('click', ()=>{
      const url = 'https://wa.me/?text=' + encodeURIComponent(text);
      window.open(url,'_blank','noopener');
    });
    btnSys.addEventListener('click', async ()=>{
      if (navigator.share){
        try{ await navigator.share({ title, text }); }catch(e){}
      } else {
        const url = 'https://wa.me/?text=' + encodeURIComponent(text);
        window.open(url,'_blank','noopener');
      }
    });
    btnCopy.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(text); btnCopy.textContent='Copied'; setTimeout(()=>btnCopy.textContent='Copy text', 1200);}catch(e){}
    });
    btnPNG.addEventListener('click', async ()=>{
      const card = pop.querySelector('#month-pop-content');
      document.body.classList.add('__exporting');
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        const canvas = await window.html2canvas(card, {backgroundColor:'#ffffff', scale:2});
        const link = document.createElement('a');
        link.download = (title.replace(/\s+/g,'_') || 'share') + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } finally {
        document.body.classList.remove('__exporting');
      }
    });
  }

  // ---- Overview Share (broaden selectors) ----
  function attachOverviewShare(){
    const candidates = [
      '.ribbon', '#ribbon', '.overview-ribbon', '#overview', '#overviewRibbon',
      '.overview', '.summary', '#summaryRibbon', '#topRibbon', '[data-role="overview"]'
    ];
    let ribbon = null;
    for (const sel of candidates){
      ribbon = document.querySelector(sel);
      if (ribbon) break;
    }
    if (!ribbon || ribbon.querySelector('.share-icon')) return;

    const icon = document.createElement('span');
    icon.className = 'share-icon';
    icon.title = 'Share overview';
    icon.textContent = '↗';
    ribbon.appendChild(icon);

    icon.addEventListener('click', (e)=>{
      e.stopPropagation();
      document.querySelectorAll('.month-pop').forEach(n=>n.remove());

      const owner = txt(document.getElementById('ownerNameDisplay')) || '—';
      const year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '—').replace(/\D+/g,'') || '—';

      // Pull live KPI values from the dashboard instead of relying on legacy attributes
      const targetEl     = document.getElementById('dashYearlyTarget');
      const ytdEl        = document.getElementById('dashYtdAccomplished');
      const remainEl     = document.getElementById('dashRemaining');
      const nextMonthEl  = document.getElementById('nextBadgeMonth');
      const nextAmountEl = document.getElementById('nextBadgeAmount');
      const nextDaysEl   = document.getElementById('nextBadgeDays');
      const target = targetEl ? (targetEl.textContent || '').trim() : '';
      const ytd    = ytdEl ? (ytdEl.textContent || '').trim() : '';
      const remain = remainEl ? (remainEl.textContent || '').trim() : '';
      const nextMonthVal = nextMonthEl ? (nextMonthEl.textContent || '').trim() : '';
      const nextAmount = nextAmountEl ? (nextAmountEl.textContent || '').trim() : '';
      const nextDays  = nextDaysEl ? (nextDaysEl.textContent || '').trim() : '';

      const title = `${owner} — ${year} • Overview`;
      const kv = [
        ['Early Target', target || '—'],
        ['YTD Bank Inflow', ytd || '—'],
        ['Remaining', remain || '—'],
        [
          'Next Needed',
          (nextMonthVal && nextAmount)
            ? `${nextMonthVal} ${nextAmount}${nextDays ? ' (' + nextDays + ')' : ''}`
            : (nextAmount || '—')
        ],
      ];

      const pop = buildCard(title, kv);
      document.body.appendChild(pop);
      positionPopover(pop, icon);
      wireActions(pop, title, kv);
    });
  }

  // ---- Table Row Share (robust) ----
  function ensureShareHeader(){
    const thead = document.querySelector('table thead tr:last-child');
    if (!thead) return;
    if (!thead.querySelector('th.share-col')){
      const th = document.createElement('th');
      th.textContent = 'Share';
      th.className = 'share-col';
      thead.appendChild(th);
    }
  }

  function monthIndexFromText(text){
    if (!text) return null;
    const t = text.toLowerCase().trim();
    // Try abbr
    let idx = MONTHS.indexOf(t.slice(0,3));
    if (idx >= 0) return idx;
    // Try number
    const n = parseInt(t, 10);
    if (!isNaN(n) && n>=1 && n<=12) return n-1;
    return null;
  }

  function extractRowData(tr, fallbackIdx){
    const owner = txt(document.getElementById('ownerNameDisplay')) || '—';
    const year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '—').replace(/\D+/g,'') || '—';

    // If we have data-month/data-field, use those:
    const dm = tr.querySelector('td[data-month]');
    const idx = dm ? Number(dm.getAttribute('data-month')) : fallbackIdx;

    // Try direct mapped fields
    const q = (f)=>tr.querySelector(`td[data-field="${f}"], td[data-field*="${f}"]`);
    const targetEl = q('target');
    const expectedEl = q('expected');
    const actualEl = q('actual') || q('bank');
    // Variance and notes: flexible
    let variance = '—', notes = '—';
    const byHeader = (label)=>{
      const headers = Array.from(tr.parentElement.parentElement.querySelectorAll('thead tr:last-child th')).map(h=>txt(h).toLowerCase());
      const tds = Array.from(tr.children);
      for (let i=0;i<headers.length;i++){
        if (['variance','shortage','surplus','diff','delta'].some(k=>headers[i].includes(k))){
          return txt(tds[i]);
        }
      }
      return null;
    };
    variance = byHeader('variance') || txt(q('variance')) || '—';

    // Notes: try explicit data-field or last 'notes-like' cell
    notes = txt(q('notes')) || (()=>{
      const headers = Array.from(tr.parentElement.parentElement.querySelectorAll('thead tr:last-child th')).map(h=>txt(h).toLowerCase());
      const tds = Array.from(tr.children);
      for (let i=0;i<headers.length;i++){
        if (['notes','note','remarks','comments'].some(k=>headers[i].includes(k))) return txt(tds[i]) || '—';
      }
      return '—';
    })();

    // Month label for title
    let monthLabel = '—';
    // Prefer first cell that looks like a month
    const monthCell = tr.querySelector('td[data-field="month"]') || tr.children[0];
    if (monthCell){
      const t = txt(monthCell);
      const mIdx = monthIndexFromText(t);
      monthLabel = mIdx!=null ? ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][mIdx] : (t.split(/\s+/)[0]||'—');
    }

    return {
      owner, year,
      month: monthLabel,
      target: txt(targetEl) || '—',
      expected: txt(expectedEl) || '—',
      bank: txt(actualEl) || '—',
      variance, notes
    };
  }

  function attachRowShare(){
    ensureShareHeader();
    const body = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!body) return;
    let rowIdx = 0;
    Array.from(body.querySelectorAll('tr')).forEach(tr => {
      // skip header or non-data rows
      if (tr.querySelector('.table-row-share')) return;
      // Add cell if missing
      let last = tr.lastElementChild;
      if (!last || !last.classList.contains('share-cell')){
        const td = document.createElement('td');
        td.className = 'share-cell';
        tr.appendChild(td);
        last = td;
      }
      const btn = document.createElement('button');
      btn.className = 'table-row-share';
      btn.title = 'Share this row';
      btn.textContent = '↗';
      last.appendChild(btn);

      const fallbackIdx = rowIdx; // in case we need it
      rowIdx += 1;

      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        document.querySelectorAll('.month-pop').forEach(n=>n.remove());
        const d = extractRowData(tr, fallbackIdx);
        const title = `${d.owner} — ${d.year} • ${d.month}`;
        const kv = [
          ['Target', d.target],
          ['Expected', d.expected],
          ['Bank', d.bank],
          ['Variance', d.variance],
      ['Balance', d.accVariance || '—'],
          ['Notes', d.notes],
        ];
        const pop = buildCard(title, kv);
        document.body.appendChild(pop);
        positionPopover(pop, btn);
        wireActions(pop, title, kv);
      });
    });
  }

  // ---- Charts modal (robust) ----
  function attachChartsShare(){
    const modal = document.querySelector('#chartsModal, .charts-modal, [data-modal="charts"]');
    if (!modal) return;
    const header = modal.querySelector('.modal-header, header, h3, h2') || modal;
    if (header.querySelector('.share-icon')) return;
    const icon = document.createElement('span');
    icon.className = 'share-icon';
    icon.title = 'Share chart';
    icon.textContent = '↗';
    header.appendChild(icon);

    icon.addEventListener('click', async (e)=>{
      e.stopPropagation();
      document.querySelectorAll('.month-pop').forEach(n=>n.remove());

      const owner = txt(document.getElementById('ownerNameDisplay')) || '—';
      const year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '—').replace(/\D+/g,'') || '—';
      const title = `${owner} — ${year} • Chart`;
      const kv = [['Info','Tap PNG to export the chart image']];
      const pop = buildCard(title, kv);
      document.body.appendChild(pop);
      positionPopover(pop, icon);
      wireActions(pop, title, kv);

      const btnPNG = pop.querySelector('.png');
      btnPNG.addEventListener('click', async ()=>{
        const canvas = modal.querySelector('canvas');
        if (!canvas){ alert('No chart canvas found'); return; }
        await withExportTheme(async ()=>{
          const link = document.createElement('a');
          link.download = `${title.replace(/\s+/g,'_')}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        });
      }, { once: true });
    });
  }

  // ---- Report modal (robust) ----
  function attachReportShare(){
    const modal = document.querySelector('#reportModal, .report-modal, [data-modal="report"], [data-modal="reports"]');
    if (!modal) return;
    const header = modal.querySelector('.modal-header, header, h3, h2') || modal;
    if (header.querySelector('.share-icon')) return;
    const icon = document.createElement('span');
    icon.className = 'share-icon';
    icon.title = 'Share report';
    icon.textContent = '↗';
    header.appendChild(icon);

    icon.addEventListener('click', (e)=>{
      e.stopPropagation();
      document.querySelectorAll('.month-pop').forEach(n=>n.remove());

      const owner = txt(document.getElementById('ownerNameDisplay')) || '—';
      const year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '—').replace(/\D+/g,'') || '—';
      const title = `${owner} — ${year} • Report`;
      const content = modal.querySelector('.modal-body, .content, section, article, .report-body') || modal;
      const summary = Array.from(content.querySelectorAll('strong,.value,.stat,.line')).slice(0,8).map(el=>txt(el)).filter(Boolean).join(' / ') || 'Report summary';
      const kv = [['Summary', summary]];

      const pop = buildCard(title, kv);
      document.body.appendChild(pop);
      positionPopover(pop, icon);
      wireActions(pop, title, kv);

      const btnPNG = pop.querySelector('.png');
      btnPNG.addEventListener('click', async ()=>{
        await withExportTheme(async ()=>{
          if (!window.html2canvas){ alert('html2canvas not available'); return; }
          const canvas = await window.html2canvas(content, { backgroundColor:'#ffffff', scale:2 });
          const link = document.createElement('a');
          link.download = `${title.replace(/\s+/g,'_')}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        });
      }, { once: true });
    });
  }

  function initAll(){
    attachOverviewShare();
    // Removed call to attachRowShare() to hide the Share column from the monthly table
    attachChartsShare();
    attachReportShare();
  }

  initAll();
  const obs = new MutationObserver(()=> initAll());
  obs.observe(document.body, { childList:true, subtree:true });

  document.addEventListener('click', (e) => {
    if (!e.target.closest('.month-pop') && !e.target.closest('.share-icon') && !e.target.closest('.table-row-share') && !e.target.closest('.month-share-icon')) {
      document.querySelectorAll('.month-pop').forEach(n => n.remove());
    }
  });
})();
</script>
<script>

<script>
// === v9.1: Share on numbering (stable + robust values) ===
(function(){
  if (window.__shareOnNumberingV91) return;
  window.__shareOnNumberingV91 = true;

  const txt = el => (el ? (el.textContent || '').trim() : '');
  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  function buildCard(title, kvPairs){
    const pop = document.createElement('div');
    pop.className = 'month-pop is-fixed share-card';
    pop.setAttribute('role','dialog');
    const kvHtml = kvPairs.map(([k,v])=>`<div>${k}</div><div>${v ?? '—'}</div>`).join('');
    pop.innerHTML = `
      <div id="month-pop-content">
        <h4>${title}</h4>
        <div class="kv">${kvHtml}</div>
        <div class="actions">
          <button class="wa">WhatsApp</button>
          <button class="share">Share…</button>
          <button class="copy ghost">Copy text</button>
          <button class="png ghost">PNG</button>
        </div>
      </div>`;
    return pop;
  }

  function positionPopover(pop, anchorEl){
    const ar = anchorEl.getBoundingClientRect();
    const pw = 280, ph = 210;
    let x = ar.right - pw;
    let y = ar.bottom + 6;
    if (x < 8) x = Math.max(8, ar.left);
    if (x + pw > innerWidth - 8) x = innerWidth - pw - 8;
    if (y + ph > innerHeight - 8) y = Math.max(8, ar.top - ph - 6);
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
  }

  function wireActions(pop, title, kvPairs){
    const text = [title, ...kvPairs.map(([k,v])=>`${k}: ${v ?? '—'}`)].join('\n');
    const btnWA   = pop.querySelector('.wa');
    const btnSys  = pop.querySelector('.share');
    const btnCopy = pop.querySelector('.copy');
    const btnPNG  = pop.querySelector('.png');

    btnWA.addEventListener('click', ()=>{
      const url = 'https://wa.me/?text=' + encodeURIComponent(text);
      window.open(url,'_blank','noopener');
    });
    btnSys.addEventListener('click', async ()=>{
      if (navigator.share){ try{ await navigator.share({ title, text }); }catch(e){} }
      else { window.open('https://wa.me/?text=' + encodeURIComponent(text),'_blank','noopener'); }
    });
    btnCopy.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(text); btnCopy.textContent='Copied'; setTimeout(()=>btnCopy.textContent='Copy text', 1200);}catch(e){}
    });
    btnPNG.addEventListener('click', async ()=>{
      const card = pop.querySelector('#month-pop-content');
      document.body.classList.add('__exporting');
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        const canvas = await window.html2canvas(card, {backgroundColor:'#ffffff', scale:2});
        const link = document.createElement('a');
        link.download = (title.replace(/\s+/g,'_') || 'share') + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } finally { document.body.classList.remove('__exporting'); }
    });
  }

  // === Helpers for robust extraction ===
  function headerMap(){
    const map = {};
    const ths = document.querySelectorAll('table thead tr:last-child th');
    ths.forEach((th, i) => map[(th.textContent||'').trim().toLowerCase()] = i);
    const find = (...cands)=>{
      for (const [k,i] of Object.entries(map)){
        for (const c of cands){ if (k.includes(c)) return i; }
      }
      return null;
    };
    return {
      raw: map,
      month: find('month','mon'),
      target: find('target','req','needed'),
      expected: find('expected','estimate','estimated','expected inflow'),
      bank: find('bank','inflow','deposit','bank inflow','actual'),
      variance: find('variance','shortage','surplus','diff','delta'),
      notes: find('notes','note','remark','comment')
    };
  }
  function cellValue(td){
    if (!td) return '—';
    let v = td.getAttribute('data-clean') || td.getAttribute('data-value');
    const child = td.querySelector('[data-clean],[data-value],.value,.val,.amount,.num,.cell-text,.text,.money,.currency');
    if (!v && child) v = child.getAttribute('data-clean') || child.getAttribute('data-value') || child.textContent;
    if (!v){
      const inp = td.querySelector('input,textarea');
      if (inp) v = inp.value;
    }
    if (!v) v = td.textContent;
    v = (v||'').toString().replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim();
    return v || '—';
  }

  function extractFromRow(tr, fallbackIdx){
    const owner = (document.getElementById('ownerNameDisplay') ? document.getElementById('ownerNameDisplay').textContent : '—').trim() || '—';
    const yText = (document.getElementById('yearFancy') ? document.getElementById('yearFancy').textContent : (document.getElementById('yearInput') ? document.getElementById('yearInput').textContent : '—'));
    const year  = (yText || '—').replace(/\D+/g,'') || '—';

    const hm = headerMap();
    const tds = Array.from(tr.children);

    // Month label
    let monthLabel = '—';
    if (hm.month != null && tds[hm.month]){
      const mtxt = cellValue(tds[hm.month]);
      const ab = (mtxt||'').slice(0,3);
      const idx = MONTHS.map(m=>m.toLowerCase()).indexOf(ab.toLowerCase());
      monthLabel = idx>=0 ? MONTHS[idx] : (mtxt||'—');
    } else {
      const n = Number(cellValue(tds[0]));
      monthLabel = (n>=1 && n<=12) ? MONTHS[n-1] : `Row ${fallbackIdx+1}`;
    }

    const getVal = (idx) => (idx!=null && tds[idx]) ? cellValue(tds[idx]) : '—';
    const target   = getVal(hm.target);
    const expected = getVal(hm.expected);
    const bank     = getVal(hm.bank);
    const variance = getVal(hm.variance);
    const notes    = getVal(hm.notes);

    return { owner, year, month: monthLabel, target, expected, bank, variance, notes };
  }

  function attachOnNumbering(){
    const body = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!body) return;
    const rows = Array.from(body.querySelectorAll('tr'));
    rows.forEach((tr, idx) => {
      const firstTd = tr.querySelector('td:first-child');
      if (!firstTd) return;
      firstTd.classList.add('number-cell');
      if (firstTd.querySelector('.num-share')) return;
      const trigger = document.createElement('span');
      trigger.className = 'num-share';
      trigger.title = 'Share this row';
      trigger.textContent = '↗';
      firstTd.appendChild(trigger);

      trigger.addEventListener('click', (e)=>{
        e.stopPropagation();
        document.querySelectorAll('.month-pop').forEach(n=>n.remove());
        const d = extractFromRow(tr, idx);
        const title = `${d.owner} — ${d.year} • ${d.month}`;
        const kv = [
          ['Target', d.target],
          ['Expected', d.expected],
          ['Bank', d.bank],
          ['Variance', d.variance],
      ['Balance', d.accVariance || '—'],
          ['Notes', d.notes],
        ];
        const pop = buildCard(title, kv);
        document.body.appendChild(pop);
        positionPopover(pop, trigger);
        wireActions(pop, title, kv);
      });
    });
  }

  function init(){ attachOnNumbering(); }
  init();
  const obs = new MutationObserver(()=> init());
  obs.observe(document.body, { childList:true, subtree:true });

  document.addEventListener('click', (e)=>{
    if (!e.target.closest('.month-pop') && !e.target.closest('.num-share')){
      document.querySelectorAll('.month-pop').forEach(n=>n.remove());
    }
  });
})();
</script>
<script>
// === v9.2: Number cell click opens share (plus visible ↗), broad tbody detection ===
(function(){
  if (window.__shareOnNumberingV92) return;
  window.__shareOnNumberingV92 = true;

  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const txt = el => (el ? (el.textContent || '').trim() : '');

  function isInt1to12(s){
    const n = Number((s||'').toString().trim());
    return Number.isInteger(n) && n>=1 && n<=12;
  }

  function buildCard(title, kvPairs){
    const pop = document.createElement('div');
    pop.className = 'month-pop is-fixed share-card';
    pop.setAttribute('role','dialog');
    const kvHtml = kvPairs.map(([k,v])=>`<div>${k}</div><div>${v ?? '—'}</div>`).join('');
    pop.innerHTML = `
      <div id="month-pop-content">
        <h4>${title}</h4>
        <div class="kv">${kvHtml}</div>
        <div class="actions">
          <button class="wa">WhatsApp</button>
          <button class="share">Share…</button>
          <button class="copy ghost">Copy text</button>
          <button class="png ghost">PNG</button>
        </div>
      </div>`;
    return pop;
  }

  function positionPopover(pop, anchorEl){
    const ar = anchorEl.getBoundingClientRect();
    const pw = 280, ph = 210;
    let x = ar.right - pw;
    let y = ar.bottom + 6;
    if (x < 8) x = Math.max(8, ar.left);
    if (x + pw > innerWidth - 8) x = innerWidth - pw - 8;
    if (y + ph > innerHeight - 8) y = Math.max(8, ar.top - ph - 6);
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
  }

  function wireActions(pop, title, kvPairs){
    const text = [title, ...kvPairs.map(([k,v])=>`${k}: ${v ?? '—'}`)].join('\n');
    const btnWA   = pop.querySelector('.wa');
    const btnSys  = pop.querySelector('.share');
    const btnCopy = pop.querySelector('.copy');
    const btnPNG  = pop.querySelector('.png');
    btnWA.addEventListener('click', ()=>{
      window.open('https://wa.me/?text=' + encodeURIComponent(text),'_blank','noopener');
    });
    btnSys.addEventListener('click', async ()=>{
      if (navigator.share){ try{ await navigator.share({ title, text }); }catch(e){} }
      else { window.open('https://wa.me/?text=' + encodeURIComponent(text),'_blank','noopener'); }
    });
    btnCopy.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(text); btnCopy.textContent='Copied'; setTimeout(()=>btnCopy.textContent='Copy text', 1200);}catch(e){}
    });
    btnPNG.addEventListener('click', async ()=>{
      const card = pop.querySelector('#month-pop-content');
      document.body.classList.add('__exporting');
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        const canvas = await window.html2canvas(card, {backgroundColor:'#ffffff', scale:2});
        const link = document.createElement('a');
        link.download = (title.replace(/\s+/g,'_') || 'share') + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } finally { document.body.classList.remove('__exporting'); }
    });
  }

  // Header mapping with broad variants
  function headerMap(){
    const map = {};
    const ths = document.querySelectorAll('table thead tr:last-child th');
    ths.forEach((th, i) => map[(th.textContent||'').trim().toLowerCase()] = i);
    const find = (...cands)=>{
      for (const [k,i] of Object.entries(map)){
        for (const c of cands){ if (k.includes(c)) return i; }
      }
      return null;
    };
    return {
      raw: map,
      month: find('month','mon'),
      target: find('target','req','needed'),
      expected: find('expected','estimate','estimated','expected inflow'),
      bank: find('bank','inflow','deposit','bank inflow','actual'),
      variance: find('variance','shortage','surplus','diff','delta'),
      notes: find('notes','note','remark','comment')
    };
  }

  function cellValue(td){
    if (!td) return '—';
    let v = td.getAttribute('data-clean') || td.getAttribute('data-value');
    const child = td.querySelector('[data-clean],[data-value],.value,.val,.amount,.num,.cell-text,.text,.money,.currency');
    if (!v && child) v = child.getAttribute('data-clean') || child.getAttribute('data-value') || child.textContent;
    if (!v){
      const inp = td.querySelector('input,textarea');
      if (inp) v = inp.value;
    }
    if (!v) v = td.textContent;
    v = (v||'').toString().replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim();
    return v || '—';
  }

  function extractFromRow(tr, fallbackIdx){
    const owner = (document.getElementById('ownerNameDisplay') ? document.getElementById('ownerNameDisplay').textContent : '—').trim() || '—';
    const yText = (document.getElementById('yearFancy') ? document.getElementById('yearFancy').textContent : (document.getElementById('yearInput') ? document.getElementById('yearInput').textContent : '—'));
    const year  = (yText || '—').replace(/\D+/g,'') || '—';

    const hm = headerMap();
    const tds = Array.from(tr.children);

    // Month label
    let monthLabel = '—';
    if (hm.month != null && tds[hm.month]){
      const mtxt = cellValue(tds[hm.month]);
      const ab = (mtxt||'').slice(0,3).toLowerCase();
      const idx = MONTHS.map(m=>m.toLowerCase()).indexOf(ab);
      monthLabel = idx>=0 ? MONTHS[idx] : (mtxt||'—');
    } else {
      const n = Number(cellValue(tds[0]));
      monthLabel = (n>=1 && n<=12) ? MONTHS[n-1] : `Row ${fallbackIdx+1}`;
    }

    const getVal = (idx) => (idx!=null && tds[idx]) ? cellValue(tds[idx]) : '—';
    const target   = getVal(hm.target);
    const expected = getVal(hm.expected);
    const bank     = getVal(hm.bank);
    const variance = getVal(hm.variance);
    const notes    = getVal(hm.notes);

    return { owner, year, month: monthLabel, target, expected, bank, variance, notes };
  }

  function numberCell(td){
    // accept first cell, or cells with class row-num/row-number, or any cell whose text is 1..12
    if (!td) return false;
    if (td.cellIndex === 0) return true;
    const cls = td.classList;
    if (cls && (cls.contains('row-num') || cls.contains('row-number') || cls.contains('index') || cls.contains('idx'))) return true;
    return isInt1to12(txt(td));
  }

  function enhanceRows(){
    const body = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!body) return;
    const rows = Array.from(body.querySelectorAll('tr'));
    rows.forEach((tr, idx) => {
      const tds = Array.from(tr.children);
      if (!tds.length) return;
      const td0 = tds[0];
      if (!numberCell(td0)) return;
      td0.classList.add('number-cell');
      // ensure a small ↗ is visible
      if (!td0.querySelector('.num-share')){
        const tip = document.createElement('span');
        tip.className = 'num-share';
        tip.title = 'Share this row';
        tip.textContent = '↗';
        td0.appendChild(tip);
      }
    });
  }

  // Delegated click handler: clicking the number cell opens share (even without the arrow)
  document.addEventListener('click', (e)=>{
    const td = e.target.closest('td');
    if (!td || !numberCell(td)) return;
    const tr = td.parentElement;
    const rowIdx = Array.from(tr.parentElement.children).indexOf(tr);
    const d = extractFromRow(tr, rowIdx);
    const title = `${d.owner} — ${d.year} • ${d.month}`;
    const kv = [
      ['Target', d.target],
      ['Expected', d.expected],
      ['Bank', d.bank],
      ['Variance', d.variance],
      ['Balance', d.accVariance || '—'],
      ['Notes', d.notes],
    ];
    const pop = buildCard(title, kv);
    document.querySelectorAll('.month-pop').forEach(n=>n.remove());
    document.body.appendChild(pop);
    positionPopover(pop, td);
  });
  document.addEventListener('click', (e)=>{
    const withinCard = e.target.closest('.month-pop');
    const isNumberCell = e.target.closest('td.number-cell');
    if (!withinCard && !isNumberCell){
      document.querySelectorAll('.month-pop').forEach(n=>n.remove());
    }
  });

  // Run now and on DOM changes
  enhanceRows();
  const obs = new MutationObserver(()=> enhanceRows());
  obs.observe(document.body, { childList:true, subtree:true });
})();
</script>
<script>
// === v9.3: Strong value detection for number-cell sharing ===
(function(){
  if (window.__shareOnNumberingV93) return;
  window.__shareOnNumberingV93 = true;

  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const txt = el => (el ? (el.textContent || '').trim() : '');
  const toNum = (s)=>{
    if (s==null) return NaN;
    const n = (''+s).replace(/[^0-9.-]/g,'');
    return parseFloat(n);
  };

  function isInt1to12(s){
    const n = Number((s||'').toString().trim());
    return Number.isInteger(n) && n>=1 && n<=12;
  }

  function pickOwner(){
    const cands = [
      '#ownerNameDisplay','[data-owner]','.owner-name','.header .owner','.ribbon .owner','.overview .owner'
    ];
    for (const sel of cands){
      const el = document.querySelector(sel);
      if (el && txt(el)) return txt(el);
    }
    // fallback to title prefix
    const t = document.title || '';
    const m = t.match(/^[^-–•|]+/);
    return m ? m[0].trim() : '—';
  }
  function pickYear(){
    const cands = ['#yearFancy','#yearInput','[data-year]','.year-display','.overview .year'];
    for (const sel of cands){
      const el = document.querySelector(sel);
      if (el && txt(el)) {
        const only = txt(el).replace(/\D+/g,'');
        if (only) return only;
      }
    }
    const t = document.title || '';
    const m = t.match(/(20\d{2})/);
    return m ? m[1] : '—';
  }

  // Choose header row with most ths
  function bestHeaderRow(){
    const rows = Array.from(document.querySelectorAll('table thead tr'));
    if (!rows.length) return null;
    let best = rows[0], bestCount = 0;
    rows.forEach(r=>{
      const c = r.querySelectorAll('th').length;
      if (c > bestCount){ best = r; bestCount = c; }
    });
    return best;
  }

  function headerMap(){
    const map = {};
    const hr = bestHeaderRow();
    const ths = hr ? Array.from(hr.querySelectorAll('th')) : [];
    ths.forEach((th, i) => map[(txt(th) || '').toLowerCase()] = i);
    const find = (...cands)=>{
      // 1) by header text includes
      for (const [k,i] of Object.entries(map)){
        for (const c of cands){ if (k.includes(c)) return i; }
      }
      // 2) by data-field across table (use first occurrence's index)
      const fields = ['target','expected','bank','variance','notes','month'];
      for (const c of cands){
        if (fields.includes(c)){
          const cell = document.querySelector(`tbody td[data-field="${c}"], tbody td[data-field*="${c}"]`);
          if (cell) return cell.cellIndex;
        }
      }
      return null;
    };
    return {
      raw: map,
      month: find('month','mon'),
      target: find('target','req','needed'),
      expected: find('expected inflow','expected','estimate','estimated'),
      bank: find('bank inflow','bank','inflow','deposit','actual'),
      variance: find('variance','shortage','surplus','diff','delta'),
      notes: find('notes','note','remark','comment')
    };
  }

  function cellValue(td){
    if (!td) return '—';
    let v = td.getAttribute('data-clean') || td.getAttribute('data-value');
    const child = td.querySelector('[data-clean],[data-value],.value,.val,.amount,.num,.cell-text,.text,.money,.currency');
    if (!v && child) v = child.getAttribute('data-clean') || child.getAttribute('data-value') || child.textContent;
    if (!v){
      const inp = td.querySelector('input,textarea');
      if (inp) v = inp.value;
    }
    if (!v) v = td.textContent;
    v = (v||'').toString().replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim();
    return v || '—';
  }

  function extractFromRow(tr, fallbackIdx){
    const owner = pickOwner();
    const year  = pickYear();

    const hm = headerMap();
    const tds = Array.from(tr.children);

    // Month label
    let monthLabel = '—';
    if (hm.month != null && tds[hm.month]){
      const mtxt = cellValue(tds[hm.month]);
      const ab = (mtxt||'').slice(0,3).toLowerCase();
      const idx = MONTHS.map(m=>m.toLowerCase()).indexOf(ab);
      monthLabel = idx>=0 ? MONTHS[idx] : (mtxt||'—');
    } else {
      const n = Number(cellValue(tds[0]));
      monthLabel = (n>=1 && n<=12) ? MONTHS[n-1] : `Row ${fallbackIdx+1}`;
    }

    const getVal = (idx) => (idx!=null && tds[idx]) ? cellValue(tds[idx]) : '—';
    let target   = getVal(hm.target);
    let expected = getVal(hm.expected);
    let bank     = getVal(hm.bank);
    let variance = getVal(hm.variance);
    let notes    = getVal(hm.notes);

    // If variance empty, compute (bank - expected) or (bank - target)
    if (!variance || variance === '—'){
      const b = toNum(bank), e = toNum(expected), t = toNum(target);
      if (!isNaN(b) && !isNaN(e)) {
        variance = (b - e).toLocaleString();
      } else if (!isNaN(b) && !isNaN(t)) {
        variance = (b - t).toLocaleString();
      }
    }

    return { owner, year, month: monthLabel, target, expected, bank, variance, notes };
  }

  function buildCard(title, kvPairs){
    const pop = document.createElement('div');
    pop.className = 'month-pop is-fixed share-card';
    pop.setAttribute('role','dialog');
    const kvHtml = kvPairs.map(([k,v])=>`<div>${k}</div><div>${v ?? '—'}</div>`).join('');
    pop.innerHTML = `
      <div id="month-pop-content">
        <h4>${title}</h4>
        <div class="kv">${kvHtml}</div>
        <div class="actions">
          <button class="wa">WhatsApp</button>
          <button class="share">Share…</button>
          <button class="copy ghost">Copy text</button>
          <button class="png ghost">PNG</button>
        </div>
      </div>`;
    return pop;
  }

  function positionPopover(pop, anchorEl){
    const ar = anchorEl.getBoundingClientRect();
    const pw = 280, ph = 210;
    let x = ar.right - pw;
    let y = ar.bottom + 6;
    if (x < 8) x = Math.max(8, ar.left);
    if (x + pw > innerWidth - 8) x = innerWidth - pw - 8;
    if (y + ph > innerHeight - 8) y = Math.max(8, ar.top - ph - 6);
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
  }

  function wireActions(pop, title, kvPairs){
    const text = [title, ...kvPairs.map(([k,v])=>`${k}: ${v ?? '—'}`)].join('\n');
    const btnWA   = pop.querySelector('.wa');
    const btnSys  = pop.querySelector('.share');
    const btnCopy = pop.querySelector('.copy');
    const btnPNG  = pop.querySelector('.png');
    btnWA.addEventListener('click', ()=>{
      window.open('https://wa.me/?text=' + encodeURIComponent(text),'_blank','noopener');
    });
    btnSys.addEventListener('click', async ()=>{
      if (navigator.share){ try{ await navigator.share({ title, text }); }catch(e){} }
      else { window.open('https://wa.me/?text=' + encodeURIComponent(text),'_blank','noopener'); }
    });
    btnCopy.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(text); btnCopy.textContent='Copied'; setTimeout(()=>btnCopy.textContent='Copy text', 1200);}catch(e){}
    });
    btnPNG.addEventListener('click', async ()=>{
      const card = pop.querySelector('#month-pop-content');
      document.body.classList.add('__exporting');
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        const canvas = await window.html2canvas(card, {backgroundColor:'#ffffff', scale:2});
        const link = document.createElement('a');
        link.download = (title.replace(/\s+/g,'_') || 'share') + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } finally { document.body.classList.remove('__exporting'); }
    });
  }

  function numberCell(td){
    if (!td) return false;
    if (td.cellIndex === 0) return true;
    const cls = td.classList;
    if (cls && (cls.contains('row-num') || cls.contains('row-number') || cls.contains('index') || cls.contains('idx'))) return true;
    return isInt1to12(txt(td));
  }

  function enhanceRows(){
    const body = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!body) return;
    const rows = Array.from(body.querySelectorAll('tr'));
    rows.forEach((tr, idx) => {
      const tds = Array.from(tr.children);
      if (!tds.length) return;
      const td0 = tds[0];
      if (!numberCell(td0)) return;
      td0.classList.add('number-cell');
      if (!td0.querySelector('.num-share')){
        const tip = document.createElement('span');
        tip.className = 'num-share';
        tip.title = 'Share this row';
        tip.textContent = '↗';
        td0.appendChild(tip);
      }
    });
  }

  // Delegated click: open share when clicking the number cell
  document.addEventListener('click', (e)=>{
    const td = e.target.closest('td');
    if (!td || !numberCell(td)) return;
    const tr = td.parentElement;
    const rowIdx = Array.from(tr.parentElement.children).indexOf(tr);

    const d = extractFromRow(tr, rowIdx);
    const title = `${d.owner} — ${d.year} • ${d.month}`;
    const kv = [
      ['Target', d.target],
      ['Expected', d.expected],
      ['Bank', d.bank],
      ['Variance', d.variance],
      ['Balance', d.accVariance || '—'],
      ['Notes', d.notes],
    ];
    const pop = buildCard(title, kv);
    document.querySelectorAll('.month-pop').forEach(n=>n.remove());
    document.body.appendChild(pop);
    positionPopover(pop, td);
    wireActions(pop, title, kv);
  });

  // Close when clicking outside
  document.addEventListener('click', (e)=>{
    const withinCard = e.target.closest('.month-pop');
    const isNumberCell = e.target.closest('td.number-cell');
    if (!withinCard && !isNumberCell){
      document.querySelectorAll('.month-pop').forEach(n => n.remove());
    }
  });

  // Run now + observe for dynamic updates
  enhanceRows();
  const obs = new MutationObserver(()=> enhanceRows());
  obs.observe(document.body, { childList:true, subtree:true });
})();
</script>
<script>
// === v9.5: Popover always-visible logic (flip + resize/scroll tracking) ===
(function(){
  if (window.__popoverFixV95) return;
  window.__popoverFixV95 = true;

  // Store the last open popover + anchor
  window.__openSharePopover = null;

  function computePosition(anchorEl, popSize){
    const ar = anchorEl.getBoundingClientRect();
    const pw = popSize.width  || 300;
    const ph = popSize.height || 200;
    let x = ar.right - pw;
    let y = ar.bottom + 8;
    let posAttr = 'below';

    // Left clamp
    if (x < 8) x = Math.max(8, ar.left);
    // Right clamp
    if (x + pw > window.innerWidth - 8) x = window.innerWidth - pw - 8;
    // If bottom overflow, flip above
    if (y + ph > window.innerHeight - 8) {
      y = Math.max(8, ar.top - ph - 8);
      posAttr = 'above';
    }
    return { x, y, posAttr };
  }

  function positionAndRemember(pop, anchorEl){
    // measure pop rough size
    const rect = pop.getBoundingClientRect();
    const { x, y, posAttr } = computePosition(anchorEl, {width: rect.width || 300, height: rect.height || 220});
    pop.style.setProperty('--pop-x', x + 'px');
    pop.style.setProperty('--pop-y', y + 'px');
    pop.setAttribute('data-pos', posAttr);
    window.__openSharePopover = { pop, anchorEl };
  }

  // Patch existing creators that call positionPopover(...)
  // We hook into document.body.appendChild to detect our popovers consistently.
  const originalAppend = Document.prototype.appendChild;
  Document.prototype.appendChild = function(child){
    const res = originalAppend.call(this, child);
    try {
      if (child && child.classList && child.classList.contains('month-pop')) {
        // Find the last click target as anchor (closest of known triggers)
        const anchorEl =
          window.__lastShareAnchor ||
          document.querySelector('.month-share-icon:focus, .num-share:focus') ||
          document.activeElement ||
          document.querySelector('.month-share-icon, .num-share');
        if (anchorEl) positionAndRemember(child, anchorEl);
      }
    } catch(e){}
    return res;
  };

  // Record the last anchor on mousedown for better accuracy
  document.addEventListener('mousedown', (e)=>{
    const a = e.target.closest('.month-share-icon, .num-share, td.number-cell, .share-icon, .table-row-share');
    if (a) window.__lastShareAnchor = a;
  }, true);

  // Reposition on scroll/resize
  function maybeReposition(){
    const ctx = window.__openSharePopover;
    if (!ctx || !ctx.pop || !ctx.anchorEl || !document.body.contains(ctx.pop)) return;
    positionAndRemember(ctx.pop, ctx.anchorEl);
  }
  window.addEventListener('scroll', maybeReposition, true);
  window.addEventListener('resize', maybeReposition);

  // Also patch legacy positionPopover if present
  if (typeof window.positionPopover === 'function' && !window.positionPopover.__v95Wrapped){
    const old = window.positionPopover;
    window.positionPopover = function(pop, anchorEl){
      const r = old(pop, anchorEl);
      positionAndRemember(pop, anchorEl);
      return r;
    };
    window.positionPopover.__v95Wrapped = true;
  }

  // Close on outside click while preserving open state tracking
  document.addEventListener('click', (e) => {
    const isPop = e.target.closest('.month-pop');
    const isTrigger = e.target.closest('.month-share-icon, .num-share, td.number-cell, .share-icon, .table-row-share');
    if (!isPop && !isTrigger){
      document.querySelectorAll('.month-pop').forEach(n => n.remove());
      window.__openSharePopover = null;
    }
  });
})();
</script>
<script>
// === v9.8: Force Balance to display by computing if missing ===
(function(){
  if (window.__accVarianceForceV98) return;
  window.__accVarianceForceV98 = true;

  const MONTHS = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
  const txt = el => (el ? (el.textContent || '').trim() : '');
  const toNum = (s)=>{
    if (s==null) return NaN;
    const n = (''+s).replace(/[^0-9.-]/g,'');
    const f = parseFloat(n);
    return isNaN(f) ? NaN : f;
  };
  const cellValue = (td) => {
    if (!td) return '';
    let v = td.getAttribute('data-clean') || td.getAttribute('data-value');
    const child = td.querySelector('[data-clean],[data-value],.value,.val,.amount,.num,.cell-text,.text,.money,.currency');
    if (!v && child) v = child.getAttribute('data-clean') || child.getAttribute('data-value') || child.textContent;
    if (!v){
      const inp = td.querySelector('input,textarea');
      if (inp) v = inp.value;
    }
    if (!v) v = td.textContent;
    return (v||'').toString().replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim();
  };

  function bestHeaderRow(){
    const rows = Array.from(document.querySelectorAll('table thead tr'));
    if (!rows.length) return null;
    let best = rows[0], bestCount = 0;
    rows.forEach(r=>{
      const c = r.querySelectorAll('th').length;
      if (c > bestCount){ best = r; bestCount = c; }
    });
    return best;
  }

  function headerIdx(){
    const hr = bestHeaderRow();
    const ths = hr ? Array.from(hr.querySelectorAll('th')) : [];
    const map = {};
    ths.forEach((th,i)=> map[(txt(th)||'').toLowerCase()] = i);
    const find = (...cands)=>{
      for (const [k,i] of Object.entries(map)){
        for (const c of cands){ if (k.includes(c)) return i; }
      }
      // Try by data-field scanning tbody
      for (const c of cands){
        const cell = document.querySelector(`tbody td[data-field="${c}"], tbody td[data-field*="${c}"]`);
        if (cell) return cell.cellIndex;
      }
      return null;
    };
    return {
      month: find('month','mon'),
      variance: find('variance','shortage','surplus','diff','delta'),
      accvar: find('balance','accum','acc','cumulative','ytd variance','ytd var','acc variance','accumulated','acc var','accum variance','cum var')
    };
  }

  function findMonthRowByLabel(label){
    const idxs = headerIdx();
    const mIdx = idxs.month;
    const rows = Array.from((document.getElementById('tableBody')||document.querySelector('table tbody')||document).querySelectorAll('tr'));
    if (mIdx==null) return null;
    const ab = (label||'').slice(0,3).toLowerCase();
    for (const tr of rows){
      const tds = Array.from(tr.children);
      if (!tds[mIdx]) continue;
      const cellAb = (cellValue(tds[mIdx]).slice(0,3)||'').toLowerCase();
      if (cellAb === ab) return tr;
    }
    return null;
  }

  function computeAccumVarianceUpTo(tr){
    const idxs = headerIdx();
    const tbody = tr.parentElement;
    const rows = Array.from(tbody.children);
    const varIdx = idxs.variance;
    if (varIdx==null) return null;
    let sum = 0;
    for (const r of rows){
      const tds = Array.from(r.children);
      const v = toNum(cellValue(tds[varIdx]));
      if (!isNaN(v)) sum += v;
      if (r === tr) break;
    }
    return sum;
  }

  function patchAccumVariance(pop){
    // find label cell "Balance" and its value cell
    const kv = pop.querySelector('.kv');
    if (!kv) return;
    const items = Array.from(kv.children);
    let labelEl = null, valueEl = null;
    for (let i=0;i<items.length;i+=2){
      const label = (items[i] && txt(items[i]).toLowerCase()) || '';
      if (label.includes('balance') || label.includes('accum')) { labelEl = items[i]; valueEl = items[i+1]; break; }
    }
    // If not present, insert after "Variance"
    if (!labelEl){
      for (let i=0;i<items.length;i+=2){
        const label = (items[i] && txt(items[i]).toLowerCase()) || '';
        if (label.includes('variance') && !label.includes('accum') && !label.includes('balance')) {
          labelEl = document.createElement('div');
          labelEl.textContent = 'Balance';
          valueEl = document.createElement('div');
          valueEl.textContent = '—';
          kv.insertBefore(valueEl, items[i+2] || null);
          kv.insertBefore(labelEl, valueEl);
          break;
        }
      }
      // refresh items
    }
    if (!labelEl || !valueEl) return;

    
    // Force the visible label name to 'Balance'
    labelEl.textContent = 'Balance';
// If value already present (not em-dash), we keep it
    const current = txt(valueEl);
    if (current && current !== '—') return;

    // Determine the anchor that opened the popover
    const anchor = window.__lastShareAnchor || document.activeElement;
    let tr = null;

    if (anchor){
      // Case A: row-number or inside table
      const trTry = anchor.closest('tr');
      if (trTry && trTry.parentElement && trTry.parentElement.tagName.toLowerCase()==='tbody'){
        tr = trTry;
      } else {
        // Case B: month pill — find the month row by data-month attribute
        const pill = anchor.closest('.month-pill') || anchor.closest('#monthsMini .month-pill');
        if (pill){
          const monthNum = pill.getAttribute('data-month');
          if (monthNum) {
            // Look for row with matching data-month or first cell equals monthNum
            tr = document.querySelector(`tbody tr[data-month="${monthNum}"]`);
            if (!tr) {
              const rows = Array.from((document.getElementById('tableBody')||document.querySelector('table tbody')||document).querySelectorAll('tr'));
              for (const row of rows) {
                const td0 = row.querySelector('td');
                if (td0) {
                  const n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
                  if (n == monthNum) {
                    tr = row;
                    break;
                  }
                }
              }
            }
          }
          // Fallback to old method if data-month approach fails
          if (!tr) {
            const label = txt(pill).split(/\s+/)[0];
            tr = findMonthRowByLabel(label);
          }
        }
      }
    }

    if (!tr) return;

    // Try direct accvar column first
    const idxs = headerIdx();
    if (idxs.accvar != null){
      const tds = Array.from(tr.children);
      if (tds[idxs.accvar]){
        const val = cellValue(tds[idxs.accvar]);
        if (val && val !== '—'){ valueEl.textContent = val; return; }
      }
    }

    // Otherwise, compute from Variance sum up to this row
    const sum = computeAccumVarianceUpTo(tr);
    if (sum != null){
      valueEl.textContent = sum.toLocaleString();
    }
  }

  // Track last anchor
  document.addEventListener('mousedown', (e)=>{
    const a = e.target.closest('.month-share-icon, .num-share, td.number-cell, .share-icon, .table-row-share');
    if (a) window.__lastShareAnchor = a;
  }, true);

  // Watch for new popovers
  const obs = new MutationObserver((muts)=>{
    for (const m of muts){
      for (const n of m.addedNodes){
        if (n.nodeType===1 && n.classList && n.classList.contains('month-pop')){
          try { patchAccumVariance(n); } catch(e){}
        }
      }
    }
  });
  obs.observe(document.body, { childList: true, subtree: true });
})();
</script>
<!-- === Owner Persistence Patch (keep owner across year changes + custom labels) === -->
<script>
(function(){
  var SELECT_KEY = 'selectedOwnerId';
  var LABEL_KEY_PREFIX = 'ownerLabel:'; // per-owner custom label

  function byId(id){ return document.getElementById(id); }

  function getOwnerSelect(){ return byId('ownerSelect'); }
  function getOwnerNameDisplay(){ return byId('ownerNameDisplay'); }

  function getSelectedOwnerId(){
    var sel = getOwnerSelect();
    return sel ? (sel.value || sel.options[sel.selectedIndex]?.value) : null;
  }

  function setSelectedOwnerId(id){
    var sel = getOwnerSelect();
    if (!sel) return;
    if (id && sel.value !== id){
      sel.value = id;
      // if your app has onOwnerChange handlers, try to notify them safely
      try { sel.dispatchEvent(new Event('change')); } catch(e){}
    }
    try { localStorage.setItem(SELECT_KEY, id || ''); } catch(e){}
  }

  function getDefaultOwnerLabel(id){
    var sel = getOwnerSelect();
    if (!sel) return id || '—';
    var opt = id ? Array.from(sel.options).find(o => o.value === id) : sel.options[sel.selectedIndex];
    return (opt && (opt.textContent || opt.label || opt.value)) || id || '—';
  }

  function getCustomOwnerLabel(id){
    try { return localStorage.getItem(LABEL_KEY_PREFIX + id) || ''; } catch(e){ return ''; }
  }

  function setCustomOwnerLabel(id, name){
    try { localStorage.setItem(LABEL_KEY_PREFIX + id, name || ''); } catch(e){}
  }

  function getEffectiveOwnerLabel(id){
    return getCustomOwnerLabel(id) || getDefaultOwnerLabel(id);
  }

  function renderOwnerName(){
    var disp = getOwnerNameDisplay();
    var id = getSelectedOwnerId();
    if (!disp || !id) return;
    disp.textContent = getEffectiveOwnerLabel(id);
  }

  function initOwnerPersistence(){
    var sel = getOwnerSelect();
    if (!sel) return;

    // 1) Restore previously selected owner, if any
    var savedId = null;
    try { savedId = localStorage.getItem(SELECT_KEY); } catch(e){}
    if (savedId && Array.from(sel.options).some(o => o.value === savedId)){
      sel.value = savedId;
    } else {
      // if nothing stored, store current selection as baseline
      try { localStorage.setItem(SELECT_KEY, sel.value || sel.options[sel.selectedIndex]?.value || ''); } catch(e){}
    }
    renderOwnerName();

    // 2) Save owner selection on change and re-render name
    sel.addEventListener('change', function(){
      try { localStorage.setItem(SELECT_KEY, sel.value || ''); } catch(e){}
      renderOwnerName();
    });

    // 3) Allow renaming owner label by double-clicking the big owner name
    var disp = getOwnerNameDisplay();
    if (disp && !disp.__renameHooked){
      disp.__renameHooked = true;
      disp.title = 'Double‑click to rename this owner label';
      disp.addEventListener('dblclick', function(){
        var id = getSelectedOwnerId();
        if (!id) return;
        var current = getEffectiveOwnerLabel(id);
        var name = prompt('Owner label for "' + id + '":', current);
        if (name == null) return;
        name = String(name).trim();
        setCustomOwnerLabel(id, name);
        renderOwnerName();
      });
    }

    // 4) On year changes, do NOT change owner. Re-render the name in case other code changed it.
    document.addEventListener('year-change', function(){
      // Ensure select stays on saved owner id
      var saved = null;
      try { saved = localStorage.getItem(SELECT_KEY); } catch(e){}
      if (saved && sel.value !== saved){
        sel.value = saved;
      }
      // Re-apply the label (in case something overwrote it)
      renderOwnerName();
      // After layout/other handlers run, enforce again
      setTimeout(function(){
        var saved2 = null;
        try { saved2 = localStorage.getItem(SELECT_KEY); } catch(e){}
        if (saved2 && sel.value !== saved2){
          sel.value = saved2;
        }
        renderOwnerName();
      }, 0);
    }, { passive: true });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initOwnerPersistence);
  } else {
    initOwnerPersistence();
  }
})();
</script>
<!-- === Owner Persistence Patch v2 (hard enforce across year toggles & mutations) === -->
<script>
(function(){
  var SELECT_KEY = 'selectedOwnerId';
  var LABEL_KEY_PREFIX = 'ownerLabel:'; // per-owner custom label
  var _updatingOwner = false;           // guard to avoid loops

  function byId(id){ return document.getElementById(id); }
  function selEl(){ return byId('ownerSelect'); }
  function nameEl(){ return byId('ownerNameDisplay'); }

  function getSavedOwnerId(){
    try { return localStorage.getItem(SELECT_KEY) || ''; } catch(e){ return ''; }
  }
  function setSavedOwnerId(id){
    try { localStorage.setItem(SELECT_KEY, id || ''); } catch(e){}
  }
  function getCustomLabel(id){
    try { return localStorage.getItem(LABEL_KEY_PREFIX + id) || ''; } catch(e){ return ''; }
  }
  function setCustomLabel(id, label){
    try { localStorage.setItem(LABEL_KEY_PREFIX + id, label || ''); } catch(e){}
  }
  function defaultLabel(id){
    var s = selEl(); if (!s) return id || '—';
    var opt = Array.from(s.options).find(o => o.value === id);
    return (opt && (opt.textContent || opt.label || opt.value)) || id || '—';
  }
  function effectiveLabel(id){
    return getCustomLabel(id) || defaultLabel(id);
  }

  function enforceOwner(targetId){
    var s = selEl(); if (!s) return;
    var id = targetId || getSavedOwnerId() || s.value || (s.options[s.selectedIndex] && s.options[s.selectedIndex].value);
    if (!id) return;
    if (s.value !== id){
      _updatingOwner = true;
      s.value = id;
      // fire change so rest of app reacts, but guard prevents re-entry
      try { s.dispatchEvent(new Event('change', {bubbles:true})); } catch(e){}
      _updatingOwner = false;
    }
    // render name
    var d = nameEl(); if (d) d.textContent = effectiveLabel(id);
  }

  function init(){
    var s = selEl(); if (!s) return;

    // Restore or set baseline
    var saved = getSavedOwnerId();
    if (saved && Array.from(s.options).some(o => o.value === saved)){
      enforceOwner(saved);
    } else {
      setSavedOwnerId(s.value);
      enforceOwner(s.value);
    }

    // When user changes owner via dropdown, persist
    s.addEventListener('change', function(){
      if (_updatingOwner) return;
      setSavedOwnerId(s.value);
      enforceOwner(s.value);
    });

    // Allow rename by double click on title
    var d = nameEl();
    if (d && !d.__renameHook){
      d.__renameHook = true;
      d.title = 'Double‑click to rename this owner label';
      d.addEventListener('dblclick', function(){
        var id = getSavedOwnerId() || (s.value || '');
        if (!id) return;
        var cur = effectiveLabel(id);
        var name = prompt('Owner label for "' + id + '":', cur);
        if (name == null) return;
        setCustomLabel(id, String(name).trim());
        enforceOwner(id);
      });
    }

    // MutationObserver: if any script or DOM change attempts to switch owner, revert to saved
    try {
      var mo = new MutationObserver(function(){
        // small debounce
        clearTimeout(mo._t); mo._t = setTimeout(function(){ enforceOwner(); }, 0);
      });
      mo.observe(s, { attributes: true, childList: true, subtree: false });
    } catch(e){}

    // Year controls: after year button clicks / keydowns, re-enforce selection
    var nextBtn = byId('yearToggleBtn');
    var prevBtn = byId('yearPrevBtn');
    var fancy   = byId('yearFancy');

    function afterYearChange(){
      // schedule a couple of passes to win against other handlers
      enforceOwner();
      setTimeout(enforceOwner, 0);
      setTimeout(enforceOwner, 50);
      setTimeout(enforceOwner, 150);
    }

    [nextBtn, prevBtn].forEach(function(btn){
      if (!btn) return;
      btn.addEventListener('click', function(){ afterYearChange(); }, true); // capture
      btn.addEventListener('click', function(){ afterYearChange(); });       // bubble
    });
    if (fancy){
      fancy.addEventListener('keydown', function(e){
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Home'){
          setTimeout(afterYearChange, 0);
        }
      });
      // some builds used wheel to change year
      fancy.addEventListener('wheel', function(){ setTimeout(afterYearChange, 0); }, { passive: true });
    }

    // As a final safety net, do a short-lived drift check right after load
    var t0 = Date.now();
    var driftTimer = setInterval(function(){
      enforceOwner();
      if (Date.now() - t0 > 2500) clearInterval(driftTimer);
    }, 120);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
<!-- === Next Year Target Reset Patch (auto-clear when no entries) === -->
<script>
(function(){
  function byId(id){ return document.getElementById(id); }
  function q(sel){ return document.querySelector(sel); }
  var MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  function ensureNote(){
    return null;
  }

  function pickFirstAmount(obj){
    if (!obj) return null;
    // common property names we used in prior builds
    var fields = ['expected','target','expectedInflow','expectedAmount','monthTarget'];
    for (var i=0;i<MONTHS.length;i++){
      var m = MONTHS[i];
      var rec = obj[m] || obj[m.toLowerCase()] || obj[i+1] || null; // support {1:..} by index
      if (!rec) continue;
      var val = null;
      if (typeof rec === 'number') { val = rec; }
      else if (rec && typeof rec === 'object'){
        for (var k=0;k<fields.length;k++){
          var f = fields[k];
          if (typeof rec[f] === 'number') { val = rec[f]; break; }
          if (typeof rec[f] === 'string' && rec[f].trim() !== ''){
            var num = parseFloat(String(rec[f]).replace(/[^0-9.\-]/g,''));
            if (!isNaN(num)) { val = num; break; }
          }
        }
      }
      if (val && isFinite(val) && val > 0){
        return { month: m, amount: val };
      }
    }
    return null;
  }

  function readNextYearData(nextY){
    // Try app helpers first
    try { if (typeof window.getYearData === 'function'){ return window.getYearData(nextY); } } catch(e){}
    try { if (typeof window.loadYearData === 'function'){ return window.loadYearData(nextY); } } catch(e){}
    // Try per-year storage key
    try { 
      if (typeof window.getStorageKey === 'function'){
        var key = window.getStorageKey(nextY);
        var raw = localStorage.getItem(key);
        if (raw){ try { return JSON.parse(raw); } catch(e){} }
      }
    } catch(e){}
    // Fallback: scan localStorage for a key containing the year and parse
    try {
      for (var i=0;i<localStorage.length;i++){
        var k = localStorage.key(i);
        if (k && (k.includes(String(nextY)) || k.endsWith(String(nextY)))){
          var raw = localStorage.getItem(k);
          try { var obj = JSON.parse(raw); if (obj) return obj; } catch(e){}
        }
      }
    } catch(e){}
    return null;
  }

  function formatAED(n){
    try { return new Intl.NumberFormat('en-AE',{minimumFractionDigits:0, maximumFractionDigits:0}).format(n); }
    catch(e){ return String(n); }
  }

  function refreshNextYearTarget(){
    var note = ensureNote(); if (!note) return;
    var curY = (window.currentYear && Number(window.currentYear)) || (new Date()).getFullYear();
    var nextY = curY + 1;

    var data = readNextYearData(nextY);
    var monthsObj = null;

    // Normalize to months structure if we know likely shape
    if (data){
      // Common shapes we used:
      // { months: { Jan: {expected:...}, ... } }
      if (data.months && typeof data.months === 'object'){
        monthsObj = data.months;
      } else if (data.nextYear && data.nextYear.months){
        monthsObj = data.nextYear.months;
      } else if (data && typeof data === 'object'){
        monthsObj = data; // last resort: treat top-level as months map
      }
    }

    var pick = pickFirstAmount(monthsObj);
    if (pick){
      // note.textContent = 'Next Year Target :- The month of ' + pick.month + ' | The amount of ' + formatAED(pick.amount);
      note.textContent = '';
    } else {
      // note.textContent = 'Next Year Target :- No entries yet';
      note.textContent = '';
    }
  }

  // Run on load, on year-change, and after a tiny delay (in case app fills data async)
  function init(){
    ensureNote();
    refreshNextYearTarget();
    setTimeout(refreshNextYearTarget, 0);
    setTimeout(refreshNextYearTarget, 200);
    setTimeout(refreshNextYearTarget, 800);

    document.addEventListener('year-change', function(){
      refreshNextYearTarget();
      setTimeout(refreshNextYearTarget, 0);
      setTimeout(refreshNextYearTarget, 200);
      setTimeout(refreshNextYearTarget, 800);
    }, { passive: true });

    // If storage changes in another tab/window, update
    window.addEventListener('storage', function(e){
      refreshNextYearTarget();
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }
})();
</script>
<!-- === Owner Persistence (SAFE) — persist across years, allow manual switching === -->
<script>
(function(){
  var SELECT_KEY = 'selectedOwnerId';
  var LABEL_KEY_PREFIX = 'ownerLabel:';

  function byId(id){ return document.getElementById(id); }
  function sel(){ return byId('ownerSelect'); }
  function title(){ return byId('ownerNameDisplay'); }

  function getSavedId(){ try { return localStorage.getItem(SELECT_KEY) || ''; } catch(e){ return ''; } }
  function setSavedId(v){ try { localStorage.setItem(SELECT_KEY, v || ''); } catch(e){} }
  function getLabel(id){ try { return localStorage.getItem(LABEL_KEY_PREFIX + id) || ''; } catch(e){ return ''; } }
  function setLabel(id,s){ try { localStorage.setItem(LABEL_KEY_PREFIX + id, s || ''); } catch(e){} }
  function defaultLabel(id){
    var s = sel(); if (!s) return id || '—';
    var opt = Array.from(s.options).find(o=>o.value===id) || s.options[s.selectedIndex];
    return (opt && (opt.textContent || opt.label || opt.value)) || id || '—';
  }
  function render(id){
    var t = title(); if (!t) return;
    t.textContent = (getLabel(id) || defaultLabel(id));
  }

  function applySavedOwner(){
    var s = sel(); if (!s) return;
    var id = getSavedId();
    if (id && Array.from(s.options).some(o=>o.value===id)){
      s.value = id;
      // Notify app
      try { s.dispatchEvent(new Event('change', {bubbles:true})); } catch(e){}
      render(id);
    } else {
      // Bootstrap current selection
      setSavedId(s.value || s.options[s.selectedIndex].value);
      render(getSavedId());
    }
  }

  function init(){
    var s = sel(); if (!s) return;

    // Restore on load
    applySavedOwner();

    // Allow manual switching freely; persist new choice
    s.addEventListener('change', function(){
      setSavedId(s.value);
      render(s.value);
    });

    // Double-click big name to rename label for current owner id
    var t = title();
    if (t && !t.__renameLabel){
      t.__renameLabel = true;
      t.title = 'Double‑click to rename this owner label (persists across years)';
      t.addEventListener('dblclick', function(){
        var id = getSavedId() || (s.value || '');
        if (!id) return;
        var cur = getLabel(id) || defaultLabel(id);
        var neo = prompt('Owner label for "'+id+'":', cur);
        if (neo == null) return;
        setLabel(id, String(neo).trim());
        render(id);
      });
    }

    // Re-apply saved owner after year changes (but do NOT block user switching)
    function onYearMoved(){
      // wait for other handlers to finish, then re-apply the SAME saved owner
      setTimeout(applySavedOwner, 0);
      setTimeout(applySavedOwner, 150);
    }
    document.addEventListener('year-change', onYearMoved, { passive: true });

    // Also hook the obvious buttons as fallback
    ['yearToggleBtn','yearPrevBtn','yearFancy'].forEach(function(id){
      var el = byId(id); if (!el) return;
      el.addEventListener('click', function(){ onYearMoved(); }, true);
      el.addEventListener('click', function(){ onYearMoved(); });
      el.addEventListener('keydown', function(e){
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'Home'){
          setTimeout(onYearMoved, 0);
        }
      });
      el.addEventListener('wheel', function(){ setTimeout(onYearMoved, 0); }, { passive: true });
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }
})();
</script>
<script>
// === Next Year Target render logic (v3) ===
// Shows "No entries yet" when next year has no saved targets,
// otherwise shows: "- Next Year Target :- The month of {Mon} | The amount of {amount} AED"
(function(){
  // Heuristic: try to pull next year's saved data using existing getStorageKey(owner, year) if available.
  function _getOwnerValue(){
    try {
      var sel = document.getElementById('ownerSelect');
      if (sel) return sel.value || 'owner1';
    } catch(e){}
    return 'owner1';
  }
  function _getYearFancyValue(){
    var yf = document.getElementById('yearFancy');
    if (yf && yf.textContent && yf.textContent.trim() !== '—') {
      var y = parseInt(yf.textContent.trim(), 10);
      if (!isNaN(y)) return y;
    }
    // fallback to numeric input if visible/exists
    var yi = document.getElementById('yearInput');
    if (yi && yi.value) {
      var y2 = parseInt(yi.value, 10);
      if (!isNaN(y2)) return y2;
    }
    return (new Date()).getFullYear();
  }
  function _monthName(idx){
    var m = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    return m[Math.max(0, Math.min(11, idx))];
  }
  function _coerceNumber(x){
    if (typeof x === 'number') return x;
    if (typeof x === 'string'){
      // strip AED, commas, spaces
      var s = x.replace(/[^\d.\-]/g,'').trim();
      var n = parseFloat(s);
      if (!isNaN(n)) return n;
    }
    return null;
  }
  function _findTargetsInObject(obj){
    // Flexible: search for an array of months with target/expected amounts.
    // We return list like [{month: 0-11, amount: number}, ...]
    var results = [];

    function scan(arrOrObj){
      if (!arrOrObj) return;
      if (Array.isArray(arrOrObj)){
        arrOrObj.forEach(scan);
        return;
      }
      if (typeof arrOrObj === 'object'){
        // common patterns:
        // { month: "Jan"/0/1..., target: 100 } or { monthName: "Apr", expected: "2000" } etc.
        var mIdx = null;
        if ('month' in arrOrObj){
          var mv = arrOrObj.month;
          if (typeof mv === 'number') mIdx = Math.max(0, Math.min(11, mv));
          else if (typeof mv === 'string'){
            var i = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"]
              .indexOf(mv.slice(0,3).toLowerCase());
            if (i >= 0) mIdx = i;
          }
        } else if ('monthName' in arrOrObj && typeof arrOrObj.monthName === 'string'){
          var i2 = ["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"]
            .indexOf(arrOrObj.monthName.slice(0,3).toLowerCase());
          if (i2 >= 0) mIdx = i2;
        }

        var amt = null;
        if ('target' in arrOrObj) amt = _coerceNumber(arrOrObj.target);
        if (amt == null && 'expected' in arrOrObj) amt = _coerceNumber(arrOrObj.expected);
        if (amt == null && 'amount' in arrOrObj) amt = _coerceNumber(arrOrObj.amount);

        if (mIdx != null && amt != null && amt > 0){
          results.push({month:mIdx, amount:amt});
        }
        // recurse children
        Object.keys(arrOrObj).forEach(function(k){ scan(arrOrObj[k]); });
      }
    }
    scan(obj);
    return results;
  }

  function getNextYearEntries(){
    var owner = _getOwnerValue();
    var currYear = _getYearFancyValue();
    var nextYear = currYear + 1;

    // Try official storage key if function exists
    var key = null;
    try {
      if (typeof window.getStorageKey === 'function'){
        key = window.getStorageKey(nextYear, owner) || window.getStorageKey(nextYear);
      }
    } catch(e){}
    // Fallbacks
    var candidates = [];
    if (key) candidates.push(key);
    candidates.push((owner || 'owner1') + '|' + nextYear);
    candidates.push('ENBD|' + (owner || 'owner1') + '|' + nextYear);
    candidates.push('enbd|' + (owner || 'owner1') + '|' + nextYear);

    var dataObj = null;
    for (var i=0;i<candidates.length;i++){
      var k = candidates[i];
      try{
        var raw = localStorage.getItem(k);
        if (raw){
          dataObj = JSON.parse(raw);
          break;
        }
      }catch(e){}
    }
    if (!dataObj) return []; // no saved data

    var found = _findTargetsInObject(dataObj);
    // Sort by month asc
    found.sort(function(a,b){ return a.month - b.month; });
    return found;
  }

  function renderNextYearTarget(forceEntries){
    return; // disabled to remove unwanted text
  }

  // Hook into owner/year changes
  function attachHooks(){
    var sel = document.getElementById('ownerSelect');
    if (sel){
      sel.addEventListener('change', function(){ setTimeout(renderNextYearTarget, 0); });
    }
    var nextBtn = document.getElementById('yearToggleBtn');
    if (nextBtn){
      nextBtn.addEventListener('click', function(){ setTimeout(renderNextYearTarget, 0); });
    }
    var prevBtn = document.getElementById('yearPrevBtn');
    if (prevBtn){
      prevBtn.addEventListener('click', function(){ setTimeout(renderNextYearTarget, 0); });
    }
    // Also observe mutations on yearFancy text changes
    var yf = document.getElementById('yearFancy');
    if (window.MutationObserver && yf){
      var obs = new MutationObserver(function(){ renderNextYearTarget(); });
      obs.observe(yf, {childList:true, characterData:true, subtree:true});
    }
  }

  // Expose manual trigger (in case you update storage after editing)
  window.renderNextYearTarget = renderNextYearTarget;

  // Init on DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    attachHooks();
    renderNextYearTarget();
  });
})();
</script>
<script>
// === Mirror legacy nextYearTargetNote into our container (v3.1) ===
(function(){
  function byId(id){ return document.getElementById(id); }
  function syncOnce(){
    var src = byId('nextYearTargetNote');
    var dst = byId('nextYearTargetContainer');
    if (!dst) return false;
    if (!src) return false;
    var t = (src.textContent || '').trim();
    // If source shows a real entry (contains "The month of"), use it; else show placeholder.
    if (t && t.indexOf('The month of') !== -1){
      // dst.textContent = t;
      dst.textContent = '';
    } else {
      // dst.textContent = 'Next Year Target :- No entries yet';
      dst.textContent = '';
    }
    return true;
  }
  function startObserving(){
    var src = byId('nextYearTargetNote');
    if (!src) return;
    try {
      var obs = new MutationObserver(function(){ syncOnce(); });
      obs.observe(src, { characterData: true, childList: true, subtree: true });
      // initial sync
      syncOnce();
    } catch(e){ /* no-op */ }
  }
  // Try repeatedly for a short while in case the legacy note is created later
  var tries = 0, maxTries = 40;
  var timer = setInterval(function(){
    if (syncOnce()){ clearInterval(timer); startObserving(); }
    if (++tries >= maxTries){ clearInterval(timer); startObserving(); }
  }, 150);
  // Also hook common app events
  document.addEventListener('DOMContentLoaded', function(){
    syncOnce(); startObserving();
  });
  window.addEventListener('load', function(){
    syncOnce(); startObserving();
  });
})();
</script>
<script>
// === Persist Selected Year per Owner (v1) ===
(function(){
  var YEAR_KEY_PREFIX = 'selectedYear:';
  function byId(id){ return document.getElementById(id); }
  function getOwnerId(){
    try {
      var sel = byId('ownerSelect');
      if (sel && sel.value) return sel.value;
      // fallback to saved owner id if owner selector not ready
      var sid = localStorage.getItem('selectedOwnerId');
      if (sid) return sid;
    } catch(e){}
    return 'owner1';
  }
  function parseYear(text){
    var n = parseInt(String(text||'').replace(/[^\d]/g,''), 10);
    return isFinite(n) ? n : null;
  }
  function setYearEverywhere(y){
    if (!y) return;
    try { window.currentYear = y; } catch(e){}
    var fancy = byId('yearFancy');
    if (fancy) fancy.textContent = String(y);
    var yi = byId('yearInput');
    if (yi) yi.value = String(y);
    try {
      if (typeof window.getStorageKey === 'function'){
        window.storageKey = window.getStorageKey(y);
      }
    } catch(e){}
    // fire a custom event so any app logic can react
    try {
      document.dispatchEvent(new CustomEvent('selected-year-changed', { detail: { year: y } }));
    } catch(e){}
  }
  function saveYear(y){
    var owner = getOwnerId();
    try { localStorage.setItem(YEAR_KEY_PREFIX + owner, String(y)); } catch(e){}
  }
  function loadYear(owner){
    try {
      var v = localStorage.getItem(YEAR_KEY_PREFIX + owner);
      var n = parseYear(v);
      return n;
    } catch(e){ return null; }
  }
  function applySavedYearForOwner(owner){
    var saved = loadYear(owner);
    if (saved && isFinite(saved)){
      setYearEverywhere(saved);
      return true;
    }
    return false;
  }
  function hookYearChanges(){
    var prev = byId('yearPrevBtn');
    var next = byId('yearToggleBtn');
    function deferSave(){
      setTimeout(function(){
        var fancy = byId('yearFancy');
        var y = parseYear(fancy ? fancy.textContent : (byId('yearInput')||{}).value);
        if (y) saveYear(y);
      }, 0);
    }
    if (prev) prev.addEventListener('click', deferSave);
    if (next) next.addEventListener('click', deferSave);
    var fancy = byId('yearFancy');
    if (window.MutationObserver && fancy){
      var obs = new MutationObserver(function(){
        var y = parseYear(fancy.textContent);
        if (y) saveYear(y);
      });
      obs.observe(fancy, { childList:true, characterData:true, subtree:true });
    }
    var yi = byId('yearInput');
    if (yi){
      yi.addEventListener('change', function(){
        var y = parseYear(yi.value);
        if (y){ saveYear(y); setYearEverywhere(y); }
      });
    }
  }
  function hookOwnerChanges(){
    var sel = byId('ownerSelect');
    if (!sel) return;
    sel.addEventListener('change', function(){
      // when owner changes, apply that owner's saved year (if any)
      if (!applySavedYearForOwner(sel.value)){
        // otherwise keep current year but save mapping for new owner
        var fancy = byId('yearFancy');
        var y = parseYear(fancy ? fancy.textContent : (byId('yearInput')||{}).value) || (new Date()).getFullYear();
        saveYear(y);
      }
      // nudge any dependent UI
      try { if (typeof window.renderNextYearTarget === 'function') window.renderNextYearTarget(); } catch(e){}
    });
  }
  function init(){
    // On first load, try to restore saved year for current/saved owner
    var owner = getOwnerId();
    var restored = applySavedYearForOwner(owner);
    if (!restored){
      // If nothing saved yet, save current initial year so refreshes keep it
      var cur = parseYear((byId('yearFancy')||{}).textContent) || (new Date()).getFullYear();
      saveYear(cur);
    }
    hookYearChanges();
    hookOwnerChanges();
    // Safety: re-apply after app finishes its own init (prevents flashing 2025)
    setTimeout(function(){
      applySavedYearForOwner(getOwnerId());
      try { if (typeof window.renderNextYearTarget === 'function') window.renderNextYearTarget(); } catch(e){}
    }, 120);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }
})();
</script>
<!-- === PATCH v3: Always show next target (month & amount) + explicit (shortage …)/(surplus … even 0) === -->
<script>
(function(){
  function safe(fn){ try{ fn(); }catch(e){} }
  function fmt(n){ try{ return (window.formatNumber? formatNumber(n): (Number(n)||0).toLocaleString()); }catch(_){ return String(n); } }

  function computeNextMetrics(){
    var idx = -1;
    try { idx = (typeof findNextNeededMonth === 'function') ? findNextNeededMonth() : -1; } catch(_){ idx = -1; }
    if (idx == null || idx < 0){ return null; }
    var monthsArr   = window.months || ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    var targetsArr  = window.monthlyTargets || [];
    var actualsArr  = window.actuals || [];
    var target = Number(targetsArr[idx] || 0);
    var accumBefore = (typeof getAccumVarianceBeforeMonth === 'function') ? getAccumVarianceBeforeMonth(idx) : 0;
    var currentVar  = (Number(actualsArr[idx] || 0) - Number(targetsArr[idx] || 0));
    var accumAfter  = accumBefore + currentVar;
    var shortage    = Math.max(0, -accumAfter);
    var surplus     = Math.max(0,  accumAfter); // can be 0
    var monthLabel  = (monthsArr[idx]||'').slice(0,3);
    var dToNext     = (typeof getDaysToNext === 'function' && window.keyDates) ? getDaysToNext(window.keyDates[idx]) : '—';
    return { idx, target, accumAfter, shortage, surplus, monthLabel, dToNext };
  }

  function buildStatusLine(m){
  var isShort = m.shortage > 0;
  var isSurp  = m.surplus  > 0;
  var color, label;
  if (isShort){
    color = 'var(--orange-red-flag)';
    label = 'shortage ' + fmt(m.shortage);
  } else if (isSurp){
    color = 'var(--green)';
    label = 'surplus ' + fmt(m.surplus);
  } else {
    color = 'var(--muted, #777)';
    label = '(met)';
  }
  return `<br><span style="font-size: 8px; color:${color};">${label}</span>`;

} else if (m.surplus > 0) {
  E.nextText.innerHTML = `<strong>${fmt(m.target)}</strong> <span style="color:var(--green);">(surplus ${fmt(m.surplus)})</span>`;
  E.nextContainer.classList.remove('shortage');
} else {
  E.nextText.innerHTML = `<strong>${fmt(m.target)}</strong> <span class="muted">(met)</span>`;
  E.nextContainer.classList.remove('shortage');
}
</strong> <span style="color:var(--green);">(surplus ${fmt(m.surplus)})</span>`; // surplus even if 0
      E.nextContainer.classList.remove('shortage');
    }
    E.nextDays.textContent = (m.dToNext === '—' || m.dToNext === 'Past') ? '-' : (m.dToNext === 'Today' ? 'Today' : `${m.dToNext}d`);
    E.nextContainer.style.display = 'flex';
    if (E.dashNextText){ E.dashNextText.textContent = ''; E.dashNextText.classList.remove('alert-green'); }
  }

  // Wrap renderGauge; also observe DOM in case original code overwrites after our run.
  safe(function(){
    var orig = window.renderGauge;
    if (typeof orig === 'function'){
      window.renderGauge = function(){
        var r = orig.apply(this, arguments);
        updateGaugeInner();
        updateNextRibbon();
        return r;
      };
    }
  });

  safe(function(){
    document.addEventListener('DOMContentLoaded', function(){
      updateGaugeInner(); updateNextRibbon();
      var mo = new MutationObserver(function(){ updateGaugeInner(); updateNextRibbon(); });
      mo.observe(document.body, { childList:true, subtree:true, attributes:true, characterData:true });
    });
    window.addEventListener('load', function(){ updateGaugeInner(); updateNextRibbon(); });
  });
})();
</script>
<script>
// Global cleanup: ensure pdf-mode is removed after 3s (safety)
window.addEventListener('load', function(){
  setInterval(function(){
    if (document.body.classList.contains('pdf-mode')){
      document.body.classList.remove('pdf-mode');
    }
  }, 3000);
});
</script>
<script>
// === Force gauge to always show NEXT TARGET (regardless of shortage) ===
(function(){
  function getNextTargetRegardless() {
    try {
      const now = (typeof getNow === 'function') ? getNow() : new Date();
      const nowM = now.getMonth(); // 0..11
      // Prefer forward months this year
      for (let i = nowM; i < 12; i++) {
        const t = Number((window.monthlyTargets && window.monthlyTargets[i]) || 0);
        if (t > 0) return { index: i, target: t };
      }
      // Wrap to earlier months
      for (let i = 0; i < nowM; i++) {
        const t = Number((window.monthlyTargets && window.monthlyTargets[i]) || 0);
        if (t > 0) return { index: i, target: t };
      }
      return null;
    } catch(e){ return null; }
  }

  function forceGaugeToNextTarget() {
    if (!window.elements || !elements.gaugeText) return;
    const pick = getNextTargetRegardless();
    if (!pick) {
      elements.gaugeText.innerHTML = '<div class="month">All Met 🎉</div>';
      return;
    }
    const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const monthLabel = MONTHS[pick.index];
    const targetAmount = (typeof formatNumber === 'function') ? formatNumber(pick.target) : String(pick.target);
    // Render month and amount (no shortage line)
    elements.gaugeText.innerHTML = (
      '<div class="month" title="Next target month (regardless of shortage)">' + monthLabel + '</div>' +
      '<div class="amount" title="Target amount for ' + monthLabel + '">' + targetAmount + '</div>'
    );
  }

  // Hook renderGauge so our display is applied after the chart renders
  try {
    var origRG = window.renderGauge;
    if (typeof origRG === 'function') {
      window.renderGauge = function(){
        var r = origRG.apply(this, arguments);
        try { forceGaugeToNextTarget(); } catch(e){}
        return r;
      };
    } else {
      // If not present yet, attempt once after load
      setTimeout(forceGaugeToNextTarget, 120);
    }
  } catch(e){}

  // Also update when obvious UI actions occur
  window.addEventListener('load', forceGaugeToNextTarget);
  document.addEventListener('visibilitychange', function(){ if (!document.hidden) forceGaugeToNextTarget(); });
  ['btnImportExcel','btnReset','btnToggleAll','btnToggleFuture'].forEach(function(id){
    var el = document.getElementById(id);
    if (el) el.addEventListener('click', function(){ setTimeout(forceGaugeToNextTarget, 60); });
  });
  // Re-run when storage state updates (if saveState exists)
  if (typeof window.saveState === 'function') {
    var __oldSave = window.saveState;
    window.saveState = function(){
      var r = __oldSave.apply(this, arguments);
      try { setTimeout(forceGaugeToNextTarget, 60); } catch(e){}
      return r;
    };
  }
})();
</script>
<script>
// === Calendar-based next target selector for the circle ===




// Robust date parser: supports ISO, Date objects, and "DD/MM/YYYY" or "DD-MM-YYYY"
function parseAnyDate(raw){
  try{
    if (!raw) return null;
    if (raw instanceof Date) return isNaN(raw) ? null : raw;
    if (typeof raw === 'number') { const d = new Date(raw); return isNaN(d) ? null : d; }
    if (typeof raw !== 'string') return null;
    const s = raw.trim();

    // ISO-like first (YYYY-MM-DD or YYYY/MM/DD or with time)
    const iso = new Date(s);
    if (!isNaN(iso)) return iso;

    // DD/MM/YYYY or DD-MM-YYYY
    const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m){
      const d = parseInt(m[1],10);
      const mo = parseInt(m[2],10) - 1;
      const y = parseInt(m[3],10);
      const dt = new Date(y, mo, d, 12, 0, 0, 0); // noon to avoid TZ edge cases
      // Validate
      if (dt.getFullYear() === y && dt.getMonth() === mo && dt.getDate() === d) return dt;
      return null;
    }
    return null;
  }catch(e){ return null; }
}

function findNextTargetByCalendar(){
  try {
    const now = (typeof getNow === 'function') ? getNow() : new Date();
    const liveYear = now.getFullYear();
    const selectedYear = (typeof window.currentYear === 'number') ? window.currentYear : liveYear;
    const MONTHS = 12;

    // Base date:
    const baseDate = (selectedYear === liveYear) ? now : new Date(selectedYear, 0, 1);

    // Helper: virtual due date (last day of month, or configured day)
    function virtualDueDate(year, m){
      let day = 0;
      if (Array.isArray(window.monthDueDay) && window.monthDueDay.length === 12) {
        day = Number(window.monthDueDay[m] || 0);
      } else if (typeof window.monthDueDay === 'number') {
        day = Number(window.monthDueDay || 0);
      } else if (typeof window.defaultDueDay === 'number') {
        day = Number(window.defaultDueDay || 0);
      }
      if (day >= 1) {
        const lastDay = new Date(year, m + 1, 0).getDate();
        day = Math.min(day, lastDay);
        return new Date(year, m, day);
      }
      return new Date(year, m + 1, 0);
    }

    const tArr = window.monthlyTargets || [];
    const kd = window.keyDates || []; // keyDates[month] = array of ISO strings

    // 1) Candidates from explicit key dates (>= baseDate), with target > 0
    let best = null;
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue; // 0 is not a target
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (isNaN(dt)) continue;
        if (dt.getFullYear() !== selectedYear) continue;
        if (dt >= baseDate){
          if (!best || dt < best.date) best = { index: i, target: t, date: dt };
        }
      }
    }
    if (best) return best;

    // 2) If no future key dates exist, fall back to virtual due dates (>= baseDate)
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      const vd = virtualDueDate(selectedYear, i);
      if (vd >= baseDate){
        if (!best || vd < best.date) best = { index: i, target: t, date: vd };
      }
    }
    if (best) return best;

    // 3) Wrap inside selected year: pick earliest key date or due date with t>0
    //    (This only happens when all targets are in the past relative to baseDate)
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      let earliest = null;
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (isNaN(dt)) continue;
        if (dt.getFullYear() !== selectedYear) continue;
        if (!earliest || dt < earliest) earliest = dt;
      }
      const date = earliest || virtualDueDate(selectedYear, i);
      return { index: i, target: t, date };
    }

    // 4) No targets at all → show current month (or Jan if not live year)
    const idx = (selectedYear === liveYear) ? now.getMonth() : 0;
    return { index: idx, target: Number(tArr[idx] || 0), date: null };
  } catch(e){
    // Safe fallback
    const now = new Date();
    const idx = now.getMonth();
    return { index: idx, target: Number((window.monthlyTargets && window.monthlyTargets[idx]) || 0), date: null };
  }
}
else if (typeof window.monthDueDay === 'number') {
        day = Number(window.monthDueDay || 0);
      } else if (typeof window.defaultDueDay === 'number') {
        day = Number(window.defaultDueDay || 0);
      }
      if (day >= 1) {
        const lastDay = new Date(year, m + 1, 0).getDate();
        day = Math.min(day, lastDay);
        return new Date(year, m, day);
      }
      return new Date(year, m + 1, 0);
    }

    const tArr = window.monthlyTargets || [];
    const inflowArr = window.monthlyInflows || window.monthlyBankInflow || [];
    const kd = window.keyDates || []; // keyDates[month] = array of ISO strings

    function monthIsMet(i){
      const t = Number(tArr[i] || 0);
      const b = Number(inflowArr[i] || 0);
      if (!(t > 0)) return false; // zero targets are not "met" targets; they will be skipped anyway
      return b >= t;
    }

    function earliestCandidateOnOrAfter(i){
      // return a Date or null for month i if on/after baseDate
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      let earliest = null;
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (isNaN(dt)) continue;
        if (dt.getFullYear() !== selectedYear) continue;
        if (dt >= baseDate && (!earliest || dt < earliest)) earliest = dt;
      }
      if (earliest) return earliest;
      const vd = virtualDueDate(selectedYear, i);
      return (vd >= baseDate) ? vd : null;
    }

    // 1) Prefer the closest FUTURE/ON baseDate target with t>0 that is NOT met
    let best = null;
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      if (monthIsMet(i)) continue;
      const c = earliestCandidateOnOrAfter(i);
      if (!c) continue;
      if (!best || c < best.date) best = { index: i, target: t, date: c };
    }
    if (best) return best;

    // 2) If all future targets are met (or none), pick the closest FUTURE/ON baseDate target with t>0 (even if met)
    best = null;
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      const c = earliestCandidateOnOrAfter(i);
      if (!c) continue;
      if (!best || c < best.date) best = { index: i, target: t, date: c };
    }
    if (best) return best;

    // 3) Wrap inside the selected year to the first month with t>0 that is NOT met
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      if (monthIsMet(i)) continue;
      return { index: i, target: t, date: null };
    }

    // 4) Fallback: first month with t>0, otherwise current/January
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (t > 0) return { index: i, target: t, date: null };
    }
    const idx = (selectedYear === liveYear) ? now.getMonth() : 0;
    return { index: idx, target: Number(tArr[idx] || 0), date: null };

  } catch(e){
    const now = new Date();
    const idx = now.getMonth();
    return { index: idx, target: Number((window.monthlyTargets && window.monthlyTargets[idx]) || 0), date: null };
  }
}
else if (typeof window.monthDueDay === 'number') {
        day = Number(window.monthDueDay || 0);
      } else if (typeof window.defaultDueDay === 'number') {
        day = Number(window.defaultDueDay || 0);
      }

      if (day >= 1) {
        // Clamp to last day of month to avoid invalid dates
        const lastDay = new Date(year, m + 1, 0).getDate();
        day = Math.min(day, lastDay);
        return new Date(year, m, day);
      }

      // Default: last day of month
      return new Date(year, m + 1, 0);
    }

    const tArr = window.monthlyTargets || [];
    const kd = window.keyDates || []; // keyDates[month] = array of ISO strings

    // 1) Build candidate list of upcoming dates in/after baseDate within selectedYear
    let best = null;

    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue; // skip zero targets

      let candidateDate = null;

      // Prefer the earliest explicit keyDate >= baseDate (within selectedYear)
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      let earliestFromKeys = null;
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (isNaN(dt)) continue;
        if (dt.getFullYear() !== selectedYear) continue;
        if (dt >= baseDate && (!earliestFromKeys || dt < earliestFromKeys)) {
          earliestFromKeys = dt;
        }
      }

      if (earliestFromKeys) {
        candidateDate = earliestFromKeys;
      } else {
        // Use virtual due date (e.g., last day of that month) and compare with baseDate
        const vd = virtualDueDate(selectedYear, i);
        if (vd >= baseDate) candidateDate = vd;
      }

      if (candidateDate){
        if (!best || candidateDate < best.date) {
          best = { index: i, target: t, date: candidateDate };
        }
      }
    }

    if (best) return best;

    // 2) Nothing ahead in/after baseDate → wrap inside selectedYear:
    // pick the earliest month in the selectedYear with target > 0 (ignoring day-of-month since all are "past" relative to baseDate).
    for (let i = 0; i < MONTHS; i++){
      const t = Number(tArr[i] || 0);
      if (t > 0) return { index: i, target: t, date: null };
    }

    // 3) No targets at all → show current month (or January of selected year if not current)
    const idx = (selectedYear === liveYear) ? now.getMonth() : 0;
    return { index: idx, target: Number(tArr[idx] || 0), date: null };

  } catch(e){
    // Safe fallback
    const now = new Date();
    const idx = now.getMonth();
    return { index: idx, target: Number((window.monthlyTargets && window.monthlyTargets[idx]) || 0), date: null };
  }
}
;
        }
      }
    }
    if (best) return best;

    // 2) No future key dates => find first upcoming month (this year) with target > 0
    const start = now.getMonth();
    for (let i = start; i < MONTHS; i++){
      const t = Number((window.monthlyTargets && window.monthlyTargets[i]) || 0);
      if (t > 0) return { index: i, target: t, date: null };
    }
    // 3) Wrap to earlier months
    for (let i = 0; i < start; i++){
      const t = Number((window.monthlyTargets && window.monthlyTargets[i]) || 0);
      if (t > 0) return { index: i, target: t, date: null };
    }

    // 4) Fallback: current month (even if 0)
    return { index: start, target: Number((window.monthlyTargets && window.monthlyTargets[start]) || 0), date: null };
  } catch(e){
    const now = new Date();
    const idx = now.getMonth();
    return { index: idx, target: Number((window.monthlyTargets && window.monthlyTargets[idx]) || 0), date: null };
  }
}

// === Accumulated variance accessor ===
function getAccumulatedForIndex(monthIndex){
  if (Array.isArray(window.accVariance) && window.accVariance.length === 12) {
    const v = Number(window.accVariance[monthIndex]);
    if (!Number.isNaN(v)) return v;
  }
  const tArr = window.monthlyTargets || [];
  const bArr = window.monthlyInflows || window.monthlyBankInflow || [];
  let acc = 0;
  // If your baseline includes opening balance, enable next line:
  // acc += Number(window.openingBalanceForYear || 0) || 0;
  for (let i = 0; i <= monthIndex; i++){
    acc += Number(bArr[i] || 0) - Number(tArr[i] || 0);
  }
  return acc;
}

// === Circle inner renderer (month + amount + status) ===
function updateGaugeInner(){
  try {
    const E = (typeof elements !== 'undefined') ? elements : {};
    const holder = E.gaugeText || document.getElementById('gaugeText');
    if (!holder) return;

    const nxt = findNextTargetByCalendar();
    const monthsArr = (Array.isArray(window.months) && window.months.length === 12)
      ? window.months
      : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    const mName = monthsArr[nxt.index] || '—';
    const amount = (typeof fmt === 'function')
      ? fmt(nxt.target)
      : (nxt.target?.toLocaleString?.() ?? String(nxt.target ?? '—'));

    const acc = getAccumulatedForIndex(nxt.index);
    let statusText = '(balanced)';
    let statusClass = 'status-balanced';
    if (acc > 0) { statusText = '(surplus)'; statusClass = 'status-surplus'; }
    else if (acc < 0) { statusText = '(shortage)'; statusClass = 'status-shortage'; }

    holder.innerHTML = '<div class="month">'+mName+'</div>' +
                       '<div class="amount">'+amount+'</div>' +
                       '<div class="status '+statusClass+'">'+statusText+'</div>';
  } catch(e){ /* no-op */ }
}

// === Ribbon status helper & enhancer ===
function formatStatusForMonth(index){
  const acc = getAccumulatedForIndex(index);
  if (acc > 0)  return { text: '(surplus)',  cls: 'ribbon-surplus'  };
  if (acc < 0)  return { text: '(shortage)', cls: 'ribbon-shortage' };
  return { text: '(balanced)', cls: 'ribbon-balanced' };
}

function enhanceRibbonWithStatus(){
  try{
    if (typeof findNextNeededMonth !== 'function') return;
    const next = findNextNeededMonth();
    if (!next || typeof next.index !== 'number') return;
    const { text, cls } = formatStatusForMonth(next.index);

    const el = document.getElementById('nextNeededText')
           || document.querySelector('[data-role="next-needed-text"]')
           || document.querySelector('.next-needed-text, .next-needed-ribbon');
    if (!el) return;

    let badge = el.querySelector('.ribbon-status');
    if (!badge){
      badge = document.createElement('span');
      badge.className = 'ribbon-status';
      badge.style.marginLeft = '6px';
      el.appendChild(badge);
    }
    badge.textContent = ' ' + text;
    badge.classList.remove('ribbon-surplus','ribbon-shortage','ribbon-balanced');
    badge.classList.add(cls);
  } catch(e){ /* no-op */ }
}

// === Auto-run after initial render and on changes ===
document.addEventListener('DOMContentLoaded', function(){
  // Try to run after your app renders once
  setTimeout(function(){
    try { updateGaugeInner(); } catch(e){}
    try { enhanceRibbonWithStatus(); } catch(e){}
  }, 50);

  // Observe the ribbon container for changes to keep status in sync
  const rib = document.getElementById('nextNeededText')
          || document.querySelector('[data-role="next-needed-text"]')
          || document.querySelector('.next-needed-text, .next-needed-ribbon');
  if (rib && window.MutationObserver){
    const mo = new MutationObserver(function(){ try { enhanceRibbonWithStatus(); } catch(e){} });
    mo.observe(rib, { childList: true, characterData: true, subtree: true });
  }
});

// Optional: expose a manual refresh hook if your code already calls this elsewhere
window.refreshCircleAndRibbonStatus = function(){
  try { updateGaugeInner(); } catch(e){}
  try { enhanceRibbonWithStatus(); } catch(e){}
};
</script>
<script>
(function(){
  // ---- Re-apply circle (Next Target by calendar) whenever something tries to overwrite it ----
  // Guard to avoid recursive updates
  let __circle_updating = false;
  let __circle_sig = "";

  function monthName(idx){
    const arr = (Array.isArray(window.months) && window.months.length === 12)
      ? window.months
      : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    return arr[idx] || "—";
  }

  // Ensure parseAnyDate exists (from v22). If not, define a minimal one.
  if (typeof parseAnyDate !== 'function'){
    window.parseAnyDate = function(raw){
      if (!raw) return null;
      if (raw instanceof Date) return isNaN(raw) ? null : raw;
      if (typeof raw === 'number') { const d=new Date(raw); return isNaN(d)?null:d; }
      if (typeof raw !== 'string') return null;
      const s = raw.trim();
      const iso = new Date(s);
      if (!isNaN(iso)) return iso;
      const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
      if (m){
        const d = parseInt(m[1],10), mo = parseInt(m[2],10)-1, y = parseInt(m[3],10);
        const dt = new Date(y,mo,d,12,0,0,0);
        if (dt.getFullYear()===y && dt.getMonth()===mo && dt.getDate()===d) return dt;
      }
      return null;
    };
  }

  
function findNextTargetByCalendar_STRICT(){
  const now = (typeof getNow === 'function') ? getNow() : new Date();
  const liveYear = now.getFullYear();
  const selectedYear = (typeof window.currentYear === 'number') ? window.currentYear : liveYear;
  const baseDate = (selectedYear === liveYear) ? now : new Date(selectedYear,0,1);
  const tArr = window.monthlyTargets || [];
  const kd = window.keyDates || [];
  const MONTHS = 12;

  // 1) Prefer explicit key dates >= baseDate (any target amount, including 0)
  let best = null;
  for (let i=0;i<MONTHS;i++){
    const list = Array.isArray(kd[i]) ? kd[i] : [];
    for (const raw of list){
      const dt = (typeof parseAnyDate === 'function') ? parseAnyDate(raw) : new Date(raw);
      if (!dt || isNaN(dt)) continue;
      if (dt.getFullYear() !== selectedYear) continue;
      if (dt >= baseDate){
        if (!best || dt < best.date) best = { index:i, date:dt };
      }
    }
  }
  if (best) return { index: best.index, target: Number(tArr[best.index] || 0), date: best.date };

  // 2) Fallback: virtual due dates >= baseDate for all months (even if target is 0)
  function virtualDueDate(year, m){
    let day = 0;
    if (Array.isArray(window.monthDueDay) && window.monthDueDay.length === 12) {
      day = Number(window.monthDueDay[m] || 0);
    } else if (typeof window.monthDueDay === 'number') {
      day = Number(window.monthDueDay || 0);
    } else if (typeof window.defaultDueDay === 'number') {
      day = Number(window.defaultDueDay || 0);
    } else {
      day = 0;
    }
    if (day >= 1) {
      const lastDay = new Date(year, m + 1, 0).getDate();
      day = Math.min(day, lastDay);
      return new Date(year, m, day);
    }
    return new Date(year, m + 1, 0);
  }

  best = null;
  for (let i=0;i<MONTHS;i++){
    const vd = virtualDueDate(selectedYear, i);
    if (vd >= baseDate){
      if (!best || vd < best.date) best = { index:i, date:vd };
    }
  }
  if (best) return { index: best.index, target: Number(tArr[best.index] || 0), date: best.date };

  // 3) Wrap: earliest key date or due date in the year (any target)
  for (let i=0;i<MONTHS;i++){
    const list = Array.isArray(kd[i]) ? kd[i] : [];
    let earliest = null;
    for (const raw of list){
      const dt = (typeof parseAnyDate === 'function') ? parseAnyDate(raw) : new Date(raw);
      if (!dt || isNaN(dt) || dt.getFullYear() !== selectedYear) continue;
      if (!earliest || dt < earliest) earliest = dt;
    }
    const date = earliest || virtualDueDate(selectedYear, i);
    return { index:i, target: Number(tArr[i] || 0), date };
  }

  // 4) No dates at all: show current month (or Jan) with whatever amount (possibly 0)
  const idx = (selectedYear === liveYear) ? now.getMonth() : 0;
  return { index: idx, target: Number(tArr[idx] || 0), date: null };
}
;
        }
      }
    }
    if (best) return best;

    // 2) due-date fallback >= baseDate (1st, configured, or last day of month)
    function virtualDueDate(year, m){
      let day = 0;
      if (Array.isArray(window.monthDueDay) && window.monthDueDay.length === 12) {
        day = Number(window.monthDueDay[m] || 0);
      } else if (typeof window.monthDueDay === 'number') {
        day = Number(window.monthDueDay || 0);
      } else if (typeof window.defaultDueDay === 'number') {
        day = Number(window.defaultDueDay || 0);
      } else {
        day = 0;
      }
      if (day >= 1) {
        const lastDay = new Date(year, m + 1, 0).getDate();
        day = Math.min(day, lastDay);
        return new Date(year, m, day);
      }
      // if no configured day, default to last day of month
      return new Date(year, m + 1, 0);
    }

    best = null;
    for (let i=0;i<MONTHS;i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      const vd = virtualDueDate(selectedYear, i);
      if (vd >= baseDate){
        if (!best || vd < best.date) best = { index:i, target:t, date:vd };
      }
    }
    if (best) return best;

    // 3) wrap: earliest key date or due date with t>0
    for (let i=0;i<MONTHS;i++){
      const t = Number(tArr[i] || 0);
      if (!(t > 0)) continue;
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      let earliest = null;
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (!dt || dt.getFullYear() !== selectedYear) continue;
        if (!earliest || dt < earliest) earliest = dt;
      }
      const date = earliest || virtualDueDate(selectedYear, i);
      return { index:i, target:t, date };
    }

    // 4) none
    const idx = (selectedYear === liveYear) ? now.getMonth() : 0;
    return { index: idx, target: Number(tArr[idx] || 0), date: null };
  }

  function getAccumulatedForIndexSafe(i){
    if (Array.isArray(window.accVariance) && window.accVariance.length === 12) {
      const v = Number(window.accVariance[i]);
      if (!Number.isNaN(v)) return v;
    }
    const tArr = window.monthlyTargets || [];
    const bArr = window.monthlyInflows || window.monthlyBankInflow || [];
    let acc = 0;
    for (let k=0;k<=i;k++){
      acc += Number(bArr[k] || 0) - Number(tArr[k] || 0);
    }
    return acc;
  }

  function renderCircleCalendarOnly(){
    try {
      const holder = document.getElementById('gaugeText') ||
                     document.querySelector('[data-role="gauge-text"], #gaugeText');
      if (!holder) return;

      const next = findNextTargetByCalendar_STRICT();
      const mName = monthName(next.index);
      const amount = (typeof fmt === 'function')
        ? fmt(next.target)
        : (next.target?.toLocaleString?.() ?? String(next.target ?? '—'));

      const acc = getAccumulatedForIndexSafe(next.index);
      let statusText = '(balanced)';
      let statusClass = 'status-balanced';
      if (acc > 0) { statusText = '(surplus)'; statusClass = 'status-surplus'; }
      else if (acc < 0) { statusText = '(shortage)'; statusClass = 'status-shortage'; }

      const newHTML = '<div class="month">'+mName+'</div>' +
                      '<div class="amount">'+amount+'</div>' +
                      '<div class="status '+statusClass+'">'+statusText+'</div>';

      const sig = mName + '|' + amount + '|' + statusClass;
      if (__circle_sig === sig) return; // no change needed

      __circle_updating = true;
      holder.setAttribute('data-mode', 'calendar');
      holder.innerHTML = newHTML;
      __circle_sig = sig;
      __circle_updating = false;
    } catch(e){ __circle_updating = false; }
  }

  function attachGaugeObserver(){
    const holder = document.getElementById('gaugeText') ||
                   document.querySelector('[data-role="gauge-text"], #gaugeText');
    if (!holder || !window.MutationObserver) return;

    const mo = new MutationObserver(function(muts){
      if (__circle_updating) return;
      // If some other code changes the gauge, immediately reapply our calendar value
      renderCircleCalendarOnly();
    });
    mo.observe(holder, { childList: true, characterData: true, subtree: true });
    // First render
    renderCircleCalendarOnly();
  }

  // Try immediately, then again after data likely loads
  document.addEventListener('DOMContentLoaded', function(){
    // initial attempts
    renderCircleCalendarOnly();
    attachGaugeObserver();
    // try a few delayed passes in case data arrives late
    let tries = 0;
    const timer = setInterval(function(){
      tries++;
      renderCircleCalendarOnly();
      if (tries >= 10) clearInterval(timer); // stop after ~10 passes
    }, 150);
  });

  // expose manual refresh
  window.refreshCircleCalendar = renderCircleCalendarOnly;
})();
</script>
<script>
function parseAnyDate(raw){
  try{
    if (!raw) return null;
    if (raw instanceof Date) return isNaN(raw) ? null : raw;
    if (typeof raw === 'number') { const d=new Date(raw); return isNaN(d)?null:d; }
    if (typeof raw !== 'string') return null;
    const s = raw.trim();
    const iso = new Date(s);
    if (!isNaN(iso)) return iso;
    const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m){
      const d = parseInt(m[1],10), mo = parseInt(m[2],10)-1, y = parseInt(m[3],10);
      const dt = new Date(y, mo, d, 12, 0, 0, 0);
      if (dt.getFullYear()===y && dt.getMonth()===mo && dt.getDate()===d) return dt;
    }
    return null;
  }catch(e){ return null; }
}
function monthName(idx){
  const arr = (Array.isArray(window.months) && window.months.length===12)
    ? window.months
    : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  return arr[idx] || "—";
}
function findNextTargetCalendarOnly(){
  const now = (typeof getNow === 'function') ? getNow() : new Date();
  const liveYear = now.getFullYear();
  const selectedYear = (typeof window.currentYear === 'number') ? window.currentYear : liveYear;
  const baseDate = (selectedYear === liveYear) ? now : new Date(selectedYear, 0, 1);
  const tArr = window.monthlyTargets || [];
  const kd = window.keyDates || [];
  const MONTHS = 12;
  let best = null;
  for (let i=0;i<MONTHS;i++){
    const t = Number(tArr[i] || 0);
    if (!(t > 0)) continue;
    const list = Array.isArray(kd[i]) ? kd[i] : [];
    for (const raw of list){
      const dt = parseAnyDate(raw);
      if (!dt || dt.getFullYear() !== selectedYear) continue;
      if (dt >= baseDate){
        if (!best || dt < best.date) best = { index:i, target:t, date:dt };
      }
    }
  }
  if (best) return best;
  function virtualDueDate(year, m){
    let day = 0;
    if (Array.isArray(window.monthDueDay) && window.monthDueDay.length === 12) {
      day = Number(window.monthDueDay[m] || 0);
    } else if (typeof window.monthDueDay === 'number') {
      day = Number(window.monthDueDay || 0);
    } else if (typeof window.defaultDueDay === 'number') {
      day = Number(window.defaultDueDay || 0);
    }
    if (day >= 1) {
      const lastDay = new Date(year, m + 1, 0).getDate();
      day = Math.min(day, lastDay);
      return new Date(year, m, day);
    }
    return new Date(year, m + 1, 0);
  }
  best = null;
  for (let i=0;i<MONTHS;i++){
    const t = Number(tArr[i] || 0);
    if (!(t > 0)) continue;
    const vd = virtualDueDate(selectedYear, i);
    if (vd >= baseDate){
      if (!best || vd < best.date) best = { index:i, target:t, date:vd };
    }
  }
  if (best) return best;
  for (let i=0;i<MONTHS;i++){
    const t = Number(tArr[i] || 0);
    if (t > 0){
      const list = Array.isArray(kd[i]) ? kd[i] : [];
      let earliest = null;
      for (const raw of list){
        const dt = parseAnyDate(raw);
        if (!dt || dt.getFullYear() !== selectedYear) continue;
        if (!earliest || dt < earliest) earliest = dt;
      }
      return { index:i, target:t, date: earliest || (new Date(selectedYear, i+1, 0)) };
    }
  }
  return { index: (selectedYear===liveYear? now.getMonth():0), target: 0, date: null };
}
function ensureNextTargetCard(){
  const host = document.getElementById('mainSection') ||
               document.querySelector('.main, .content, .container, #content') ||
               document.body;
  let card = document.getElementById('nextTargetCard');
  if (!card){
    card = document.createElement('div');
    card.id = 'nextTargetCard';
    card.className = 'next-target-card';
    host.insertBefore(card, host.firstChild);
  }
  return card;
}
function fmtAmount(n){
  if (typeof fmt === 'function') return fmt(n);
  return (n?.toLocaleString?.() ?? String(n ?? '—'));
}
function renderNextTargetMain(){
  const card = ensureNextTargetCard();
  const nxt = findNextTargetCalendarOnly();
  const m = monthName(nxt.index);
  const amt = fmtAmount(nxt.target);
  let statusText = '';
  let statusClass = '';
  try{
    let acc = 0;
    const tArr = window.monthlyTargets || [];
    const bArr = window.monthlyInflows || window.monthlyBankInflow || [];
    for (let i=0;i<=nxt.index;i++){ acc += Number(bArr[i]||0) - Number(tArr[i]||0); }
    if (acc > 0) { statusText = ' (surplus)'; statusClass = 'surplus'; }
    else if (acc < 0) { statusText = ' (shortage)'; statusClass = 'shortage'; }
    else { statusText = ' (balanced)'; statusClass = 'balanced'; }
  }catch(_) {}
  card.innerHTML = `
    <div class="ntc-label">Next Target</div>
    <div class="ntc-line">
      <span class="ntc-month">${m}</span>
      <span class="ntc-sep">—</span>
      <span class="ntc-amt">${amt}</span>
      <span class="ntc-status ${statusClass}">${statusText}</span>
    </div>
  `;
}
(function injectStyles(){
  if (document.getElementById('nextTargetCardStyles')) return;
  const css = document.createElement('style');
  css.id = 'nextTargetCardStyles';
  css.textContent = `
    .next-target-card{ display:inline-block; padding:8px 12px; border-radius:12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08); background:#fff; margin-bottom:10px; }
    .next-target-card .ntc-label{ font-weight:700; font-size: 14px; opacity:.85; margin-bottom:2px; }
    .next-target-card .ntc-line{ font-weight:700; font-size: 17px; }
    .next-target-card .ntc-month{ margin-right:6px; }
    .next-target-card .ntc-sep{ margin:0 6px; opacity:.6; }
    .next-target-card .ntc-amt{ }
    .next-target-card .ntc-status{ font-weight:600; font-size: 13px; margin-left:6px; opacity:.9; }
    .next-target-card .ntc-status.surplus{ color:#1a7f37; }
    .next-target-card .ntc-status.shortage{ color:#c62828; }
    .next-target-card .ntc-status.balanced{ color:#666; }
  `;
  document.head.appendChild(css);
})();
document.addEventListener('DOMContentLoaded', function(){
  renderNextTargetMain();
  let i=0, t=setInterval(()=>{ i++; renderNextTargetMain(); if(i>6) clearInterval(t); }, 150);
});
window.refreshNextTargetMain = renderNextTargetMain;
</script>
<style>
/* Hide the placeholder 'Next Year Target :- No entries yet' everywhere */
#nextYearTargetNote { display: none !important; }
/* If it's rendered inside a dedicated container, hide it too */
#nextYearTargetContainer .ny-empty,
#nextYearTargetContainer .ny-placeholder {
  display: none !important;
}
</style>
<style id="repAIAnalysis-unify-font">
  #repAIAnalysis, .pdf-mode #repAIAnalysis {
    font-family: 'Poppins', 'Segoe UI', Arial, sans-serif !important;
    font-size: 19px !important;
    font-weight: 300 !important;
    line-height: 1.4 !important;
  margin-top: 2.2cm !important;
  margin-bottom: 2.2cm !important;
  }
</style>
<script>
// Extra safety: hide any element whose text equals the placeholder line
(function(){
  const PHRASE = 'next year target :- no entries yet';
  const all = document.querySelectorAll('body *');
  for (const el of all){
    try{
      if (el.children.length === 0){
        const t = (el.textContent || '').trim().toLowerCase();
        if (t === PHRASE) {
          el.style.display = 'none';
        }
      }
    }catch(_){}
  }
})();
</script>
<!-- ===== Refresh System v3: fast, stateful, non-destructive ===== -->
<style>
/* Refresh buttons style to match existing UI */
.topToolbar .btn-refresh, .btn-refresh {
  background: var(--very-light-green) !important;
  color: var(--text-bold) !important;
  border: 1px solid rgba(111,174,117,0.25) !important;
  font-size: 13px; padding: 6px 8px; border-radius: 8px;
}
.btn-refresh.ghost { background: transparent !important; border-color: rgba(74,141,133,0.25) !important; }
</style>
<script>
(function(){
  const STORAGE_KEY = "ENBD_ui_state_v3";
  const SCROLL_KEY  = "ENBD_scroll_v3";
  const URL_KEY     = "ENBD_url_state_v3";

  /** Debounce helper */
  function debounce(fn, wait){
    let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); };
  }

  /** Load/save UI state (owner, year, darkMode, etc) */
  function loadState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch { return {}; }
  }
  const saveState = debounce(function(state){
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state || {})); } catch {}
  }, 200);

  /** Apply state to UI without triggering full recalcs */
  function applyState(state){
    try {
      if (!state) return;
      // Owner
      if (state.owner && document.getElementById('ownerSelect')){
        const sel = document.getElementById('ownerSelect');
        if (sel.value !== state.owner) { sel.value = state.owner; sel.dispatchEvent(new Event('change', {bubbles:true})); }
      }
      // Year (respect fancy label system)
      if (typeof state.year === "number"){
        const yi = document.getElementById('yearInput');
        const yf = document.getElementById('yearFancy');
        if (yi) yi.value = state.year;
        if (yf) yf.textContent = String(state.year);
        // mirror global currentYear if app uses it
        try { window.currentYear = state.year; } catch {}
      }
      // Dark mode
      if (typeof state.dark === "boolean"){
        document.body.classList.toggle('dark', state.dark);
      }
    } catch(e){ console.warn("applyState error", e); }
  }

  /** Soft re-render critical widgets without clearing inputs */
  function softRefresh(){
    try {
      if (typeof window.renderNextTargetMain === 'function') window.renderNextTargetMain();
    } catch(e){ console.warn("nextTargetMain refresh", e); }
    try {
      if (typeof window.refreshNextTargetMain === 'function') window.refreshNextTargetMain();
    } catch(e){}
    try {
      if (typeof window.renderRibbon === 'function') window.renderRibbon();
    } catch(e){}
    try {
      if (typeof window.drawProgress === 'function') window.drawProgress();
    } catch(e){}
    try {
      if (typeof window.recomputeSummary === 'function') window.recomputeSummary();
    } catch(e){}
    try {
      if (typeof window.refreshMonthsMini === 'function') window.refreshMonthsMini();
    } catch(e){}
  }
  window.softRefresh = softRefresh;

  /** Hard refresh fallback: preserve state + scroll, then reload */
  function hardRefresh(){
    const state = collectState();
    try { localStorage.setItem(URL_KEY, location.hash || ""); } catch {}
    try { localStorage.setItem(SCROLL_KEY, String(window.scrollY||0)); } catch {}
    saveState(state);
    location.reload();
  }
  window.hardRefresh = hardRefresh;

  /** Collect current UI state */
  function collectState(){
    const st = loadState();
    try {
      const sel = document.getElementById('ownerSelect');
      if (sel) st.owner = sel.value;
    } catch {}
    try {
      const yi = document.getElementById('yearInput');
      const yf = document.getElementById('yearFancy');
      const yv = yi && yi.value ? Number(yi.value) : (yf && Number(yf.textContent)) || window.currentYear;
      if (yv) st.year = yv;
    } catch {}
    st.dark = document.body.classList.contains('dark');
    return st;
  }

  /** Persist scroll on unload */
  window.addEventListener('beforeunload', function(){
    const st = collectState();
    try { localStorage.setItem(SCROLL_KEY, String(window.scrollY||0)); } catch {}
    saveState.flush ? saveState.flush() : saveState(st);
  });

  /** On load: restore state + URL hash + scroll, then soft refresh */
  document.addEventListener('DOMContentLoaded', function(){
    // Restore state first
    const st = loadState();
    applyState(st);

    // If URL hash carries year/owner (e.g. #year=2026&owner=owner3), respect it
    if (location.hash && location.hash.includes("year=")){
      const params = new URLSearchParams(location.hash.replace(/^#/, ""));
      const year = Number(params.get("year"));
      const owner = params.get("owner");
      if (year) st.year = year;
      if (owner) st.owner = owner;
      applyState(st);
    }

    // Restore scroll
    const sy = Number(localStorage.getItem(SCROLL_KEY) || 0);
    if (!isNaN(sy)) window.scrollTo({ top: sy, behavior: "instant" });

    // Initial soft refresh (non-destructive)
    setTimeout(softRefresh, 120);
  });

  /** When tab becomes visible, re-sync data quickly */
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState === 'visible') softRefresh();
  });

  /** When another tab updates localStorage, sync here */
  window.addEventListener('storage', function(e){
    if (e && (e.key === STORAGE_KEY)) {
      applyState(loadState());
      softRefresh();
    }
  });

  /** Save state on owner/year change with debounce */
  const saveNow = debounce(()=>saveState(collectState()), 150);
  document.addEventListener('change', function(ev){
    const id = (ev.target && ev.target.id) || "";
    if (id === 'ownerSelect' || id === 'yearInput') saveNow();
  });
  document.addEventListener('input', debounce(function(){
    saveState(collectState());
  }, 400));

  /** Small helper to update URL hash from current state */
  window.updateUrlState = function(){
    const st = collectState();
    const p = new URLSearchParams();
    if (st.year)  p.set("year", String(st.year));
    if (st.owner) p.set("owner", String(st.owner));
    location.hash = p.toString();
  };
})();
</script>
<!-- Add compact refresh controls near existing toolbar (if present) -->
<!-- Color Play Popover -->
<script id="mirror-adjusted-target-note">
(function(){
  function ensureTotalNoteContainer(){
    var cell = document.getElementById('monthlyTarget'); // main table footer Target total
    if(!cell){ return null; }
    var note = document.getElementById('totalTargetNote');
    if(!note){
      note = document.createElement('div');
      note.id = 'totalTargetNote';
      note.className = 'tiny-note';
      // place the note directly below the number
      cell.appendChild(note);
    }
    return note;
  }
  function copyDashNote(){
    try{
      var src = document.getElementById('dashTargetNote');
      var tgt = ensureTotalNoteContainer();
      if(!src || !tgt){ return; }
      var txt = (src.textContent || '').trim();
      tgt.textContent = txt;
    }catch(e){ /* no-op */ }
  }
  function init(){
    copyDashNote();
    var src = document.getElementById('dashTargetNote');
    if(src && 'MutationObserver' in window){
      new MutationObserver(copyDashNote).observe(src, {childList:true, characterData:true, subtree:true});
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  // Public hook
  window.__mirrorAdjustedTargetToTotal = copyDashNote;
})();
</script>
<script>
(function(){
  // ---------- DATA (from user's message) ----------
  // Monthly CR (AED) as booked at month-end (YYYY-MM: amount)
  const cr = {
    "2025-01": 245452,
    "2025-02": 310654,
    "2025-03": 652458,
    "2025-04": 2273480,
    "2025-05": 739704,
    "2025-06": 640914,
    "2025-07": 0,
    "2025-08": 0,
    "2025-09": 0,
    "2025-10": 0,
    "2025-11": 0,
    "2025-12": 0
  };

  // Targets as due-date events (exact day)
  // Get current year being viewed
  const currentYear = window.currentYear || new Date().getFullYear();
  
  const targets = [
    {date: `${currentYear}-10-02`, amount: 2440000, label: "Plot 125/B/689 Industrial Area 13"},
    // The October target 5,550,000 is associated with Nov due(s). If split later, add two rows.
    {date: `${currentYear}-11-09`, amount: 5550000, label: "2 Plots - 3073 & 1308 - Muweileh (combined)"}
  ];

  // Utility: format AED
  const fmt = (n) => (n||0).toLocaleString(undefined, {maximumFractionDigits:0});

  // Sum monthly CR up to EOM of a given date.
  function cumCRThrough(dateStr){
    const d = new Date(dateStr + "T00:00:00");
    const y = d.getFullYear();
    const m = d.getMonth()+1;
    const endDay = new Date(y, m, 0).getDate();
    // If due is last day, include this month; else include previous month.
    const includeMonth = (d.getDate() === endDay) ? m : (m-1);
    let total = 0;
    const yyyy = y.toString();
    for (let mm=1; mm<=includeMonth; mm++){
      const key = yyyy + "-" + String(mm).padStart(2,"0");
      total += (cr[key]||0);
    }
    return total;
  }

  // Required cumulative by date = sum of all targets with date <= given date
  function requiredBy(dateStr){
    const d = new Date(dateStr + "T00:00:00");
    return targets.filter(t => new Date(t.date+"T00:00:00") <= d)
                  .reduce((a,t)=>a+(t.amount||0),0);
  }

  // Find next future due date relative to "today"
  const today = new Date();
  const futureTargets = targets.filter(t => new Date(t.date+"T00:00:00") >= today)
                               .sort((a,b)=> new Date(a.date) - new Date(b.date));
  const next = futureTargets[0] || targets[targets.length-1]; // fallback last

  // Get balance directly from table (same row as target)
  function getBalanceFromTable(targetDate) {
    try {
      const currentDate = new Date();
      const currentMonth = currentDate.getMonth(); // 0-based (0 = January, 9 = October)
      
      const tbody = document.getElementById('tableBody');
      if (!tbody) return 0;
      
      const rows = tbody.querySelectorAll('tr');
      
      if (rows[currentMonth] && rows[currentMonth].cells && rows[currentMonth].cells[10]) {
        const balanceCell = rows[currentMonth].cells[10]; // 11th column (Balance)
        const balanceText = balanceCell.textContent || '';
        // Extract numbers from balance cell (handle negative values)
        const cleanText = balanceText.replace(/[^0-9.-]/g, '');
        const balanceValue = parseFloat(cleanText) || 0;
        return Math.abs(balanceValue); // Return absolute value for gap calculation
      }
    } catch (e) { /* ignore */ }
    return 0;
  }

  // Compute numbers for next due
  const req = requiredBy(next.date);
  const available = cumCRThrough(next.date);
  // Get the month index for the next due date
  const nextMonth = new Date(next.date).getMonth();
  // Use balance from table instead of calculated gap
  const tableBalance = getBalanceFromTable(nextMonth);
  const gap = Math.abs(tableBalance);
  const cushion = tableBalance > 0 ? tableBalance : Math.max(0, available - req);

  // Get individual target amount directly from table cell
  function getTargetFromTable(targetDate) {
    try {
      const tbody = document.getElementById('tableBody');
      if (!tbody) return 0;
      
      const rows = tbody.querySelectorAll('tr');
      
      // Look for the row that matches the target date
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (!row.cells || row.cells.length < 6) continue;
        
        // Check if this row contains the target date in the Key Dates column (index 1)
        const keyDatesCell = row.cells[1];
        if (keyDatesCell && keyDatesCell.textContent) {
          const cellText = keyDatesCell.textContent;
          
          // Check if this row's date matches our target date (year-dynamic)
          if (cellText.includes('02/10/' + currentYear) && targetDate.includes(currentYear + '-10-02')) {
            const targetCell = row.cells[5]; // 6th column (Target)
            if (targetCell) {
              const targetText = targetCell.textContent || '';
              const targetValue = parseFloat(targetText.replace(/[^0-9]/g, '')) || 0;
              console.log('Found October target:', targetValue);
              return targetValue;
            }
          } else if (cellText.includes('09/11/' + currentYear) && targetDate.includes(currentYear + '-11-09')) {
            const targetCell = row.cells[5]; // 6th column (Target)
            if (targetCell) {
              const targetText = targetCell.textContent || '';
              const targetValue = parseFloat(targetText.replace(/[^0-9]/g, '')) || 0;
              console.log('Found November target:', targetValue);
              return targetValue;
            }
          }
        }
      }
    } catch (e) {
      console.warn('Error reading target from table:', e);
    }
    return 0;
  }

  const individualTarget = getTargetFromTable(next.date) || next.amount || 0;

  // Render
  document.getElementById("odc-next-due").textContent =
    new Date(next.date).toLocaleDateString(undefined,{day:"2-digit",month:"short",year:"numeric"});
  document.getElementById("odc-next-label").textContent = "• " + (next.label || "");
  document.getElementById("odc-required").textContent = fmt(individualTarget);
  
  // Get YTD Bank Inflow from the main dashboard instead of cumulative CR
  const ytdElement = document.getElementById('dashYtdAccomplished');
  const ytdValue = ytdElement ? parseFloat((ytdElement.textContent || '').replace(/[^0-9]/g, '')) || 0 : 0;
  document.getElementById("odc-cumcr").textContent = fmt(ytdValue);
  
  document.getElementById("odc-gap").textContent = tableBalance < 0 ? ("AED "+fmt(gap)) : ("0 (cushion AED "+fmt(cushion)+")");

  // OD utilisation (on due day) from localStorage
  function computeODUtil(){
    const limit = Number(localStorage.getItem("odc-limit") || 0);
    const eod = Number(localStorage.getItem("odc-eod") || 0);
    let util = "—";
    if (limit>0){
      const perc = Math.max(0, (-eod)/limit) * 100;
      util = (isFinite(perc)? perc.toFixed(1) + "%":"—");
    }
    const utilEl = document.getElementById("odc-od-util");
    const limitEl = document.getElementById("odc-od-limit");
    const balanceEl = document.getElementById("odc-od-balance");
    
    if (utilEl) utilEl.textContent = util;
    if (limitEl) limitEl.value = localStorage.getItem("odc-limit") || "";
    if (balanceEl) balanceEl.value = localStorage.getItem("odc-eod") || "";
  }

  computeODUtil();

  // Panel UI
  const gear = document.getElementById("odc-gear");
  const panel = document.getElementById("odc-panel");
  gear.addEventListener("click", ()=>{
    panel.style.display = (panel.style.display==="none"||!panel.style.display) ? "block" : "none";
  });

  document.getElementById("odc-save").addEventListener("click", ()=>{
    const limit = document.getElementById("odc-od-limit").value;
    const eod = document.getElementById("odc-od-balance").value;
    localStorage.setItem("odc-limit", limit);
    localStorage.setItem("odc-eod", eod);
    computeODUtil();
  });
})();
</script>
<script>
(function(){
  if (window.__ODC_RIBBON_WIRED__) return; window.__ODC_RIBBON_WIRED__=true;

  function fmt(n){ return Number(n||0).toLocaleString('en-US'); }
  const MONTHS = window.MONTHS || ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  function getOwner(){ try{ return owners && currentOwner ? owners[currentOwner] : null; }catch(_){ return null; } }

  function sumTo(arr,i){ let s=0; for(let k=0;k<=i;k++) s += Number(arr[k]||0); return s; }

  function findNextDue(owner, targets, actuals, keyDates, broughtForward){
    const now = new Date();
    function accumThrough(i){
      let s = Number(broughtForward||0);
      for(let k=0;k<=i;k++){ s += Number(actuals[k]||0) - Number(targets[k]||0); }
      return s;
    }
    const cand=[];
    for(let m=0;m<12;m++){
      if (accumThrough(m) >= 0) continue;
      const fut = (keyDates[m]||[]).map(d=>new Date(d)).filter(d=>d>now).sort((a,b)=>a-b);
      if (fut.length) cand.push({month:m,date:fut[0]});
    }
    if (cand.length){ cand.sort((a,b)=>a.date-b.date); return cand[0]; }
    for(let m=0;m<12;m++){ if (accumThrough(m) < 0){ const y=(new Date()).getFullYear(); return {month:m,date:new Date(y,m+1,0)}; } }
    return null;
  }

  function pickLabel(owner, month){
    try{
      const proj = owner.projects && owner.projects[month] ? String(owner.projects[month]).trim() : '';
      return proj || owner.name || '—';
    }catch(_){ return '—'; }
  }

  function computeODUtil(){
    try{
      const lim = Number(localStorage.getItem('__od_limit__')||0);
      const eod = Number(localStorage.getItem('__od_eod__')||0); // negative if OD used
      const util = (lim>0 && eod<0) ? Math.max(0, (-eod/lim)*100) : 0;
      return util.toFixed(1)+'%';
    }catch(_){ return '0.0%'; }
  }

  // Get individual target from table (same logic as other script blocks)
  function getTargetFromTable(targetDate) {
    try {
      const currentDate = new Date();
      const currentMonth = currentDate.getMonth(); // 0-based (0 = January, 9 = October)
      
      const tbody = document.getElementById('tableBody');
      if (!tbody) return 0;
      
      const rows = tbody.querySelectorAll('tr');
      
      if (rows[currentMonth] && rows[currentMonth].cells && rows[currentMonth].cells[5]) {
        const targetCell = rows[currentMonth].cells[5];
        const targetText = targetCell.textContent || '';
        // Extract only numbers from the target cell
        const cleanText = targetText.replace(/[^0-9]/g, '');
        const targetValue = parseFloat(cleanText) || 0;
        return targetValue;
      }
    } catch (e) { /* ignore */ }
    return 0;
  }

  // Get balance directly from table (same row as target)
  function getBalanceFromTable(monthIndex) {
    try {
      const tbody = document.getElementById('tableBody');
      if (!tbody) return 0;
      
      const rows = tbody.querySelectorAll('tr');
      
      // Use the month index parameter, or default to current month if not provided
      const targetMonth = monthIndex !== undefined ? monthIndex : new Date().getMonth();
      
      if (rows[targetMonth] && rows[targetMonth].cells && rows[targetMonth].cells[10]) {
        const balanceCell = rows[targetMonth].cells[10]; // 11th column (Balance)
        const balanceText = balanceCell.textContent || '';
        // Extract numbers from balance cell (preserve negative values)
        const cleanText = balanceText.replace(/[^\d.-]/g, '');
        const balanceValue = parseFloat(cleanText) || 0;
        console.log('Balance from table row', targetMonth, ':', balanceValue);
        return balanceValue; // Return actual balance (positive or negative)
      }
    } catch (e) { 
      console.warn('Error reading balance from table:', e);
    }
    return 0;
  }

  function renderDueRibbon(){
    const o = getOwner();
    if (!o) return;
    const targets = o.monthlyTargets || window.monthlyTargets || new Array(12).fill(0);
    const actuals = o.actuals        || window.actuals        || new Array(12).fill(0);
    const keyDates= o.keyDates       || window.keyDates       || new Array(12).fill(null).map(()=>[]);
    const bf      = Number(o.broughtForward || 0);

    const due = findNextDue(o, targets, actuals, keyDates, bf);

    const nd = document.getElementById('odc-next-due');
    const nl = document.getElementById('odc-next-label');
    const rq = document.getElementById('odc-required');
    const cc = document.getElementById('odc-cumcr');
    const gp = document.getElementById('odc-gap');
    const ou = document.getElementById('odc-od-util');

    if (!nd || !rq || !cc || !gp) return; // ribbon not present

    if (!due){
      nd.textContent = '—';
      if (nl) nl.textContent = '';
      // Use individual target from table instead of cumulative total
      const individualTarget = getTargetFromTable() || 0;
      rq.textContent = fmt(individualTarget);
      cc.textContent = fmt(bf + sumTo(actuals, 11));
      gp.textContent = '0';
      if (ou) ou.textContent = computeODUtil();
      return;
    }

    const m = due.month, y = due.date.getFullYear(), d = String(due.date.getDate()).padStart(2,'0');
    // Use individual target from table instead of cumulative total
    const individualTarget = getTargetFromTable(due.date) || targets[m] || 0;
    const required = individualTarget;
    const cumulative = bf + sumTo(actuals, m);
    // Get balance directly from table instead of calculating gap
    const gap = getBalanceFromTable(m);
    const cushion = Math.max(0, cumulative - required);

    nd.textContent = `${MONTHS[m]} ${d}, ${y}`;
    if (nl) nl.textContent = ` • ${pickLabel(o, m)}`;
    rq.textContent = fmt(required);
    cc.textContent = fmt(cumulative);
    // Use balance from table instead of calculated gap
    const tableBalance = getBalanceFromTable(m);
    gp.textContent = tableBalance < 0 ? `AED ${fmt(Math.abs(tableBalance))}` : `0 (cushion AED ${fmt(tableBalance)})`;
    if (ou) ou.textContent = computeODUtil();
  }

  // expose
  window.renderDueRibbon = renderDueRibbon;

  // wrap common functions to auto-refresh
  ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','switchOwner'].forEach(name=>{
    try{
      const fn = window[name];
      if (typeof fn === 'function'){
        window[name] = function(...args){
          const res = fn.apply(this,args);
          try{ renderDueRibbon(); }catch(_){}
          return res;
        }
      }
    }catch(_){}
  });

  document.addEventListener('DOMContentLoaded', function(){ try{ renderDueRibbon(); }catch(_){} });
  // safety net
  ['change','input','click'].forEach(ev => document.addEventListener(ev, ()=>{ try{ renderDueRibbon(); }catch(_){} }, {capture:true}));

})();
</script>
<!-- ENBD: Extend Due Ribbon to include "Next to Next" (same ribbon) -->
<script>
(function(){
  if (window.__ENBD_RIBBON_NEXT2__) return; window.__ENBD_RIBBON_NEXT2__ = true;

  function fmt(n){ return Number(n||0).toLocaleString('en-US'); }
  const MONTHS = (window.ENBD_Core && ENBD_Core.MONTHS) || ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  // Utility sums up to index i (inclusive)
  function sumTo(arr,i){ let s=0; for(let k=0;k<=i;k++) s += Number(arr[k]||0); return s; }

  // Core accessors (compatible with your wired build)
  function getOwner(){ return window.owners && window.currentOwner ? owners[currentOwner] : null; }
  function getAgg(o){
    if (window.ENBD_Core && ENBD_Core.getOwnerCalendarAgg) return ENBD_Core.getOwnerCalendarAgg(o);
    // Fallback to flat arrays if no multi-building core is present
    return {
      targets:(o.monthlyTargets||Array(12).fill(0)).slice(),
      expected:(o.expected||Array(12).fill(0)).slice(),
      actuals:(o.actuals||Array(12).fill(0)).slice(),
      keyDates:(o.keyDates||Array(12).fill(null).map(()=>[])).map(x=>x||[])
    };
  }

  // Find a sorted list (by date) of due items (month+date) where cumulative shortfall exists
  function findDueList(owner){
    const agg = getAgg(owner);
    const now = new Date();
    function accumThrough(i){
      let s = Number(owner.broughtForward||0);
      for (let k=0;k<=i;k++) s += Number(agg.actuals[k]||0) - Number(agg.targets[k]||0);
      return s;
    }
    const cands = [];
    for (let m=0;m<12;m++){
      if (accumThrough(m) >= 0) continue;
      const future = (agg.keyDates[m]||[]).map(d=>new Date(d)).filter(d=>d>now).sort((a,b)=>a-b);
      if (future.length) cands.push({month:m, date:future[0]});
    }
    cands.sort((a,b)=>a.date-b.date);
    // Fallbacks: if none found but there are negative months, add the first negative month-end
    if (!cands.length){
      for (let m=0;m<12;m++){
        if (accumThrough(m) < 0){
          const y = (new Date()).getFullYear();
          cands.push({month:m, date:new Date(y, m+1, 0)});
          break;
        }
      }
    } else {
      // Also consider further negative months with no key dates after the last key-dated candidate
      // so we can potentially produce a next-to-next even if only one had a key date.
      for (let m=0;m<12 && cands.length<3; m++){
        if (accumThrough(m) < 0 && !cands.find(x=>x.month===m)){
          const y = (new Date()).getFullYear();
          cands.push({month:m, date:new Date(y, m+1, 0)});
        }
      }
      cands.sort((a,b)=>a.date-b.date);
    }
    // De-duplicate months preserving order
    const seen = new Set();
    const list = [];
    for (const x of cands){
      if (!seen.has(x.month)){ seen.add(x.month); list.push(x); }
      if (list.length>=3) break;
    }
    return list;
  }

  function pickLabel(owner, calMonth){
    // Prefer project label on that calendar month if available, else owner/building name as wired earlier
    if (owner.projects && owner.projects[calMonth]){
      const s = String(owner.projects[calMonth]||'').trim();
      if (s) return s;
    }
    // If multi-building model exists, search any building that contributes key date in that calMonth
    if (owner.buildings){
      for (const b of owner.buildings){
        // map FY to calendar: try all 12 indices
        for (let i=0;i<12;i++){
          const cm = ((+b.fyStartMonth||0) + i) % 12;
          if (cm!==calMonth) continue;
          const kd = (b.keyDates?.[i]||[]);
          if (kd.length) return (b.projects?.[i]||'').toString().trim() || b.name || owner.name || "—";
        }
      }
    }
    return owner.name || "—";
  }

  // Extend existing renderer to include "next-to-next"
  function renderWithNext2(){
    const owner = getOwner(); if (!owner) return;
    const agg = getAgg(owner);
    const list = findDueList(owner);
    const bf = Number(owner.broughtForward||0);

    // Primary spans (existing single due)
    const nextDueEl   = document.getElementById('odc-next-due');
    const nextLabelEl = document.getElementById('odc-next-label');
    const reqEl       = document.getElementById('odc-required');
    const cumEl       = document.getElementById('odc-cumcr');
    const gapEl       = document.getElementById('odc-gap');

    // Secondary block (create once if missing)
    let block = document.getElementById('odc-next2-block');
    if (!block){
      const cont = document.getElementById('odc-ribbon') || document.getElementById('odc-ribbon-container');
      if (cont){
        block = document.createElement('div');
        block.id = 'odc-next2-block';
        block.style.cssText = 'margin-top:6px; opacity:.95; font-size:0.95em;';
        cont.appendChild(block);
      }
    }

    // Get balance directly from table (same row as target)
    function getBalanceFromTable(monthIndex) {
      try {
        const tbody = document.getElementById('tableBody');
        if (!tbody) return 0;
        
        const rows = tbody.querySelectorAll('tr');
        
        if (rows[monthIndex] && rows[monthIndex].cells && rows[monthIndex].cells[10]) {
          const balanceCell = rows[monthIndex].cells[10]; // 11th column (Balance)
          const balanceText = balanceCell.textContent || '';
          // Extract numbers from balance cell (preserve negative values)
          const cleanText = balanceText.replace(/[^\d.-]/g, '');
          const balanceValue = parseFloat(cleanText) || 0;
          return balanceValue; // Return actual balance (positive or negative)
        }
      } catch (e) { /* ignore */ }
      return 0;
    }

    function rowHTML(prefix, m, d, y, label, required, cumulative){
      // Get balance directly from table instead of calculating gap
      const tableBalance = getBalanceFromTable(m);
      const gap = Math.abs(tableBalance);
      const cushion = tableBalance > 0 ? tableBalance : 0;
      return (
        `<div><strong>${prefix}</strong>: ${MONTHS[m]} ${d}, ${y} • ${label}</div>`+
        `<div><strong>Target</strong>: AED ${fmt(required)}</div>`+
        `<div><strong>Actual Inflow</strong>: AED ${fmt(cumulative)}</div>`+
        `<div><strong>Gap to meet</strong>: ${tableBalance < 0 ? 'AED '+fmt(gap) : '0 (cushion AED '+fmt(cushion)+')'}</div>`
      );
    }

    // Render 1st (keep existing spans for backwards compatibility)
    if (list.length){
      const a = list[0];
      const m = a.month, y = a.date.getFullYear(), d = String(a.date.getDate()).padStart(2,'0');
      const label = pickLabel(owner, m);
      
      // Get target from table by looking for the specific month row
      function getTargetFromCurrentTable(monthIndex) {
        try {
          const tbody = document.getElementById('tableBody');
          if (!tbody) return 0;
          const rows = tbody.querySelectorAll('tr');
          
          // Month index should match table row (0-based)
          if (rows[monthIndex] && rows[monthIndex].cells && rows[monthIndex].cells[5]) {
            const targetCell = rows[monthIndex].cells[5];
            const targetText = targetCell.textContent || '';
            // Extract only numbers from the target cell
            const cleanText = targetText.replace(/[^0-9]/g, '');
            const targetValue = parseFloat(cleanText) || 0;
            console.log('[ODC] Target from table row', monthIndex, ':', targetValue);
            return targetValue;
          }
        } catch (e) { /* ignore */ }
        return 0;
      }
      
      // Always use individual target from table, do NOT fall back to cumulative agg.targets
      const required = getTargetFromCurrentTable(m) || 0;
      const cumulative = bf + sumTo(agg.actuals, m);

      if (nextDueEl) nextDueEl.textContent = MONTHS[m] + ' ' + d + ', ' + y;
      if (nextLabelEl) nextLabelEl.textContent = '• ' + label;
      if (reqEl) reqEl.textContent = fmt(required);
      if (cumEl) cumEl.textContent = fmt(cumulative);
      if (gapEl){
        const gap = Math.max(0, required - cumulative);
        const cushion = Math.max(0, cumulative - required);
        gapEl.textContent = (gap===0 ? `0 (cushion AED ${fmt(cushion)})` : `AED ${fmt(gap)}`);
      }
    }

    // Render 2nd (next-to-next) in the same ribbon block
    if (block){
      if (list.length >= 2){
        const b = list[1];
        const m2 = b.month, y2 = b.date.getFullYear(), d2 = String(b.date.getDate()).padStart(2,'0');
        const label2 = pickLabel(owner, m2);
        const required2 = getTargetFromTableCell(m2) || getTargetFromCurrentTable(m2) || 0;
        const cumulative2 = bf + sumTo(agg.actuals, m2);
        block.innerHTML = rowHTML('Next to Next Due', m2, d2, y2, label2, required2, cumulative2);
      } else {
        block.innerHTML = ''; // hide if not available
      }
    }
  }

  // Replace existing renderer if it exists; otherwise bind to common hooks
  window.renderDueRibbon = renderWithNext2;
  // Run once now
  try { renderWithNext2(); } catch(_) {}

  // Refresh when page scripts run their usual updates
  ['change','input','click'].forEach(ev => document.addEventListener(ev, ()=>{ try{ renderWithNext2(); }catch(_){ } }, {capture:true}));
  // If the page exposes these, hook them (no error if absent)
  ['renderAll','recalcSummary','updateCurrentOwnerData','saveState'].forEach(fn=>{
    try{
      if (window[fn] && typeof window[fn] === 'function'){
        const orig = window[fn];
        window[fn] = function(){ const r = orig.apply(this, arguments); try{ renderWithNext2(); }catch(_){ } return r; };
      }
    }catch(_){}
  });
})();
</script>
<!-- === OVERRIDE: Monthly pills use Balance from the table (last column) === -->
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    // parentheses negatives e.g., (100,000)
    if (/^\(.*\)$/.test(v)) {
      v = '-' + v.replace(/[()]/g, '');
    }
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return new Intl.NumberFormat().format(Math.round(Number(n||0))); }
    catch(_) { return (Number(n||0)).toString(); }
  }
  function monthName(i){ return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || '—'; }
  function nowMonth(){ try{return new Date().getMonth();}catch(_){return 0;} }

  // Robust header index lookup (find "Accum" column; fallback to last th)
  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }

  function getRowForMonth(i){
    // Prefer explicit data-month marker if present
    var tr = document.querySelector('tbody tr[data-month="'+(i+1)+'"]');
    if (tr) return tr;
    // Fallback: find row whose first numeric cell equals i+1
    var rows = Array.from((document.getElementById('tableBody') || document.querySelector('table tbody') || document).querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === i+1) return rows[k];
    }
    return null;
  }

  // Compute "next needed" index based on Balance (<0) forward-only
  function nextNeededIndexByAccum(){
    var start = nowMonth();
    for (var i=start;i<12;i++){
      var tr = getRowForMonth(i);
      if (!tr) continue;
      var tds = Array.from(tr.children);
      // Always read balance from the last column (rightmost)
      var lastColumnIndex = tds.length > 0 ? tds.length - 1 : -1;
      var accCell = lastColumnIndex >= 0 ? tds[lastColumnIndex] : null;
      var acc = parseNum(accCell ? (accCell.getAttribute('data-clean') || accCell.textContent) : 0);
      if (acc < 0) return i;
    }
    return -1;
  }

  window.renderMonthsMini = function renderMonthsMini(){
    var wrap = document.getElementById('monthsMini');
    if (!wrap) return;
    // Find important column indexes for Target/Actual (for display only)
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    var idxTarget = findHeaderIndex([/target|needed|req/i]);
    var idxActual = findHeaderIndex([/bank|actual|inflow/i]);
    // Balance will always be read from the last column of each row

    var html = [];
    var nextIdx = nextNeededIndexByAccum();
    for (var i=0;i<12;i++){
      var tr = getRowForMonth(i);
      var tds = tr ? Array.from(tr.children) : [];
      
      // Always read balance from the last column of this row
      var lastColumnIndex = tds.length > 0 ? tds.length - 1 : -1;
      
      var target = parseNum(tds[idxTarget] ? (tds[idxTarget].getAttribute('data-clean') || tds[idxTarget].textContent) : 0);
      var actual = parseNum(tds[idxActual] ? (tds[idxActual].getAttribute('data-clean') || tds[idxActual].textContent) : 0);
      var acc    = lastColumnIndex >= 0 ? parseNum(tds[lastColumnIndex] ? (tds[lastColumnIndex].getAttribute('data-clean') || tds[lastColumnIndex].textContent) : 0) : 0;

      var accLabel;
if (acc>0) { accLabel = 'Balance ' + fmt(acc); }
else if (acc<0) { accLabel = 'Balance (' + '<span class="neg">' + fmt(Math.abs(acc)) + '</span>' + ')'; }
else { accLabel = 'Balance —'; }
var cls = (acc>0) ? 'met' : (acc<0) ? 'unmet' : 'equal';
      if (i === nextIdx) cls += ' next';

      html.push(
        '<div class="month-pill '+cls+'" data-month="'+(i+1)+'">'+
          '<div>'+monthName(i)+'</div>'+
          '<div>'+ (target ? ('Target: '+fmt(target)) : 'Target: —') +'</div>'+
          '<div>'+ (actual ? ('Bank: '+fmt(actual)) : 'Bank: —') +'</div>'+
          '<div class="acc-var-label tiny">'+accLabel+'</div>'+
        '</div>'
      );
    }
    wrap.innerHTML = html.join('');

    // Wire popovers if enhancer exists
    if (window.__wireMonthPopovers && typeof window.__wireMonthPopovers === 'function'){
      try { window.__wireMonthPopovers(); } catch(_){}
    }
  };

  // Run once and then on updates
  try { window.renderMonthsMini(); } catch(_){}
  ['renderAll','recalcSummary','updateCurrentOwnerData','saveState'].forEach(function(fn){
    if (window[fn] && typeof window[fn] === 'function'){
      var orig = window[fn];
      window[fn] = function(){ var r = orig.apply(this, arguments); try{ window.renderMonthsMini(); }catch(_){ } return r; };
    }
  });
  ['change','input','click'].forEach(function(ev){
    document.addEventListener(ev, function(){ try{ window.renderMonthsMini(); }catch(_){ } }, {capture:true});
  });
})();
</script>
<span id="odc-od-util" style="display:none !important;"></span>
<!-- RIBBON: lock editing but keep values -->
<script>
(function(){
  function lockRibbon(root){
    if (!root) return;
    // Make form controls readonly/disabled but visible
    root.querySelectorAll('input, textarea, select').forEach(function(el){
      try {
        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA'){
          el.setAttribute('readonly','readonly');
        }
        if (el.tagName === 'SELECT' || el.type === 'checkbox' || el.type === 'radio'){
          el.setAttribute('disabled','disabled');
        }
        // Prevent value changes programmatically via user events
        el.addEventListener('keydown', function(e){ e.preventDefault(); }, {capture:true});
        el.addEventListener('input', function(e){ e.preventDefault(); }, {capture:true});
      } catch(_){}
    });
    // Disable contenteditable & dragging
    root.querySelectorAll('[contenteditable]').forEach(function(n){ try{ n.setAttribute('contenteditable','false'); }catch(_){} });
    root.querySelectorAll('[draggable="true"]').forEach(function(n){ try{ n.setAttribute('draggable','false'); }catch(_){} });
  }
  function attach(){
    var roots = Array.from(document.querySelectorAll('#creditRibbon, #greenRibbon, .credit-ribbon, .green-ribbon, .ribbon, .ribbon-strip, .ribbonRow, .ribbon-container'));
    if (!roots.length) return;
    roots.forEach(function(r){
      lockRibbon(r);
      // Keep locking after any render
      try{
        var mo = new MutationObserver(function(){ lockRibbon(r); });
        mo.observe(r, {subtree:true, childList:true, attributes:true});
      }catch(_){}
    });
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- RIBBON: Build 'All Targets' chips from table (uses Balance last column) -->
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return new Intl.NumberFormat().format(Math.round(Number(n||0))); }
    catch(_) { return (Number(n||0)).toString(); }
  }
  function monthName(i){ return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || '—'; }

  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }

  function getAllRows(){
    var tbody = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!tbody) return [];
    var rows = Array.from(tbody.querySelectorAll('tr'));
    // Filter out header-like or hidden rows
    return rows.filter(function(r){
      var style = (r.getAttribute('style')||'').toLowerCase();
      return !/display:\s*none/.test(style);
    });
  }

  
  function buildAllTargetChips(){
    var ribbonRoot = document.querySelector('#creditRibbon, #greenRibbon, .credit-ribbon, .green-ribbon, .ribbon, .ribbon-container, .ribbon-strip, .ribbonRow');
    if (!ribbonRoot) return;
    var host = document.getElementById('ribbonAllTargets');
    if (!host){
      host = document.createElement('div');
      host.id = 'ribbonAllTargets';
      ribbonRoot.appendChild(host);
    }

    function headers(){
      var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
      if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
      return ths.map(function(th){
        return (th.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
      });
    }
    var labs = headers();

    function findStrict(name, fallbackRegexes){
      var i = labs.indexOf(name.toLowerCase());
      if (i !== -1) return i;
      for (var j=0;j<labs.length;j++){
        if (new RegExp('(^|\\b)'+name.replace(/[.*+?^${}()|[\\]\\]/g,'\\$&')+'(\\b|$)').test(labs[j])) return j;
      }
      for (var r=0;r<(fallbackRegexes||[]).length;r++){
        for (var j2=0;j2<labs.length;j2++){
          if (fallbackRegexes[r].test(labs[j2])) return j2;
        }
      }
      return -1;
    }

    var idxTarget = findStrict('target', [/target/i]);
    var idxAccum  = findStrict('accum variance', [/acc.*var/i, /accum/i, /acc/i]);
    var idxMonth  = findStrict('month', [/^\s*month\s*$/i, /month/i]);

    function parseNum(v){
      if (v == null) return 0;
      v = (''+v).trim();
      if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
      v = v.replace(/[^0-9.-]/g, '');
      var n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    }
    function fmt(n){
      try { return new Intl.NumberFormat().format(Math.round(Number(n||0))); }
      catch(_) { return (Number(n||0)).toString(); }
    }
    function monthName(i){ return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || '—'; }

    function getAllRows(){
      var tbody = document.getElementById('tableBody') || document.querySelector('table tbody');
      if (!tbody) return [];
      return Array.from(tbody.querySelectorAll('tr'));
    }
    function isBroughtForwardRow(tr){
      var td0 = tr.querySelector('td');
      if (td0){
        var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
        if (n === 0) return true; // BF row marked as #0
      }
      var txt = (tr.textContent||'').toLowerCase();
      return /brought\s*forward|opening\s*balance/.test(txt);
    }
    function getMonthInfo(tr, rowIndex){
      var dm = tr.getAttribute('data-month');
      if (dm && /^\d+$/.test(dm)) return { i: Math.max(0, Math.min(11, parseInt(dm,10))) , label: monthName(parseInt(dm,10)) };
      var tds = Array.from(tr.children);
      var label = (idxMonth >=0 && tds[idxMonth]) ? (tds[idxMonth].textContent || '').trim() : '';
      var map = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,sept:8,oct:9,nov:10,dec:11};
      var key = label.toLowerCase().slice(0,4);
      if (key in map) return { i: map[key], label: label || monthName(map[key]) };
      return { i: rowIndex, label: monthName(rowIndex) };
    }

    var rows = getAllRows();
    var chips = [];

    rows.forEach(function(tr, k){
      if (!tr || isBroughtForwardRow(tr)) return;
      var tds = Array.from(tr.children);

      var targetCell = (idxTarget >= 0 ? tds[idxTarget] : null) || tds[5];
      var target = parseNum(targetCell ? (targetCell.getAttribute('data-clean') || targetCell.textContent) : 0);
      if (!(target>0) && targetCell){
        var dt = targetCell.getAttribute('data-target');
        if (dt != null) target = parseNum(dt);
      }
      if (!(target > 0)) return;

      var accCell = (idxAccum >= 0 ? tds[idxAccum] : tds[tds.length - 1]);
      var acc = parseNum(accCell ? (accCell.getAttribute('data-clean') || accCell.textContent) : 0);

      var m = getMonthInfo(tr, k);
      var cls = (acc>0) ? 'surplus' : (acc<0) ? 'shortage' : 'equal';
      var accLabel = (acc>0) ? ('Surplus AED ' + fmt(acc)) : (acc<0) ? ('Shortage (AED ' + fmt(Math.abs(acc)) + ')') : 'Balanced';

      var chip = '<span class="ribbon-all-chip '+cls+'" data-month="'+(m.i+1)+'">'+
                  '<span class="m">'+ (m.label || monthName(m.i)) +'</span>'+
                  '<span class="t">• Target AED '+fmt(target)+'</span>'+
                  '<span class="a acc">• Balance: '+accLabel+'</span>'+
                 '</span>';
      chips.push({ i: m.i, html: chip });
    });

    chips.sort(function(a,b){ return a.i - b.i; });

    host.innerHTML = chips.map(function(c){ return c.html; }).join('');

    host.querySelectorAll('input, select, textarea, button, a').forEach(function(el){
      el.setAttribute('tabindex','-1');
      el.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation();}, {capture:true});
    });
  }
var idxTarget = findHeaderIndex([/target|needed|req/i]);
    var idxAccum  = findHeaderIndex([/acc\w*var/i, /accum/i, /acc/i]);
    var idxMonth  = findHeaderIndex([/^\s*month\s*$/i, /month/i]);

    var chips = [];
    var rows = getAllRows();

    // Attempt to derive month index per row by either data-month or first cell (#) or Month column text
    function getMonthInfo(tr, rowIndex){
      var dm = tr.getAttribute('data-month');
      if (dm && /^\d+$/.test(dm)) return { i: Math.max(0, Math.min(11, parseInt(dm,10))) , label: monthName(parseInt(dm,10)) };
      // If Month column exists
      var tds = Array.from(tr.children);
      var label = (idxMonth >=0 && tds[idxMonth]) ? (tds[idxMonth].textContent || '').trim() : '';
      // Guess numeric month from label
      var map = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,sept:8,oct:9,nov:10,dec:11};
      var key = label.toLowerCase().slice(0,3);
      if (key in map) return { i: map[key], label: label || monthName(map[key]) };
      // Fallback: use rowIndex (assuming table ordered Jan..Dec)
      return { i: rowIndex, label: monthName(rowIndex) };
    }

    rows.forEach(function(tr, k){
      var tds = Array.from(tr.children);
      var target = parseNum(tds[idxTarget] ? (tds[idxTarget].getAttribute('data-clean') || tds[idxTarget].textContent) : 0);
      if (target <= 0) return;

      var acc = parseNum(tds[idxAccum] ? (tds[idxAccum].getAttribute('data-clean') || tds[idxAccum].textContent) : (tds[tds.length-1] ? tds[tds.length-1].textContent : 0));
      var m = getMonthInfo(tr, k);
      var cls = (acc>0) ? 'surplus' : (acc<0) ? 'shortage' : 'equal';
      var accLabel = (acc>0) ? ('Surplus AED ' + fmt(acc)) : (acc<0) ? ('Shortage (AED ' + fmt(Math.abs(acc)) + ')') : 'Balanced';
      var chip = '<span class="ribbon-all-chip '+cls+'" data-month="'+(m.i+1)+'">'+
                 '<span class="m">'+ (m.label || monthName(m.i)) +'</span>'+
                 '<span class="t">• Target AED '+fmt(target)+'</span>'+
                 '<span class="a acc">• Balance: '+accLabel+'</span>'+
                 '</span>';
      chips.push({ i: m.i, html: chip });
    });

    // Sort by month index to keep chronological order
    chips.sort(function(a,b){ return a.i - b.i; });

    host.innerHTML = chips.map(function(c){ return c.html; }).join('');

    // Enforce display-only interactions for the new area
    host.querySelectorAll('input, select, textarea, button, a').forEach(function(el){
      el.setAttribute('tabindex','-1');
      el.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation();}, {capture:true});
    });
  }

  // Run now and after KPI renders
  function attach(){
    try { buildAllTargetChips(); } catch(e){}
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','renderRibbon','renderKPIs','renderTable'].forEach(function(fn){
      if (window[fn] && typeof window[fn] === 'function'){
        var orig = window[fn];
        window[fn] = function(){ var r = orig.apply(this, arguments); try{ buildAllTargetChips(); }catch(_){ } return r; };
      }
    });
    document.addEventListener('input', function(){ try{ buildAllTargetChips(); }catch(_){ } }, {capture:true});
    document.addEventListener('click', function(){ try{ buildAllTargetChips(); }catch(_){ } }, {capture:true});
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- === OVERRIDE: Next Needed + Circle pull from table Balance (last column) === -->
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return new Intl.NumberFormat().format(Math.round(Number(n||0))); }
    catch(_) { return (Number(n||0)).toString(); }
  }
  function monthName(i){ return ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i] || '—'; }
  function nowMonth(){ try{return new Date().getMonth();}catch(_){return 0;} }

  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }
  function tbodyNode(){
    return document.getElementById('tableBody') || document.querySelector('table tbody');
  }
  function getRowForMonth(i){
    var tbody = tbodyNode(); if (!tbody) return null;
    // data-month
    var tr = tbody.querySelector('tr[data-month="'+i+'"]');
    if (tr) return tr;
    // # column equals i+1
    var rows = Array.from(tbody.querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === i+1) return rows[k];
    }
    return null;
  }
  function accAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxAccum = findHeaderIndex([/acc\w*var/i, /accum/i, /acc/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxAccum] || tds[tds.length - 1];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function targetAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxTarget = findHeaderIndex([/^\s*target\s*$/i, /target|needed|req/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxTarget] || tds[5];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function firstFutureShortageIdx(){
    var start = nowMonth();
    for (var i=start;i<12;i++){
      var t = targetAt(i);
      var a = accAt(i);
      if (t>0 && a<0) return i;
    }
    return -1;
  }

  function updateNextNeededFromTable(){
    var idx = firstFutureShortageIdx();
    var pill = document.getElementById('nextMonthPill');
    var txt  = document.getElementById('nextText');
    var days = document.getElementById('nextDays');
    var gauge= document.querySelector('.gaugeText, #gaugeText, [data-gauge-text]');
    var container = document.getElementById('nextContainer') || (txt && txt.closest('.nextAlert'));

    if (idx === -1){
      if (container){ container.style.display = 'none'; container.classList.remove('shortage'); }
      var dash = document.getElementById('dashNextText');
      if (dash){
        dash.innerHTML = '<span style="background:#eaf7ed;padding:6px 10px;border-radius:8px;font-weight:600;">All targets met 🎉</span>';
        dash.classList.add('alert-green');
      }
      if (gauge){ gauge.innerHTML = '<div class="month">All Met 🎉</div>'; }
      return;
    }

    var acc = accAt(idx);
    var shortage = Math.max(0, -acc);
    var surplus  = Math.max(0,  acc);
    var targ     = targetAt(idx);

    if (pill) pill.textContent = monthName(idx);
    if (txt){
      if (shortage>0){
        txt.innerHTML = '<strong>'+fmt(targ)+'</strong> <span style="color:var(--orange-red-flag);">(shortage '+fmt(shortage)+')</span>';
        if (container){ container.style.display = 'flex'; container.classList.add('shortage'); }
      } else if (surplus>0){
        txt.innerHTML = '<strong>'+fmt(targ)+'</strong> <span style="color:var(--green);">(surplus '+fmt(surplus)+')</span>';
        if (container){ container.style.display = 'flex'; container.classList.remove('shortage'); }
      } else {
        txt.innerHTML = '<strong>'+fmt(targ)+'</strong> <span class="muted">(met)</span>';
        if (container){ container.style.display = 'flex'; container.classList.remove('shortage'); }
      }
    }
    if (gauge){
      var tooltip = '';
      var shortageLine = shortage>0 ? ('<br><span style="font-size: 8px; color:var(--orange-red-flag);">shortage '+fmt(shortage)+'</span>') : '';
      gauge.innerHTML = '<div class="month" style="font-size: 12px">'+fmt(targ)+shortageLine+'</div>';
    }
    // Keep existing days calc if available
    try {
      if (typeof getDaysToNext === 'function' && window.keyDates && keyDates[idx]){
        var d = getDaysToNext(keyDates[idx]);
        if (days) days.textContent = (d === '—' || d === 'Past') ? '-' : (d === 'Today' ? 'Today' : (d+'d'));
      }
    } catch(_){}
  }

  // Run initially and after major renders
  function attach(){
    try{ updateNextNeededFromTable(); }catch(_){}
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','renderRibbon','renderKPIs','renderTable'].forEach(function(fn){
      if (window[fn] && typeof window[fn] === 'function'){
        var orig = window[fn];
        window[fn] = function(){
          var r = orig.apply(this, arguments);
          try{ updateNextNeededFromTable(); }catch(_){}
          return r;
        };
      }
    });
    document.addEventListener('input', function(){ try{ updateNextNeededFromTable(); }catch(_){} }, {capture:true});
    document.addEventListener('click', function(){ try{ updateNextNeededFromTable(); }catch(_){} }, {capture:true});
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- OVERRIDE: Next Target mini card uses Balance from table (last column) -->
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return (window.formatNumber ? formatNumber(n) : new Intl.NumberFormat().format(Math.round(Number(n||0)))); }
    catch(_) { return String(n||0); }
  }
  function monthName(i){
    try{
      var arr = (Array.isArray(window.months) && window.months.length===12) ? window.months :
                ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      return arr[i] || '—';
    }catch(_){ return '—'; }
  }
  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }
  function tbodyNode(){ return document.getElementById('tableBody') || document.querySelector('table tbody'); }
  function getRowForMonth(i){
    var tbody = tbodyNode(); if (!tbody) return null;
    var tr = tbody.querySelector('tr[data-month="'+i+'"]');
    if (tr) return tr;
    var rows = Array.from(tbody.querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === i+1) return rows[k];
    }
    return null;
  }
  function accAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxAccum = findHeaderIndex([/acc\w*var/i, /accum/i, /acc/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxAccum] || tds[tds.length - 1];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function targetAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxTarget = findHeaderIndex([/^\s*target\s*$/i, /target|needed|req/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxTarget] || tds[5];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function findNextTargetCalendarOnly(){
    // reuse existing if available
    if (typeof window.findNextTargetCalendarOnly === 'function') return window.findNextTargetCalendarOnly();
    // fallback: earliest future target month with Target>0 from nowMonth
    var start = (new Date()).getMonth();
    for (var i=start;i<12;i++){ if (targetAt(i)>0) return {index:i, target:targetAt(i)}; }
    return {index:start, target:targetAt(start)};
  }

  function renderNextTargetMain_OVRD(){
    var card = (function ensure(){
      var host = document.getElementById('mainSection') ||
                 document.querySelector('.main, .content, .container, #content') ||
                 document.body;
      var c = document.getElementById('nextTargetCard');
      if (!c){
        c = document.createElement('div');
        c.id = 'nextTargetCard';
        c.className = 'next-target-card';
        host.insertBefore(c, host.firstChild);
      }
      return c;
    })();

    var nxt = findNextTargetCalendarOnly();
    var m = monthName(nxt.index);
    var targ = targetAt(nxt.index);
    var acc = accAt(nxt.index);

    var statusText = '';
    var statusClass = '';
    if (acc > 0) { statusText = ' (surplus)'; statusClass = 'surplus'; }
    else if (acc < 0) { statusText = ' (shortage)'; statusClass = 'shortage'; }
    else { statusText = ' (balanced)'; statusClass = 'balanced'; }

    card.innerHTML = '<div class="ntc-label">Next Target</div>'+
      '<div class="ntc-line">'+
      '<span class="ntc-month">'+m+'</span>'+
      '<span class="ntc-sep">—</span>'+
      '<span class="ntc-amt">'+fmt(targ)+'</span>'+
      '<span class="ntc-status '+statusClass+'">'+statusText+'</span>'+
      '</div>';
  }

  // Patch global reference so any re-renders use the override
  window.renderNextTargetMain = renderNextTargetMain_OVRD;
  window.refreshNextTargetMain = renderNextTargetMain_OVRD;

  // Run once on load
  try { renderNextTargetMain_OVRD(); } catch(_){}
})();
</script>
<!-- OVERRIDE v3: Next Target card lists ALL upcoming targets using Balance (last column) -->
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return (window.formatNumber ? formatNumber(n) : new Intl.NumberFormat().format(Math.round(Number(n||0)))); }
    catch(_) { return String(n||0); }
  }
  function monthName(i){
    try{
      var arr = (Array.isArray(window.months) && window.months.length===12) ? window.months :
                ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      return arr[i] || '—';
    }catch(_){ return '—'; }
  }
  function nowMonth(){ try{return new Date().getMonth();}catch(_){return 0;} }
  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }
  function tbodyNode(){ return document.getElementById('tableBody') || document.querySelector('table tbody'); }
  function getRowForMonth(i){
    var tbody = tbodyNode(); if (!tbody) return null;
    var tr = tbody.querySelector('tr[data-month="'+i+'"]');
    if (tr) return tr;
    var rows = Array.from(tbody.querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === i+1) return rows[k];
    }
    return null;
  }
  function accAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxAccum = findHeaderIndex([/acc\w*var/i, /accum/i, /acc/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxAccum] || tds[tds.length - 1];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function targetAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxTarget = findHeaderIndex([/^\s*target\s*$/i, /target|needed|req/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxTarget] || tds[5];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }

  function ensureCard(){
    var host = document.getElementById('mainSection') ||
               document.querySelector('.main, .content, .container, #content') ||
               document.body;
    var c = document.getElementById('nextTargetCard');
    if (!c){
      c = document.createElement('div');
      c.id = 'nextTargetCard';
      c.className = 'next-target-card';
      host.insertBefore(c, host.firstChild);
    }
    return c;
  }

  function renderNextTargetMain_LIST(){
    var card = ensureCard();
    var start = nowMonth();
    var lines = [];
    for (var i=start;i<12;i++){
      var t = targetAt(i);
      if (!(t>0)) continue;
      var acc = accAt(i);
      var accCls = (acc>0) ? 'pos' : (acc<0) ? 'neg' : 'zero';
      lines.push('<div class="ntc-row">'+
                   '<span class="m">'+monthName(i)+'</span> '+
                   '<span class="lbl">target</span> (<span class="amt">'+fmt(t)+'</span>) '+
                   '<span class="lbl">Balance</span> (<span class="acc '+accCls+'">'+fmt(acc)+'</span>)'+
                 '</div>');
    }
    if (!lines.length){
      lines.push('<div class="ntc-row muted">No upcoming targets</div>');
    }
    card.innerHTML = '<div class="ntc-label">Next Targets</div>'+
                     '<div class="ntc-list">'+lines.join('')+'</div>';
  }

  // Styling for the list view
  (function injectStyles(){
    if (document.getElementById('nextTargetCardListStyles')) return;
    var css = document.createElement('style');
    css.id = 'nextTargetCardListStyles';
    css.textContent = [
      '.next-target-card .ntc-list{ display:flex; flex-direction:column; gap:4px; }',
      '.next-target-card .ntc-row{ font-size: 13px; line-height:1.2; }',
      '.next-target-card .ntc-row .lbl{ color: var(--muted, #6c757d); }',
      '.next-target-card .ntc-row .acc.neg{ color:#c62828; font-weight:600; }',
      '.next-target-card .ntc-row .acc.pos{ color:#2e7d32; font-weight:600; }',
      '.next-target-card .ntc-row .acc.zero{ color: var(--muted, #6c757d); }',
      '.next-target-card .ntc-label{ font-weight:700; margin-bottom:6px; font-size: 13px; color: var(--text-bold, #334); }'
    ].join('\n');
    document.head.appendChild(css);
  })();

  // Replace previous assignment so refresh hooks use the list renderer
  window.renderNextTargetMain = renderNextTargetMain_LIST;
  window.refreshNextTargetMain = renderNextTargetMain_LIST;

  // Run now, and re-run after common recalculations
  function attach(){
    try{ renderNextTargetMain_LIST(); }catch(_){}
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','renderRibbon','renderKPIs','renderTable'].forEach(function(fn){
      if (window[fn] && typeof window[fn] === 'function'){
        var orig = window[fn];
        window[fn] = function(){ var r = orig.apply(this, arguments); try{ renderNextTargetMain_LIST(); }catch(_){ } return r; };
      }
    });
    document.addEventListener('input', function(){ try{ renderNextTargetMain_LIST(); }catch(_){ } }, {capture:true});
    document.addEventListener('click', function(){ try{ renderNextTargetMain_LIST(); }catch(_){ } }, {capture:true});
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- OVERRIDE v4: Expandable Next Targets floating widget (uses Balance last column) -->
<style id="nextTargetsWidgetStyles">
  #nextTargetsWidget{
    position: fixed;
    top: 96px;
    left: 16px;
    z-index: 9999;
    font-family: inherit;
  }
  .ntw{
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }
  .ntw-toggle{
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 999px;
    border: 1px solid rgba(74,141,133,0.18);
    background: rgba(255,255,255,0.7);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.08);
    cursor: pointer;
    font-size: 13px;
    line-height: 1;
    color: #2a3a3a;
    user-select: none;
  }
  .ntw-toggle .dot{
    width: 8px; height: 8px; border-radius: 999px; background: #4a8d85;
  }
  .ntw-toggle .caret{ transition: transform .22s ease; display:inline-block; }
  .ntw.expanded .ntw-toggle .caret{ transform: rotate(180deg); }

  .ntw-panel{
    min-width: 280px;
    max-width: 360px;
    max-height: 0;
    overflow: hidden;
    border-radius: 14px;
    border: 1px solid rgba(74,141,133,0.16);
    background: rgba(255,255,255,0.82);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0 18px 40px rgba(0,0,0,0.12);
    transition: max-height .28s ease, opacity .18s ease;
    opacity: 0;
  }
  .ntw.expanded .ntw-panel{ max-height: 62vh; opacity: 1; }

  .ntw-head{
    display:flex; align-items:center; justify-content:space-between;
    padding: 10px 12px 6px 12px; border-bottom:1px dashed rgba(74,141,133,0.18);
  }
  .ntw-title{ font-weight: 700; font-size: 13px; color:#203233 }
  .ntw-meta{ font-size: 12px; color: #6b7a7a }
  .ntw-body{ padding: 8px 12px 10px 12px; display:flex; flex-direction:column; gap:6px; }

  .ntc-row{
    font-size: 13px; line-height: 1.25;
    display:flex; flex-wrap:wrap; gap:6px; align-items:center;
    padding: 6px 8px; border-radius: 10px;
    background: rgba(74,141,133,0.05);
    border: 1px solid rgba(74,141,133,0.12);
  }
  .ntc-row .m{ font-weight:700; min-width:40px; }
  .ntc-row .lbl{ color: #6c757d; }
  .ntc-row .amt{ font-weight:600; }
  .ntc-row .acc.neg{ color:#c62828; font-weight:600; }
  .ntc-row .acc.pos{ color:#2e7d32; font-weight:600; }
  .ntc-row .acc.zero{ color:#6c757d; }

  /* Responsive: tuck under ribbons on small screens */
  @media (max-width: 980px){
    #nextTargetsWidget{ top: 84px; left: 10px; }
    .ntw-panel{ min-width: 240px; }
  }
</style>
<script>
(function(){
  function parseNum(v){
    if (v == null) return 0;
    v = (''+v).trim();
    if (/^\(.*\)$/.test(v)) v = '-' + v.replace(/[()]/g, '');
    v = v.replace(/[^0-9.-]/g, '');
    var n = parseFloat(v);
    return isNaN(n) ? 0 : n;
  }
  function fmt(n){
    try { return (window.formatNumber ? formatNumber(n) : new Intl.NumberFormat().format(Math.round(Number(n||0)))); }
    catch(_) { return String(n||0); }
  }
  function monthName(i){
    try{
      var arr = (Array.isArray(window.months) && window.months.length===12) ? window.months :
                ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      return arr[i] || '—';
    }catch(_){ return '—'; }
  }
  function nowMonth(){ try{return new Date().getMonth();}catch(_){return 0;} }

  function findHeaderIndex(regexList){
    var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
    if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').toLowerCase();
      for (var r=0;r<regexList.length;r++){
        if (regexList[r].test(t)) return i;
      }
    }
    return ths.length ? (ths.length - 1) : -1;
  }
  function tbodyNode(){ return document.getElementById('tableBody') || document.querySelector('table tbody'); }
  function getRowForMonth(i){
    var tbody = tbodyNode(); if (!tbody) return null;
    var tr = tbody.querySelector('tr[data-month="'+i+'"]');
    if (tr) return tr;
    var rows = Array.from(tbody.querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === i+1) return rows[k];
    }
    return null;
  }
  function accAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxAccum = findHeaderIndex([/acc\w*var/i, /accum/i, /acc/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxAccum] || tds[tds.length - 1];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }
  function targetAt(i){
    var tr = getRowForMonth(i); if (!tr) return 0;
    var idxTarget = findHeaderIndex([/^\s*target\s*$/i, /target|needed|req/i]);
    var tds = Array.from(tr.children);
    var cell = tds[idxTarget] || tds[5];
    return parseNum(cell ? (cell.getAttribute('data-clean') || cell.textContent) : 0);
  }

  function ensureWidget(){
    var host = document.getElementById('nextTargetsWidget');
    if (host) return host;
    host = document.createElement('div');
    host.id = 'nextTargetsWidget';
    host.className = 'ntw collapsed';

    var btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'ntw-toggle';
    btn.innerHTML = '<span class="dot"></span><span>Next Targets</span><span class="caret">▾</span>';
    host.appendChild(btn);

    var panel = document.createElement('div');
    panel.className = 'ntw-panel';
    panel.innerHTML = '<div class="ntw-head"><div class="ntw-title">Next Targets</div><div class="ntw-meta" id="ntwMeta">—</div></div><div class="ntw-body" id="ntwBody"></div>';
    host.appendChild(panel);

    document.body.appendChild(host);

    // Toggle behavior
    btn.addEventListener('click', function(e){
      e.stopPropagation();
      host.classList.toggle('expanded');
      host.classList.toggle('collapsed');
    });
    // Click-away to collapse
    document.addEventListener('click', function(e){
      if (!host.contains(e.target)) {
        host.classList.remove('expanded');
        host.classList.add('collapsed');
      }
    });

    return host;
  }

  function renderWidget(){
    var host = ensureWidget();
    var body = host.querySelector('#ntwBody');
    var meta = host.querySelector('#ntwMeta');
    if (!body) return;

    var start = (window.currentYear && window.currentYear !== (new Date()).getFullYear()) ? 0 : nowMonth();
    var lines = [];
    var count = 0;
    for (var i=start;i<12;i++){
      var t = targetAt(i);
      if (!(t>0)) continue;
      var acc = accAt(i);
      var accCls = (acc>0) ? 'pos' : (acc<0) ? 'neg' : 'zero';
      var row = '<div class="ntc-row">'+
                  '<span class="m">'+monthName(i)+'</span>'+
                  '<span class="lbl">&nbsp;target</span> (<span class="amt">'+fmt(t)+'</span>)'+
                  '<span class="lbl">&nbsp;Balance</span> (<span class="acc '+accCls+'">'+fmt(acc)+'</span>)'+
                '</div>';
      lines.push({i:i, html:row});
      count++;
    }
    lines.sort(function(a,b){ return a.i - b.i; });
    body.innerHTML = lines.map(function(x){ return x.html; }).join('') || '<div class="ntc-row">No upcoming targets</div>';
    if (meta) meta.textContent = ('Year: ' + (window.currentYear || (new Date()).getFullYear()) + ' • ' + count ? (count+' items') : '—');
  }

  function attach(){
    try{ renderWidget(); }catch(_){}
    // Re-render on common updates
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','renderRibbon','renderKPIs','renderTable'].forEach(function(fn){
      if (window[fn] && typeof window[fn] === 'function'){
        var orig = window[fn];
        window[fn] = function(){ var r = orig.apply(this, arguments); try{ renderWidget(); }catch(_){ } return r; };
      }
    });
    document.addEventListener('input', function(){ try{ renderWidget(); }catch(_){ } }, {capture:true});
    document.addEventListener('click', function(){ try{ renderWidget(); }catch(_){ } }, {capture:true});
    window.renderNextTargetMain = renderWidget;
    window.refreshNextTargetMain = renderWidget;
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- KILL OLD MINI CARD (logic) -->
<script id="killOldNextTargetCardJS">
(function(){
  function nukeCard(){
    try{ var el = document.getElementById('nextTargetCard'); if (el) el.remove(); }catch(_){}
    try{ document.querySelectorAll('.next-target-card').forEach(function(n){ n.remove(); }); }catch(_){}
  }
  function stubEnsure(){
    try { window.ensureNextTargetCard = function(){ 
      var d = document.createElement('div'); 
      d.id = 'nextTargetCard'; 
      d.style.display = 'none'; 
      return d; 
    }; } catch(_){}
  }
  function overrideRenders(){
    try{
      if (typeof window.renderNextTargetMain !== 'function') window.renderNextTargetMain = function(){};
      if (typeof window.refreshNextTargetMain !== 'function') window.refreshNextTargetMain = function(){};
    }catch(_){}
  }

  function attach(){
    nukeCard(); stubEnsure(); overrideRenders();
    // Keep killing if other scripts try to recreate it
    try{
      var mo = new MutationObserver(function(){ nukeCard(); });
      mo.observe(document.body, {childList:true, subtree:true});
      // also periodically nuke for safety (lightweight)
      setTimeout(nukeCard, 200);
      setTimeout(nukeCard, 800);
      setTimeout(nukeCard, 2000);
    }catch(_){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- === Injected: Cosmetic rename of "Acc. / Accum. Variance" to "Balance" (safe, post-load) === -->
<script>
(function(){
  function runRename(){
    try{
      var patterns = [
        /\bACC\.?\s*Variance\b/gi,
        /\bAcc\.?\s*Variance\b/gi,
        /\bAccu\.?\s*Variance\b/gi,
        /\bAccum\.?\s*Variance\b/gi,
        /\bAccumulated\s*Variance\b/gi,
        /\bAcc\s*Var(?:iance)?\b/gi
      ];
      function shouldSkip(node){
        if(!node || !node.parentNode) return true;
        var tag = node.parentNode.nodeName;
        return ['SCRIPT','STYLE','NOSCRIPT','TEXTAREA','INPUT','OPTION'].indexOf(tag) !== -1;
      }
      function replaceTextNode(node){
        if(shouldSkip(node)) return;
        var text = node.nodeValue;
        var changed = false;
        for(var i=0;i<patterns.length;i++){
          if(patterns[i].test(text)){
            text = text.replace(patterns[i], 'Balance');
            changed = true;
          }
        }
        if(changed){ node.nodeValue = text; }
      }
      // Walk all text nodes under body
      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
      var n;
      while(n = walker.nextNode()){
        replaceTextNode(n);
      }
      // Also try common table header cells explicitly
      Array.from(document.querySelectorAll('thead th, tfoot th')).forEach(function(th){
        var t = (th.textContent || '').trim();
        if(/acc/i.test(t) && /var/i.test(t)){
          th.setAttribute('data-original-label', t);
          th.textContent = 'Balance';
        }
      });
      // Observe dynamic changes (popovers, tooltips, injected text, etc.)
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(m){
          if(m.type === 'childList'){
            m.addedNodes.forEach(function(node){
              if(node.nodeType === Node.TEXT_NODE){ replaceTextNode(node); }
              else if(node.nodeType === Node.ELEMENT_NODE){
                var w = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);
                var x;
                while(x = w.nextNode()){ replaceTextNode(x); }
              }
            });
          } else if(m.type === 'characterData'){
            replaceTextNode(m.target);
          }
        });
      });
      mo.observe(document.body, { childList:true, subtree:true, characterData:true });
    }catch(e){ console.warn('Rename to Balance failed:', e); }
  }
  // Run after full load so any logic that depends on the original header text remains intact.
  window.addEventListener('load', runRename, { once: true });
})();
</script>
<!-- === Injected: Live rename of "Acc/Accum Variance" -> "Balance" using MutationObserver === -->
<script>
(function(){
  var patterns = [
    /\bACC\.?\s*Variance\b/gi,
    /\bAcc\.?\s*Variance\b/gi,
    /\bAccu\.?\s*Variance\b/gi,
    /\bAccum\.?\s*Variance\b/gi,
    /\bAccumulated\s*Variance\b/gi,
    /\bAcc\s*Var(?:iance)?\b/gi
  ];
  function shouldSkip(node){
    if(!node || !node.parentNode) return true;
    var tag = node.parentNode.nodeName;
    return ['SCRIPT','STYLE','NOSCRIPT','TEXTAREA','INPUT','OPTION'].indexOf(tag) !== -1;
  }
  function renameNodeText(node){
    if(shouldSkip(node)) return;
    var text = node.nodeValue, changed=false;
    for(var i=0;i<patterns.length;i++){
      if(patterns[i].test(text)){
        text = text.replace(patterns[i], 'Balance');
        changed = true;
      }
    }
    if(changed) node.nodeValue = text;
  }
  function walk(root){
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
    var n; while(n = walker.nextNode()){ renameNodeText(n); }
  }
  function handleMutations(muts){
    for(var i=0;i<muts.length;i++){
      var m = muts[i];
      if(m.type === 'childList'){
        m.addedNodes.forEach(function(n){
          if(n.nodeType === 3) renameNodeText(n);
          else if(n.nodeType === 1) walk(n);
        });
      } else if(m.type === 'characterData'){
        renameNodeText(m.target);
      }
    }
  }
  function runInitial(){ walk(document.body); }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', runInitial);
  else runInitial();
  var obs = new MutationObserver(handleMutations);
  obs.observe(document.body, { childList: true, characterData: true, subtree: true });
})();
</script>
<!-- === Patch v2: Monthly Pills Month Names + Balance label (Aug 26, 2025) === -->
<script id="patch-month-pills-2025-08-26">
(function(){
  // Safe local helpers (no reliance on global monthName)
  function getMonthNameArrays(){
    try {
      var useWin = Array.isArray(window.months) && window.months.length === 12;
      var full = useWin ? window.months.slice() : ["January","February","March","April","May","June","July","August","September","October","November","December"];
      // Validate: if all 12 entries are identical or non-strings, fallback to English
      var allSame = true;
      for (var i=1;i<12;i++){
        var a = (typeof full[i-1] === 'string') ? full[i-1].toLowerCase() : '';
        var b = (typeof full[i]   === 'string') ? full[i].toLowerCase()   : '';
        if (a !== b) { allSame = false; break; }
      }
      if (allSame) full = ["January","February","March","April","May","June","July","August","September","October","November","December"];
      var short = full.map(function(n){ return (n && n.slice) ? n.slice(0,3) : ""; });
      return { full: full, short: short };
    } catch(e){
      return {
        full: ["January","February","March","April","May","June","July","August","September","October","November","December"],
        short: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
      };
    }
  }
  function localFmt(n){
    try { return (window.formatNumber ? formatNumber(n) : new Intl.NumberFormat().format(Math.round(Number(n||0)))); }
    catch(_){ return String(n||0); }
  }
  function findHeaderIndexLocal(regexList){
    try {
      if (typeof window.findHeaderIndex === 'function') return window.findHeaderIndex(regexList);
      var ths = Array.from(document.querySelectorAll('table thead tr:last-child th'));
      if (!ths.length) ths = Array.from(document.querySelectorAll('table thead th'));
      for (var i=0;i<ths.length;i++){
        var t = (ths[i].textContent||'').toLowerCase();
        for (var r=0;r<regexList.length;r++){
          if (regexList[r].test(t)) return i;
        }
      }
      return ths.length ? (ths.length - 1) : -1;
    } catch(_) { return -1; }
  }
  function parseNumLocal(v){
    try { return (typeof window.parseNum === 'function') ? window.parseNum(v) : (function(x){
      if (x == null) return 0;
      var s = String(x);
      if (/^\s*\(.*\)\s*$/.test(s)) s = '-' + s.replace(/[()]/g, '');
      s = s.replace(/[^0-9.\-]/g, '');
      var n = parseFloat(s);
      return isNaN(n) ? 0 : n;
    })(v); } catch(_){ return 0; }
  }
  function getBody(){
    return document.getElementById('tableBody') || document.querySelector('table tbody');
  }
  // Find row for given 1..12 month number
  function getRowForMonthNumber(monthNumber){
    var tbody = getBody();
    if (!tbody) return null;
    var tr = tbody.querySelector('tr[data-month="'+monthNumber+'"]');
    if (tr) return tr;
    // Fallback: look for a '# / Month' cell pattern; try first cell equals monthNumber
    var rows = Array.from(tbody.querySelectorAll('tr'));
    for (var k=0;k<rows.length;k++){
      var td0 = rows[k].querySelector('td');
      if (!td0) continue;
      var n = parseInt((td0.textContent||'').replace(/\D+/g,''),10);
      if (n === monthNumber) return rows[k];
    }
    return null;
  }

  // Override renderer robustly; compute month name using data-month (1..12)
  window.renderMonthsMini = function renderMonthsMiniPatchedV2(){
    var wrap = document.getElementById('monthsMini');
    if (!wrap) return;

    // Force specific column indices based on your table structure (0-based)
    var idxTarget   = 5;  // 6th column (Target)
    var idxActual   = 8;  // 9th column (Bank Inflow) - CORRECTED
    var idxBalance  = 10; // 11th column (Balance) - read actual balance from table
    
    var names = getMonthNameArrays();

    // Detect next-needed marker if provided
    var nextIdx = (typeof window.nextNeededIndexByAccum === 'function') ? window.nextNeededIndexByAccum() : -1;

    var pills = [];
    
    // Get table body directly
    var tbody = document.getElementById('tableBody') || document.querySelector('table tbody');
    if (!tbody) return;
    var allRows = Array.from(tbody.querySelectorAll('tr'));
    
    for (var i=1;i<=12;i++){
      // Use direct row index (i-1 since rows are 0-based, months are 1-based)
      var tr = allRows[i-1];
      var tds = tr ? Array.from(tr.children) : [];
      
      // Read from specific column indices
      var target = parseNumLocal(tds[idxTarget] ? (tds[idxTarget].getAttribute('data-clean') || tds[idxTarget].textContent) : 0);
      var actual = parseNumLocal(tds[idxActual] ? (tds[idxActual].getAttribute('data-clean') || tds[idxActual].textContent) : 0);
      var balance = parseNumLocal(tds[idxBalance] ? (tds[idxBalance].getAttribute('data-clean') || tds[idxBalance].textContent) : 0);

      var cls = (balance>0) ? 'met' : (balance<0) ? 'unmet' : 'equal';
      if ((i-1) === nextIdx) cls += ' next';

      var fullName = names.full[i-1] || '';
      var shortName = names.short[i-1] || '';

      var accLabel;
      if (balance > 0) accLabel = 'Balance: ' + localFmt(balance);
      else if (balance < 0) accLabel = 'Balance: (' + localFmt(Math.abs(balance)) + ')';
      else accLabel = 'Balance: —';

      // Build pill content with custom colors - only show Bank Inflow if there's a value
      var pillContent = '<div class="month-pill '+cls+'" data-month="'+i+'" title="'+fullName+'">'+
        '<div style="color: navy; font-weight: bold;">'+shortName+'</div>'+
        '<div style="color: red;">'+ (target ? ('Target: '+localFmt(target)) : 'Target: —') +'</div>';
      
      // Only add Bank Inflow line if there's a value
      if (actual && actual > 0) {
        pillContent += '<div>Bank: '+localFmt(actual)+'</div>';
      }
      
      pillContent += '<div class="acc-var-label tiny" style="color: orange;">'+accLabel+'</div>'+
        '</div>';

      pills.push(pillContent);
    }
    wrap.innerHTML = pills.join('');

    if (window.__wireMonthPopovers && typeof window.__wireMonthPopovers === 'function'){
      try { window.__wireMonthPopovers(); } catch(_){}
    }
  };

  // Render now; any existing hooks that call renderMonthsMini will use this override
  try { window.renderMonthsMini(); } catch(_){}

})(); 
</script>
<!-- Patch: Month-Pill Share Header uses data-month (Aug 26, 2025) -->
<script id="patch-month-pop-header-2025-08-26">
(function(){
  if (window.__monthPopHeaderFix) return; 
  window.__monthPopHeaderFix = true;

  function hasValidMonths(arr){
    try{
      return Array.isArray(arr) && arr.length === 12 && arr.every(x => typeof x === 'string' && x.trim().length > 0);
    }catch(e){ return false; }
  }
  const EN_FULL = ["January","February","March","April","May","June","July","August","September","October","November","December"];

  function getNameSets(){
    const full = hasValidMonths(window.months) ? window.months.slice(0,12) : EN_FULL;
    const abbr = full.map(n => (n||"").slice(0,3));
    return { full, abbr };
  }

  function fixHeaderFor(pop){
    try{
      // Only adjust when the popover was opened from a month pill
      const anchor = window.__lastShareAnchor || document.activeElement;
      if (!anchor || !anchor.closest) return;
      const pill = anchor.closest('.month-pill') || anchor.closest('#monthsMini .month-pill');
      if (!pill) return;

      const dm = pill.getAttribute('data-month'); // 1..12
      const idx = Math.max(0, Math.min(11, (parseInt(dm,10) || 0) - 1));
      const { full, abbr } = getNameSets();

      const h4 = pop.querySelector('h4');
      if (h4){
        h4.textContent = abbr[idx] || "—";     // visible: abbreviated
        h4.setAttribute('title', full[idx] || "—"); // tooltip: full name
      }
    }catch(e){ /* swallow */ }
  }

  const mo = new MutationObserver((muts)=>{
    muts.forEach(m => {
      m.addedNodes && m.addedNodes.forEach(n => {
        if (n && n.nodeType === 1 && n.classList && n.classList.contains('month-pop')){
          fixHeaderFor(n);
        }
      });
    });
  });
  mo.observe(document.body, { childList:true, subtree:true });

  // Also patch any existing popovers if already present
  document.querySelectorAll('.month-pop').forEach(fixHeaderFor);
})();
</script>
<!-- Patch: Shrink / de-emphasize Next Needed badge (Aug 26, 2025) -->
<style id="patch-next-badge-shrink-2025-08-26">
  /* Smaller, subtler badge */
  .nextBadge{
    font-size: 12px !important;
    padding: 4px 8px !important;
    gap: 6px !important;
    box-shadow: none !important;
    opacity: 0.92;
    border-color: rgba(212,107,107,0.18) !important;
    background: #ffffff !important; /* flatter */
  }
  .nextBadge .label{ font-weight: 600 !important; }
  .nextBadge .pill,
  .nextBadge .amount,
  .nextBadge .days{ font-weight: 600 !important; }
  .nextBadge .smallDate{ font-size: 11px !important; opacity: 0.75; }

  /* Dark mode tweak */
  body.dark .nextBadge{
    background: #252222 !important;
    border-color: rgba(255,140,102,0.22) !important;
    box-shadow: none !important;
    opacity: 0.9;
  }
  body.dark .nextBadge .smallDate{ opacity: 0.7; }
</style>
<!-- Patch: Compact Next Targets toggle (Aug 26, 2025) -->
<style id="patch-ntw-toggle-compact-2025-08-26">
  .ntw-toggle{
    padding: 4px 10px !important;
    font-size: 12px !important;
    line-height: 1 !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06) !important;
    border-radius: 999px !important;
    background: rgba(255,255,255,0.70) !important;
  }
  .ntw-toggle .dot{ width: 6px !important; height: 6px !important; }
  body.dark .ntw-toggle{ background: rgba(24,24,24,0.80) !important; }
</style>
<!-- Patch: Shorter Next Targets chip (Aug 26, 2025, v2) -->
<style id="patch-ntw-toggle-shorter-2025-08-26">
  .ntw-toggle{
    height: 22px !important;
    min-height: 22px !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    padding-left: 10px !important;
    padding-right: 10px !important;
    font-size: 12px !important;
    line-height: 1 !important;
    gap: 6px !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.05) !important;
  }
  .ntw-toggle .dot{ width: 6px !important; height: 6px !important; }
</style>
<!-- Patch: Next Targets chip — strict short height (Aug 26, 2025, v3) -->
<style id="patch-ntw-toggle-shorter-2025-08-26-v3">
  /* Enforce a compact height on both button and generic element */
  button.ntw-toggle, .ntw-toggle{
    height: 18px !important;
    min-height: 18px !important;
    max-height: 18px !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    padding-left: 8px !important;
    padding-right: 8px !important;
    font-size: 11px !important;
    line-height: 1 !important;
    gap: 6px !important;
    border-width: 1px !important;
    box-sizing: border-box !important;
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
  }
  /* Normalize inner spans to avoid expanding height */
  .ntw-toggle span{ line-height: 1 !important; display: inline-block !important; }
  .ntw-toggle .dot{ width: 5px !important; height: 5px !important; }
  .ntw-toggle .caret{ line-height: 1 !important; }
  /* If something still inflates height, compress visually as a fallback */
  .ntw-toggle.ntw-compact-y { transform: scaleY(.82); transform-origin: left center; }
</style>
<!-- Patch: Fix extra horizontal space on Next Targets (Aug 26, 2025, v4) -->
<style id="patch-ntw-no-stretch-2025-08-26-v4">
  /* The wrapper was stretching children to the panel's width.
     Keep children at content width, especially the toggle button. */
  #nextTargetsWidget.ntw,
  #nextTargetsWidget { align-items: flex-start !important; }

  #nextTargetsWidget .ntw-toggle{
    align-self: flex-start !important;
    width: auto !important;
    max-width: max-content !important;
    white-space: nowrap !important;
  }
</style>
<script id="kpiCompactScript">
(function(){
  function getTxt(id){
    var el = document.getElementById(id);
    if(!el) return "—";
    var t = (el.textContent||"").trim();
    if(t) return t;
    var v = (el.value||"").trim();
    return v || "—";
  }
  function parseMoney(str){
    if(!str || str==="—") return null;
    var s = String(str)
      .replace(/AED/gi,'')
      .replace(/\s/g,'')
      .replace(/,/g,'');
    var neg = false;
    if(/^\(.*\)$/.test(s)){ neg = true; s = s.slice(1,-1); }
    // Leading minus variants
    s = s.replace(/^[-–−]/, function(){ neg = true; return ''; });
    // Strip any non-digit/decimal that's left
    s = s.replace(/[^0-9.]/g,'');
    var n = parseFloat(s);
    if(isNaN(n)) return null;
    return neg ? -n : n;
  }
  function fmtPos(n){ // always show as non-negative (no parentheses)
    if(n===null || typeof n==="undefined") return "0";
    var abs = Math.round(Math.max(0, n));
    return abs.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  function fmtAny(n){ // allow negatives with parentheses
    if(n===null || typeof n==="undefined") return "—";
    var sign = n < 0 ? -1 : 1;
    var abs = Math.round(Math.abs(n));
    var s = abs.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return sign < 0 ? "(" + s + ")" : s;
  }
  function setTxt(id, val){
    var el = document.getElementById(id);
    if(el) el.textContent = val;
  }
  // Small helper: set kpi-pos / kpi-neg classes based on numeric value
  function setKpiClass(id, num){
    var el = document.getElementById(id);
    if(!el) return;
    el.classList.remove('kpi-pos','kpi-neg');
    if(typeof num !== 'number' || isNaN(num)) return;
    if(num < 0) el.classList.add('kpi-neg');
    else if(num > 0) el.classList.add('kpi-pos');
  }
  function refreshKpis(){
    var targetRaw = getTxt("dashYearlyTarget");
    var ytdRaw    = getTxt("dashYtdAccomplished");
    var remRaw    = getTxt("dashRemaining");
    var obRaw     = getTxt("dashOpeningBalance");
    if(obRaw === "—") obRaw = getTxt("bfValue");
    if(obRaw === "—") obRaw = "0";

    var target = parseMoney(targetRaw);
    var ytd    = parseMoney(ytdRaw);
    var rem    = parseMoney(remRaw);
    var ob     = parseMoney(obRaw);

    // Enforce non-negative display for Adjusted Target and YTD
    if(target === null) target = 0;
    if(ytd === null) ytd = 0;
    if(target < 0) target = 0;
    if(ytd < 0) ytd = 0;

  setTxt("kpiVal_target", fmtPos(target));
    setTxt("kpiVal_ytd",    fmtPos(ytd));
    // Balance: sign-aware text & colour
  setTxt("kpiVal_rem", fmtAny(rem));
  try { setKpiClass("kpiVal_rem", rem); } catch(e){}
  setTxt("kpiVal_ob",     fmtAny(ob)); // OB can be ±; switch to fmtPos if you want only ≥0
  // colorize by sign where appropriate (skip balance which is forced red)
  try { setKpiClass("kpiVal_ob", ob); } catch(e){}
  // Add Avg. Mo. Target KPI (use absolute monthly targets so negative target entries don't make avg negative)
  var monthlyTargets = Array.isArray(window.monthlyTargets) ? window.monthlyTargets : [];
  var totalTarget = 0;
  for (var ti = 0; ti < 12; ti++) { totalTarget += Math.abs(Number(monthlyTargets[ti] || 0)); }
  var avgMonthly = totalTarget / 12;
  avgMonthly = Math.max(0, avgMonthly);
  // Debugging: show intermediate values in console to aid troubleshooting
  try { console.debug('[KPIs] totalTarget:', totalTarget, 'avgMonthly:', avgMonthly); } catch(e){}
  setTxt("kpiVal_avgMonthly", fmtPos(avgMonthly));
  try { setKpiClass("kpiVal_avgMonthly", avgMonthly); } catch(e){}
    // Add Deviation KPI
    var actuals = window.actuals || window.monthlyInflows || window.monthlyBankInflow || [];
    var lastMonthIndex = -1;
    for (var i = 0; i < actuals.length; i++) {
      if (actuals[i] && actuals[i] != 0) {
        lastMonthIndex = i;
      }
    }
    var monthsPassed = lastMonthIndex >= 0 ? lastMonthIndex + 1 : 0;
    var requiredYTD = target ? (target / 12) * monthsPassed : 0;
    var deviation = ytd - requiredYTD;
    setTxt("kpiVal_deviation", fmtAny(deviation));
  try { setKpiClass("kpiVal_deviation", deviation); } catch(e){}

  // Compute Avg. Mo. Inflow first (average of absolute monthly inflows up to last inflow month)
    var totalActual = 0;
    if (Array.isArray(actuals) && lastMonthIndex >= 0) {
      for (var j = 0; j <= lastMonthIndex; j++) {
        totalActual += Math.abs(Number(actuals[j] || 0));
      }
    }
    var avgActualMonthly = (monthsPassed > 0) ? (totalActual / monthsPassed) : 0;
    avgActualMonthly = Math.max(0, avgActualMonthly);
    try { console.debug('[KPIs] totalActual:', totalActual, 'monthsPassed:', monthsPassed, 'avgActualMonthly:', avgActualMonthly); } catch(e){}
    // Forecasted Year-End: linear projection based on YTD and months passed
    var forecast = 0;
    if (monthsPassed > 0) {
      forecast = Math.round((ytd / monthsPassed) * 12);
    } else {
      forecast = Math.round(target || 0);
    }
    try { console.debug('[KPIs] forecast (linear):', forecast, 'ytd:', ytd, 'monthsPassed:', monthsPassed); } catch(e){}
    setTxt("kpiVal_forecast", fmtPos(Math.max(0, forecast)));
  try { setKpiClass("kpiVal_forecast", forecast); } catch(e){}
  // Mo. Variance KPI (avgActual - avgTarget). Negative when actual < target.
    var monthlyVariance = 0;
    if (typeof avgActualMonthly !== 'undefined' && typeof avgMonthly !== 'undefined') {
      // ensure numeric
      var aAct = Number(avgActualMonthly) || 0;
      var aTgt = Number(avgMonthly) || 0;
      monthlyVariance = aAct - aTgt;
      monthlyVariance = Math.round(monthlyVariance);
      try { console.debug('[KPIs] avgActualMonthly:', aAct, 'avgMonthly:', aTgt, 'monthlyVariance:', monthlyVariance); } catch(e){}
    } else {
      // fallback to last month diff if averages are not available
      if (lastMonthIndex >= 0) {
        var targets = window.monthlyTargets || [];
        monthlyVariance = (actuals[lastMonthIndex] || 0) - (targets[lastMonthIndex] || 0);
        monthlyVariance = Math.round(monthlyVariance);
      }
    }
    setTxt("kpiVal_monthlyVariance", fmtAny(monthlyVariance));
  try { setKpiClass("kpiVal_monthlyVariance", monthlyVariance); } catch(e){}
    // Set Avg Actual KPI text
    setTxt("kpiVal_avgActualMonthly", fmtPos(avgActualMonthly));
  try { setKpiClass("kpiVal_avgActualMonthly", avgActualMonthly); } catch(e){}
  // Add Monthly Needed Inflow KPI (amount needed per month going forward to reach target)
  var currentMonthIndex = new Date().getMonth();
  var remainingMonths = Math.max(1, 12 - currentMonthIndex); // at least 1 month to avoid division by zero
  var remainingTarget = Math.max(0, target - ytd);
  var monthlyNeeded = remainingTarget / remainingMonths;
  monthlyNeeded = Math.max(0, Math.round(monthlyNeeded));
  try { console.debug('[KPIs] remainingTarget:', remainingTarget, 'remainingMonths:', remainingMonths, 'monthlyNeeded:', monthlyNeeded); } catch(e){}
  setTxt("kpiVal_monthlyNeeded", fmtPos(monthlyNeeded));
  try { setKpiClass("kpiVal_monthlyNeeded", monthlyNeeded); } catch(e){}
  // Update the dynamic label to show remaining months
  
  var labelEl = document.getElementById("kpiLabel_monthlyNeeded");
  if (labelEl) {
    var mSpan = document.getElementById("kpiRemainingMonths");
    if (!mSpan) {
      labelEl.innerHTML = "📊 Mo. Needed Inflow To End of the Year — "
        + "<span id=\"kpiRemainingMonths\" style=\"font-weight:600; color: red;\">" + remainingMonths + " Months</span>"
        + " - remains <span id=\"cheqMirrorSlot\" style=\"margin-left:6px;\"></span>";
    } else {
      mSpan.textContent = remainingMonths + " Months";
    }
    (function(){
      try {
        var slot = document.getElementById("cheqMirrorSlot") || labelEl;
        if (slot && !document.getElementById("cheqDueBadge")){
          var badge = document.createElement("span");
          badge.id = "cheqDueBadge";
          badge.className = "cheq-duebadge";
          badge.style.display = "none";
          badge.title = "Right‑click to delete reminder";
          slot.appendChild(badge);
          badge.addEventListener("contextmenu", function(e){ e.preventDefault(); CHEQ.deleteAction(); });
        }
        if (window.CHEQ && CHEQ.refreshBadge) CHEQ.refreshBadge();
      } catch(e){}
    })();
  }

  }
  document.addEventListener("DOMContentLoaded", refreshKpis);
  setTimeout(refreshKpis, 400);
  setInterval(refreshKpis, 3000);
})();
</script>
<script id="nyt-special-script">
(function(){
  function markNextYearTitle(root){
    const nodes = root ? (root.querySelectorAll ? root.querySelectorAll('*') : []) : document.querySelectorAll('*');
    for (const el of nodes){
      if(!el || !el.textContent) continue;
      const t = el.textContent.trim();
      if (/^[-–]\s*Next Year Target/i.test(t)){
        el.classList.add('nyt-special');
        return true;
      }
    }
    return false;
  }
  // initial try
  if(!markNextYearTitle()){
    // Observe for dynamic updates
    const obs = new MutationObserver((muts)=>{
      for (const m of muts){
        for (const n of m.addedNodes || []){
          if (n.nodeType === 1 && markNextYearTitle(n)) { obs.disconnect(); return; }
        }
      }
    });
    obs.observe(document.body, {childList:true, subtree:true});
  }
})();
</script>
<script>
(function(){
  const LABELS = [
    "Adjusted Target",
    "YTD Inflow",
    "Opening Balance",
    "Balance"
  ];
  const ALT_LABELS = new Map([
    ["YTD Inflow", ["YTD Actual Inflow","YTD Bank Inflow","Y T D Inflow"]]
  ]);

  function labelIn(el, label){
    const t = (el.innerText || "").toLowerCase();
    if (t.includes(label.toLowerCase())) return true;
    const alts = ALT_LABELS.get(label) || [];
    return alts.some(a => t.includes(a.toLowerCase()));
  }

  function textHasAll(container, labels){
    const t = (container.innerText || "").toLowerCase();
    return labels.every(l => t.includes(l.toLowerCase()) || (ALT_LABELS.get(l)||[]).some(a => t.includes(a.toLowerCase())));
  }

  function findSummaryContainer(){
    const likely = Array.from(document.querySelectorAll('section,div,main,article,.summary,.kpi,.card,.kpi-grid,#mainKPIs,#kpisRoot,#summaryCard,#kpiSummaryCard'));
    if (!likely.includes(document.body)) likely.push(document.body);
    let best = null;
    for (const el of likely){
      if (!el || el === document) continue;
      if (textHasAll(el, ["Adjusted Target","YTD Inflow","Opening Balance","Balance"])) {
        if (!best) { best = el; continue; }
        if (el.querySelectorAll('*').length < best.querySelectorAll('*').length) best = el;
      }
    }
    return best || null;
  }

  function makeEmptyWindow(tile){
    if (!tile) return;
    // Avoid blanking our KPI strip or its ancestors/descendants.
    try {
      var kpiEl = document.getElementById('kpiCompactStrip');
      if (kpiEl) {
        // if tile is kpiCompactStrip or contains it or is inside it, skip.
        if (tile === kpiEl || tile.contains(kpiEl) || kpiEl.contains(tile)) return;
      }
    } catch(e){}
    // Avoid re-running
    if (tile.classList && tile.classList.contains('empty-window')) return;

    // If this element has an inline background or border, keep it;
    // otherwise, we'll add our minimal styling via class.
    tile.classList && tile.classList.add('empty-window');
    // Clear content but keep the container in layout
    while (tile.firstChild) tile.removeChild(tile.firstChild);
    const spacer = document.createElement('div');
    spacer.className = 'placeholder-spacer';
    tile.appendChild(spacer);
  }

  function blankTileForLabel(container, label){
    const all = Array.from(container.querySelectorAll('*')).filter(n => labelIn(n, label));
    if (!all.length) return false;

    const OTHER_LABELS = LABELS.filter(l => l !== label);
    for (const node of all){
      let cur = node;
      while (cur && cur !== container && cur !== document.body){
        const text = (cur.innerText || "").toLowerCase();
        const hasOther = OTHER_LABELS.some(l => text.includes(l.toLowerCase()) || (ALT_LABELS.get(l)||[]).some(a => text.includes(a.toLowerCase())));
        if (!hasOther){
          makeEmptyWindow(cur);
          return true;
        }
        cur = cur.parentElement;
      }
    }
    // Fallback: blank the original node
    makeEmptyWindow(all[0]);
    return true;
  }

  function run(){
    const container = findSummaryContainer();
    if (!container) return;
    LABELS.forEach(label => blankTileForLabel(container, label));
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  // Reuse a minimal container finder: we want the block that originally held the four KPIs
  function findSummaryContainer(){
    const candidates = Array.from(document.querySelectorAll(
      'section,div,main,article,.summary,.kpi,.card,.kpi-grid,#mainKPIs,#kpisRoot,#summaryCard,#kpiSummaryCard'
    ));
    if (!candidates.includes(document.body)) candidates.push(document.body);
    // Choose the first candidate that currently has at least 4 empty windows
    for (const el of candidates){
      if (el.querySelectorAll('.empty-window').length >= 4) return el;
    }
    return null;
  }

  function run(){
    const container = findSummaryContainer() || document;
    const tiles = Array.from(container.querySelectorAll('.empty-window'));
    if (!tiles.length) return;

    // Desired labels left-to-right
    const labels = ["Yearly Target","Opening Balance","Actual Inflow","Remaining"];

    tiles.slice(0,4).forEach((tile, i)=>{
      let lab = tile.querySelector('.ew-label');
      if (!lab){
        lab = document.createElement('div');
        lab.className = 'ew-label';
        tile.appendChild(lab);
      }
      lab.textContent = (i+1) + ") " + labels[i];
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  function applyLabelsNoNumbers(){
    const container = document.querySelector('.empty-window')?.parentElement || document;
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    if (!tiles.length) return;
    const labels = ["Yearly Target","Opening Balance","Actual Inflow","Remaining"];
    tiles.slice(0,4).forEach((tile, i)=>{
      let lab = tile.querySelector('.ew-label');
      if (!lab){
        lab = document.createElement('div');
        lab.className = 'ew-label';
        tile.appendChild(lab);
      }
      lab.textContent = labels[i] || "";
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyLabelsNoNumbers);
  } else {
    applyLabelsNoNumbers();
  }
})();
</script>
<script>
(function(){
  // Utility: parse a currency/number string to float (supports (), commas, AED prefix, and minus)
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    // detect parentheses as negative
    const neg = /\(([^)]+)\)/.test(txt);
    // remove currency and anything non-digit/period/minus
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }

  // Format as AED with thousands
  function fmtAED(n){
    if (n === null || n === undefined) return "AED 0";
    try {
      const sign = n < 0 ? '-' : '';
      const abs = Math.abs(n);
      const parts = abs.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return `AED ${sign}${parts}`;
    } catch(e){
      return `AED ${n}`;
    }
  }

  function findMainTable(){
    // Heuristics: look for the largest table holding financial rows
    const tables = Array.from(document.querySelectorAll('table'));
    if (!tables.length) return null;
    // Prefer table that contains the word "Brought Forward"
    let bfTable = tables.find(t => /brought\s*forward/i.test(t.innerText||''));
    if (bfTable) return bfTable;
    // Otherwise, pick the table with the most rows
    tables.sort((a,b)=> (b.querySelectorAll('tr').length||0) - (a.querySelectorAll('tr').length||0));
    return tables[0] || null;
  }

  function headerMap(table){
    const map = new Map();
    const thead = table.querySelector('thead');
    const headerRow = thead ? thead.querySelector('tr') : table.querySelector('tr');
    if (!headerRow) return map;
    const ths = Array.from(headerRow.children);
    ths.forEach((th, idx)=>{
      const name = (th.innerText||th.textContent||'').trim().toLowerCase();
      map.set(idx, name);
    });
    return map;
  }

  function extractBroughtForwardAmount(){
    const table = findMainTable();
    if (!table) return null;
    const hmap = headerMap(table);

    // Find BF row (robust to variants)
    const rows = Array.from(table.querySelectorAll('tr'));
    let bfRow = rows.find(tr => /b\.?\s*f\.?|brought\s*forward|brought\s*fwd|opening\s*balance/i.test(tr.innerText||''));
    if (!bfRow) return null;

    // Strategy: prefer specific columns if headers recognized
    const cells = Array.from(bfRow.children);
    let candidates = [];

    cells.forEach((td, idx)=>{
      const txt = (td.innerText||'').trim();
      const val = parseAmount(txt);
      if (val !== null){
        const hname = (hmap.get(idx)||'');
        candidates.append ? candidates.append({idx, hname, val}) : candidates.push({idx, hname, val});
      }
    });

    if (!candidates.length) {
      // As a fallback, search inline numbers within the row text
      const rowTxt = (bfRow.innerText||'').trim();
      const m = rowTxt.match(/-?\(?\d[\d,\.]*\)?/g);
      if (m && m.length){
        // parse last match as most likely total
        const val = parseAmount(m[m.length-1]);
        return val;
      }
      return null;
    }

    // Scoring: prefer "opening balance", then "brought forward", then "balance", then "bank inflow", then "target", then "expected"
    const pref = ['opening balance','brought forward','balance','bank inflow','target','expected'];
    candidates.forEach(c=>{
      c.score = 1000 - (pref.findIndex(p => c.hname.includes(p)) + 1)*100; // lower idx => higher score
      if (!c.hname) c.score = -1;
    });
    candidates.sort((a,b)=> b.score - a.score);

    // If all scores are -1 (no header names), choose the largest absolute value
    if (candidates[0].score === -1){
      candidates.sort((a,b)=> Math.abs(b.val) - Math.abs(a.val));
    }

    return candidates[0].val;
  }

  function setOpeningBalanceValue(){
    // Find the tile labeled "Opening Balance"
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let openingTile = null;
    for (const t of tiles){
      const label = t.querySelector('.ew-label');
      if (label && /opening\s*balance/i.test(label.textContent||'')){
        openingTile = t;
        break;
      }
    }
    if (!openingTile) return;

    const amount = extractBroughtForwardAmount();
    // Create/update value element
    let valEl = openingTile.querySelector('.ew-value');
    if (!valEl){
      valEl = document.createElement('div');
      valEl.className = 'ew-value';
      openingTile.appendChild(valEl);
    }
    valEl.textContent = fmtAED(amount||0);
  }

  function observeTable(){
    const table = findMainTable();
    if (!table) return;
    const obs = new MutationObserver(()=>{
      try { setOpeningBalanceValue(); } catch(e){}
    });
    obs.observe(table, {childList: true, subtree: true, characterData: true});
  }

  function run(){
    setOpeningBalanceValue();
    observeTable();
    window.addEventListener('resize', setOpeningBalanceValue);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  // Helpers (kept local to this script)
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    const neg = /\(([^)]+)\)/.test(txt);
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }
  function fmtAED(n){
    if (n === null || n === undefined) return "AED 0";
    try {
      const sign = n < 0 ? '-' : '';
      const abs = Math.abs(n);
      const parts = abs.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return `AED ${sign}${parts}`;
    } catch(e){
      return `AED ${n}`;
    }
  }
  function findMainTable(){
    const tables = Array.from(document.querySelectorAll('table'));
    if (!tables.length) return null;
    // Prefer the one that already held Brought Forward (if present)
    let bfTable = tables.find(t => /brought\s*forward|b\.?\s*f\.?|opening\s*balance/i.test(t.innerText||''));
    if (bfTable) return bfTable;
    tables.sort((a,b)=> (b.querySelectorAll('tr').length||0) - (a.querySelectorAll('tr').length||0));
    return tables[0] || null;
  }
  function extractFinalBalance(){
    const table = findMainTable();
    if (!table) return null;
    let rows = Array.from(table.querySelectorAll('tbody tr'));
    if (!rows.length) rows = Array.from(table.querySelectorAll('tr'));
    // keep rows that have td
    rows = rows.filter(r => r.querySelectorAll('td').length > 0);
    if (!rows.length) return null;
    // pick last non-empty row
    let row = null;
    for (let i = rows.length - 1; i >= 0; i--){
      const txt = (rows[i].innerText || '').trim();
      if (txt) { row = rows[i]; break; }
    }
    if (!row) row = rows[rows.length - 1];
    const tds = Array.from(row.querySelectorAll('td'));
    if (!tds.length) return null;
    // take last column first
    let val = parseAmount(tds[tds.length - 1].innerText || '');
    if (val === null){
      // fallback: scan from rightmost cell to left for first parseable number
      for (let i = tds.length - 1; i >= 0; i--){
        val = parseAmount(tds[i].innerText || '');
        if (val !== null) break;
      }
    }
    return val;
  }
  function setRemainingValue(){
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let remainingTile = null;
    for (const t of tiles){
      const label = t.querySelector('.ew-label');
      if (label && /remaining/i.test(label.textContent||'')){
        remainingTile = t; break;
      }
    }
    if (!remainingTile) return;
    const amount = extractFinalBalance();
    let valEl = remainingTile.querySelector('.ew-value');
    if (!valEl){
      valEl = document.createElement('div');
      valEl.className = 'ew-value';
      remainingTile.appendChild(valEl);
    }
    valEl.textContent = fmtAED(amount||0);
  }
  function observeTable(){
    const table = findMainTable();
    if (!table) return;
    const obs = new MutationObserver(()=>{
      try { setRemainingValue(); } catch(e){}
    });
    obs.observe(table, {childList: true, subtree: true, characterData: true});
  }
  function run(){
    setRemainingValue();
    observeTable();
    window.addEventListener('resize', setRemainingValue);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  const BANK_COL_INDEX = 8; // 0-based index => 9th column
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    const neg = /\(([^)]+)\)/.test(txt);
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }
  function fmtAED(n){
    if (n === null || n === undefined) return "AED 0";
    try {
      const sign = n < 0 ? '-' : '';
      const abs = Math.abs(n);
      const parts = abs.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return `AED ${sign}${parts}`;
    } catch(e){
      return `AED ${n}`;
    }
  }
  function findMainTable(){
    const tables = Array.from(document.querySelectorAll('table'));
    if (!tables.length) return null;
    // Prefer a table that mentions common finance keywords
    let t = tables.find(t => /brought\s*forward|b\.?\s*f\.?|opening\s*balance|target|variance|bank\s*inflow/i.test(t.innerText||''));
    if (t) return t;
    tables.sort((a,b)=> (b.querySelectorAll('tr').length||0) - (a.querySelectorAll('tr').length||0));
    return tables[0] || null;
  }
  function extractTotalBankInflowCol9(){
    const table = findMainTable();
    if (!table) return null;
    let rows = Array.from(table.querySelectorAll('tbody tr'));
    if (!rows.length) rows = Array.from(table.querySelectorAll('tr'));
    let sum = 0, any=false;
    for (const r of rows){
      // skip header-like rows
      if (r.querySelector('th')) continue;
      const tds = Array.from(r.querySelectorAll('td'));
      if (!tds.length) continue;
      // skip BF / Opening / Total rows
      const txt = (r.innerText||'').toLowerCase();
      if (/b\.?\s*f\.?|brought\s*forward|opening\s*balance|total(?![^\w])/i.test(txt)) continue;
      if (tds.length <= BANK_COL_INDEX) continue;
      const val = parseAmount(tds[BANK_COL_INDEX].innerText||'');
      if (val !== null){ sum += val; any = true; }
    }
    return any ? sum : null;
  }
  function setBankInflowTileCol9(){
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let bankTile = null;
    for (const t of tiles){
      const label = t.querySelector('.ew-label');
      if (label && /bank\s*inflow/i.test(label.textContent||'')){
        bankTile = t; break;
      }
    }
    if (!bankTile) return;
    const total = extractTotalBankInflowCol9();
    let valEl = bankTile.querySelector('.ew-value');
    if (!valEl){
      valEl = document.createElement('div');
      valEl.className = 'ew-value';
      bankTile.appendChild(valEl);
    }
    valEl.textContent = fmtAED(total||0);
  }
  function observeTable(){
    const table = findMainTable();
    if (!table) return;
    const obs = new MutationObserver(()=>{
      try { setBankInflowTileCol9(); } catch(e){}
    });
    obs.observe(table, {childList: true, subtree: true, characterData: true});
  }
  function run(){
    setBankInflowTileCol9();
    observeTable();
    window.addEventListener('resize', setBankInflowTileCol9);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    const neg = /\(([^)]+)\)/.test(txt);
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }
  function fmtAED(n){
    if (n === null || n === undefined) return "AED 0";
    try {
      const sign = n < 0 ? '-' : '';
      const abs = Math.abs(n);
      const parts = abs.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return `AED ${sign}${parts}`;
    } catch(e){
      return `AED ${n}`;
    }
  }
  function findMainTable(){
    const tables = Array.from(document.querySelectorAll('table'));
    if (!tables.length) return null;
    // Prefer a table that mentions common finance keywords
    let t = tables.find(t => /brought\s*forward|b\.?\s*f\.?|opening\s*balance|target|variance|bank\s*inflow/i.test(t.innerText||''));
    if (t) return t;
    tables.sort((a,b)=> (b.querySelectorAll('tr').length||0) - (a.querySelectorAll('tr').length||0));
    return tables[0] || null;
  }
  function headerMap(table){
    const map = new Map();
    const thead = table.querySelector('thead');
    const headerRow = thead ? thead.querySelector('tr') : table.querySelector('tr');
    if (!headerRow) return map;
    const ths = Array.from(headerRow.children);
    ths.forEach((th, idx)=>{
      const name = (th.innerText||th.textContent||'').trim().toLowerCase();
      map.set(idx, name);
    });
    return map;
  }
  function extractBroughtForwardAmount(){
    const table = findMainTable();
    if (!table) return 0;
    const hmap = headerMap(table);
    const rows = Array.from(table.querySelectorAll('tr'));
    let bfRow = rows.find(tr => /b\.?\s*f\.?|brought\s*forward|brought\s*fwd|opening\s*balance/i.test(tr.innerText||''));
    if (!bfRow) return 0;
    const cells = Array.from(bfRow.children);
    let candidates = [];
    cells.forEach((td, idx)=>{
      const txt = (td.innerText||'').trim();
      const val = parseAmount(txt);
      if (val !== null){
        const hname = (hmap.get(idx)||'');
        candidates.push({idx, hname, val});
      }
    });
    if (!candidates.length) return 0;
    const pref = ['opening balance','brought forward','balance','bank inflow','target','expected'];
    candidates.forEach(c=>{
      c.score = 1000 - (pref.findIndex(p => c.hname.includes(p)) + 1)*100;
      if (!c.hname) c.score = -1;
    });
    candidates.sort((a,b)=> b.score - a.score);
    if (candidates[0].score === -1){
      candidates.sort((a,b)=> Math.abs(b.val) - Math.abs(a.val));
    }
    return candidates[0].val || 0;
  }
  function findTargetColIndex(table){
    const hmap = headerMap(table);
    // Prefer header that includes 'target'
    let best = null;
    for (const [idx, name] of hmap.entries()){
      if (name && name.includes('target')) { best = idx; break; }
    }
    // Fallback: column 5 (1-based 6th) — common in your layout
    if (best === null) best = 5;
    return best;
  }
  function extractTotalTarget(){
    const table = findMainTable();
    if (!table) return 0;
    const col = findTargetColIndex(table);
    let rows = Array.from(table.querySelectorAll('tbody tr'));
    if (!rows.length) rows = Array.from(table.querySelectorAll('tr'));
    let sum = 0;
    for (const r of rows){
      if (!r.querySelectorAll('td').length) continue;
      const txt = (r.innerText||'').toLowerCase();
      if (/b\.?\s*f\.?|brought\s*forward|opening\s*balance|total(?![^\w])/i.test(txt)) continue;
      const tds = Array.from(r.querySelectorAll('td'));
      if (tds.length <= col) continue;
      const v = parseAmount(tds[col].innerText||'');
      if (v !== null) sum += v;
    }
    return sum;
  }
  function setYearlyTargetTile(){
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let yearlyTile = null;
    for (const t of tiles){
      const label = t.querySelector('.ew-label');
      if (label && /yearly\s*target/i.test(label.textContent||'')){
        yearlyTile = t; break;
      }
    }
    if (!yearlyTile) return;
    const bf = extractBroughtForwardAmount() || 0;
    const sumTarget = extractTotalTarget() || 0;
    const total = bf + sumTarget;
    let valEl = yearlyTile.querySelector('.ew-value');
    if (!valEl){
      valEl = document.createElement('div');
      valEl.className = 'ew-value';
      yearlyTile.appendChild(valEl);
    }
    valEl.textContent = fmtAED(total);
  }
  function observeTable(){
    const table = findMainTable();
    if (!table) return;
    const obs = new MutationObserver(()=>{
      try { setYearlyTargetTile(); } catch(e){}
    });
    obs.observe(table, {childList: true, subtree: true, characterData: true});
  }
  function run(){
    setYearlyTargetTile();
    observeTable();
    window.addEventListener('resize', setYearlyTargetTile);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    const neg = /\(([^)]+)\)/.test(txt);
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }
  function fmtAED(n){
    if (n === null || n === undefined) return "AED 0";
    try {
      const sign = n < 0 ? '-' : '';
      const abs = Math.abs(n);
      const parts = abs.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      return `AED ${sign}${parts}`;
    } catch(e){
      return `AED ${n}`;
    }
  }
  function findMainTable(){
    const tables = Array.from(document.querySelectorAll('table'));
    if (!tables.length) return null;
    // Prefer table that mentions finance keywords
    let t = tables.find(t => /brought\s*forward|b\.?\s*f\.?|opening\s*balance|target|variance|bank\s*inflow/i.test(t.innerText||''));
    if (t) return t;
    tables.sort((a,b)=> (b.querySelectorAll('tr').length||0) - (a.querySelectorAll('tr').length||0));
    return tables[0] || null;
  }
  function headerMap(table){
    const map = new Map();
    const thead = table.querySelector('thead');
    const headerRow = thead ? thead.querySelector('tr') : table.querySelector('tr');
    if (!headerRow) return map;
    Array.from(headerRow.children).forEach((th, idx)=>{
      const name = (th.innerText||th.textContent||'').trim().toLowerCase();
      map.set(idx, name);
    });
    return map;
  }
  function extractBroughtForwardAmount(){
    const table = findMainTable();
    if (!table) return 0;
    const hmap = headerMap(table);
    const rows = Array.from(table.querySelectorAll('tr'));
    let bfRow = rows.find(tr => /b\.?\s*f\.?|brought\s*forward|brought\s*fwd|opening\s*balance/i.test(tr.innerText||''));
    if (!bfRow) return 0;
    const cells = Array.from(bfRow.children);
    const candidates = [];
    cells.forEach((td, idx)=>{
      const txt = (td.innerText||'').trim();
      const val = parseAmount(txt);
      if (val !== null){
        const hname = (hmap.get(idx)||'');
        candidates.push({idx, hname, val});
      }
    });
    if (!candidates.length) return 0;
    const pref = ['opening balance','brought forward','balance','bank inflow','target','expected'];
    candidates.forEach(c=>{
      c.score = 1000 - (pref.findIndex(p => c.hname.includes(p)) + 1)*100;
      if (!c.hname) c.score = -1;
    });
    candidates.sort((a,b)=> b.score - a.score);
    if (candidates[0].score === -1){
      candidates.sort((a,b)=> Math.abs(b.val) - Math.abs(a.val));
    }
    return candidates[0].val || 0;
  }
  function findTargetColIndex(table){
    const hmap = headerMap(table);
    for (const [idx, name] of hmap.entries()){
      if (name && name.includes('target')) return idx;
    }
    // Fallback to 6th column (0-based 5) used in your layout
    return 5;
  }
  function extractTotalTarget(){
    const table = findMainTable();
    if (!table) return 0;
    const col = findTargetColIndex(table);
    let rows = Array.from(table.querySelectorAll('tbody tr'));
    if (!rows.length) rows = Array.from(table.querySelectorAll('tr'));
    let sum = 0;
    for (const r of rows){
      if (!r.querySelectorAll('td').length) continue;
      const txt = (r.innerText||'').toLowerCase();
      if (/b\.?\s*f\.?|brought\s*forward|opening\s*balance|total(?![^\w])/i.test(txt)) continue;
      const tds = Array.from(r.querySelectorAll('td'));
      if (tds.length <= col) continue;
      const v = parseAmount(tds[col].innerText||'');
      if (v !== null) sum += v;
    }
    return sum;
  }
  function setYearlyTargetMinusBF(){
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let yearlyTile = null;
    for (const t of tiles){
      const label = t.querySelector('.ew-label');
      if (label && /yearly\s*target/i.test(label.textContent||'')){
        yearlyTile = t; break;
      }
    }
    if (!yearlyTile) return;
    const bf = extractBroughtForwardAmount() || 0;
    const sumTarget = extractTotalTarget() || 0;
    const total = sumTarget - bf; // <-- minus BF
    let valEl = yearlyTile.querySelector('.ew-value');
    if (!valEl){
      valEl = document.createElement('div');
      valEl.className = 'ew-value';
      yearlyTile.appendChild(valEl);
    }
    valEl.textContent = fmtAED(total);
  }
  function observeTable(){
    const table = findMainTable();
    if (!table) return;
    const obs = new MutationObserver(()=>{
      try { setYearlyTargetMinusBF(); } catch(e){}
    });
    obs.observe(table, {childList: true, subtree: true, characterData: true});
  }
  function run(){
    setYearlyTargetMinusBF();
    observeTable();
    window.addEventListener('resize', setYearlyTargetMinusBF);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script>
(function(){
  function parseAmount(txt){
    if (!txt) return null;
    txt = (txt + "").replace(/\u00A0/g, ' ').trim();
    const neg = /\(([^)]+)\)/.test(txt);
    let cleaned = txt.replace(/[^\d\.\-]/g, '');
    if (!cleaned) return null;
    let val = parseFloat(cleaned);
    if (isNaN(val)) return null;
    return neg ? -Math.abs(val) : val;
  }
  function applyRemainingColor(){
    // Find Remaining tile
    const tiles = Array.from(document.querySelectorAll('.empty-window'));
    let remainingTile = null;
    for (const t of tiles){
      const lab = t.querySelector('.ew-label');
      if (lab && /remaining/i.test(lab.textContent||'')){ remainingTile = t; break; }
    }
    if (!remainingTile) return;
    const valEl = remainingTile.querySelector('.ew-value');
    if (!valEl) return;
    const val = parseAmount(valEl.textContent || '');
    remainingTile.classList.remove('rem-pos','rem-neg');
    if (val === null || val === 0) return; // neutral
    if (val > 0){ remainingTile.classList.add('rem-pos'); }
    else { remainingTile.classList.add('rem-neg'); }
  }
  function observeChanges(){
    // Re-apply when the remaining tile value changes
    const target = document.body;
    const obs = new MutationObserver(()=>{
      try { applyRemainingColor(); } catch(e){}
    });
    obs.observe(target, {subtree: true, childList: true, characterData: true});
    window.addEventListener('resize', applyRemainingColor);
  }
  function run(){
    applyRemainingColor();
    observeChanges();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<div aria-label="Next Year Targets" id="nextYearTargetCard" role="complementary">
<div class="mini-header" id="nytHeader">
<h4>Next Year Targets</h4>
<span class="caret">▾</span>
</div>
<div class="content" id="nytContent">
<ul id="nytList"><li class="tiny muted">Loading next-year targets…</li></ul>
</div>
</div>
<div aria-label="Next Year Targets" id="nextTargetCard" role="complementary">
<div class="mini-header" id="ntHeader">
<h4>Next Year Targets</h4>
<span class="caret">▾</span>
</div>
<div class="content" id="ntContent">
<ul id="ntList"><li class="tiny muted">Loading next-year targets…</li></ul>
</div>
</div>
<script>
(function(){
  if (window.__SCENARIO_V2__) return; window.__SCENARIO_V2__ = true;

  const el = {
    btn: document.getElementById('btnScenarioPlanning'),
    modal: document.getElementById('scenarioModal'),
    close: document.getElementById('scv2Close'),
    apply: document.getElementById('scv2Apply'),
    reset: document.getElementById('scv2Reset'),
    months: document.getElementById('scv2Months'),
    monthsVal: document.getElementById('scv2MonthsVal'),
    growth: document.getElementById('scv2Growth'),
    inc: document.getElementById('scv2Inc'),
    includeCur: document.getElementById('scv2IncludeCurrent'),
    baseline: () => (document.querySelector('input[name="scv2Baseline"]:checked')?.value || 'expected'),
    yTarget: document.getElementById('scv2YearlyTarget'),
    dist: document.getElementById('scv2Dist'),
    shockMonth: document.getElementById('scv2ShockMonth'),
    shockAED: document.getElementById('scv2ShockAED'),
    ye: document.getElementById('scv2YE'),
    completion: document.getElementById('scv2Completion'),
    gap: document.getElementById('scv2Gap'),
    canvas: document.getElementById('scv2Chart')
  };

  function rmDisplay(x){ try{x.style.removeProperty('display');}catch(e){} }
  function show(){ rmDisplay(el.modal); el.modal.classList.add('visible'); run(); }
  function hide(){ el.modal.classList.remove('visible'); }
  if (el.btn) el.btn.addEventListener('click', show);
  el.close.addEventListener('click', hide);
  el.modal.addEventListener('click', (e)=>{ if (e.target===el.modal) hide(); });
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && el.modal.classList.contains('visible')) hide(); });

  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function toNum(v){ if(v==null) return 0; let s=(''+v).replace(/[^0-9\-\.,]/g,'').replace(/,/g,''); const n=parseFloat(s); return isNaN(n)?0:n; }
  function fmt(n){ try{ return new Intl.NumberFormat(undefined,{maximumFractionDigits:0}).format(n); }catch(e){ return Math.round(n).toString(); } }
  function l3mAvg(arr, idx){
    let sum=0,c=0;
    for (let k=idx-1; k>=0 && c<3; k--){
      if ((+arr[k]||0)>0){ sum += (+arr[k]||0); c++; }
    }
    return c? sum/c : 0;
  }

  function getArrays(){
    const months = (window.months||MONTHS).slice(0,12);
    const targets = (Array.isArray(window.monthlyTargets) ? window.monthlyTargets.slice(0,12) : new Array(12).fill(0));
    const actuals = (Array.isArray(window.actuals) ? window.actuals.slice(0,12) : new Array(12).fill(0));
    const expected = (Array.isArray(window.expected) ? window.expected.slice(0,12) : new Array(12).fill(0));
    return {months, targets:targets.map(toNum), actuals:actuals.map(toNum), expected:expected.map(toNum)};
  }

  function startIndex(actuals){
    const now = new Date(); const m = now.getMonth();
    if (el.includeCur && el.includeCur.checked){
      return (actuals[m]>0) ? m+1 : m;
    }
    return (actuals[m]>0) ? m+1 : m+1;
  }

  function compute(){
    const {months, targets, actuals, expected} = getArrays();
    const base = el.baseline();
    const horizon = parseInt(el.months.value||'12',10);
    const g = parseFloat(el.growth.value||'0')/100;
    const inc = parseFloat(el.inc.value||'0')/100;

    const curTargetSum = targets.reduce((s,v)=>s+(+v||0),0);
    let desiredTotal = curTargetSum;
    const override = toNum(el.yTarget?.value);
    if (override>0) desiredTotal = override;
    let weights = (el.dist?.value==='equal') ? Array(12).fill(1) : targets.slice();
    let wsum = weights.reduce((s,v)=>s+(+v||0),0);
    if (wsum<=0){ weights = Array(12).fill(1); wsum=12; }
    const adjTarget = weights.map(w => desiredTotal * (w/wsum));

    const proj = actuals.slice();
    const sIdx = startIndex(actuals);
    let used=0;
    for (let i=sIdx; i<12; i++){
      let baseline = 0;
      if (base==='expected') baseline = expected[i] || targets[i] || 0;
      else if (base==='target') baseline = targets[i] || 0;
      else baseline = l3mAvg(actuals, i) || expected[i] || targets[i] || 0;
      const factor = (1+g) * Math.pow(1+inc, Math.max(0, i-sIdx));
      proj[i] = baseline * factor;
      used++;
      if (used>=horizon) break;
    }

    const sm = (el.shockMonth?.value||'').toLowerCase().slice(0,3);
    if (sm){
      const idx = MONTHS.map(s=>s.toLowerCase()).indexOf(sm);
      if (idx>=0) proj[idx] = (proj[idx]||0) + toNum(el.shockAED?.value);
    }

    const cum = a => a.reduce((arr,v,i)=>{ arr[i]=(i?arr[i-1]:0)+(+v||0); return arr; }, []);
    const cumActual = cum(actuals);
    const cumProj   = cum(proj);
    const cumAdjT   = cum(adjTarget);
    const ye = cumProj[11]||0;
    const tgtSum = adjTarget.reduce((s,v)=>s+(+v||0),0);
    const completion = tgtSum>0 ? (ye/tgtSum*100) : 0;
    const gap = ye - tgtSum;

    return {months, cumActual, cumProj, cumAdjT, ye, completion, gap, adjTarget};
  }

  let chart;
  function renderChart(d){
    if (!el.canvas) return;
    const ctx = el.canvas.getContext('2d');
    if (chart){ try{ chart.destroy(); }catch(e){} }
    if (!window.Chart){ ctx.fillText('Chart.js is missing', 8, 16); return; }
    chart = new Chart(el.canvas, {
      type: 'line',
      data: {
        labels: d.months.map(m => m.slice(0,3)),
        datasets: [
          { label: 'Cum. Actual', data: d.cumActual, borderWidth: 2, tension: .2, fill:false },
          { label: 'Scenario (Cum.)', data: d.cumProj, borderWidth: 2, borderDash:[6,4], tension: .2, fill:false },
          { label: 'Adj. Target (Cum.)', data: d.cumAdjT, borderWidth: 2, borderDash:[2,3], tension: .2, fill:false }
        ]
      },
      options: { responsive:true, plugins:{ legend: { position: 'top', labels: { usePointStyle: true, pointStyle: 'circle', boxWidth: 9, boxHeight: 9, padding: 10, font: { size: 9 } } } }, scales:{ y:{ beginAtZero:true } } }
    });
  }

  function run(){
    el.monthsVal.textContent = el.months.value;
    const d = compute();
    el.ye.textContent = fmt(d.ye);
    el.completion.textContent = (d.completion).toFixed(1);
    el.gap.textContent = fmt(d.gap);
    renderChart(d);
    window.__SCENARIO_V2_LAST__ = d;
  }

  ['input','change'].forEach(ev => {
    el.months.addEventListener(ev, run);
    el.growth.addEventListener(ev, run);
    el.inc.addEventListener(ev, run);
    el.includeCur.addEventListener(ev, run);
    document.querySelectorAll('input[name="scv2Baseline"]').forEach(r => r.addEventListener(ev, run));
    el.yTarget.addEventListener(ev, run);
    el.dist.addEventListener(ev, run);
    el.shockMonth.addEventListener(ev, run);
    el.shockAED.addEventListener(ev, run);
  });

  el.reset.addEventListener('click', () => {
    el.months.value = 12; el.monthsVal.textContent = '12';
    el.growth.value = 0; el.inc.value = 0;
    el.includeCur.checked = false;
    (document.querySelector('input[name="scv2Baseline"][value="expected"]')||{}).checked = true;
    el.yTarget.value = '';
    el.dist.value = 'weights';
    el.shockMonth.value = ''; el.shockAED.value = 0;
    run();
  });

  function applyTargetsToTable(monthly){
    const table = document.querySelector('table'); if (!table) return 0;
    const ths = Array.from(table.querySelectorAll('thead th, tr th')).map(th=>th.textContent.trim().toLowerCase());
    const idxMonth = ths.indexOf('month');
    const idxTarget = ths.indexOf('target');
    if (idxMonth<0 || idxTarget<0) return 0;
    const body = table.tBodies[0]||table;
    let applied=0;
    Array.from(body.querySelectorAll('tr')).forEach(tr => {
      const tds = Array.from(tr.children);
      if (tds.length<=idxTarget) return;
      const mtxt = (tds[idxMonth]?.textContent||'').trim().slice(0,3).toLowerCase();
      const map = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
      const i = map.indexOf(mtxt);
      if (i<0) return;
      const v = Math.round(monthly[i]);
      tds[idxTarget].textContent = new Intl.NumberFormat().format(v);
      tds[idxTarget].dispatchEvent(new Event('input',{bubbles:true}));
      tds[idxTarget].dispatchEvent(new Event('change',{bubbles:true}));
      tds[idxTarget].dispatchEvent(new Event('blur',{bubbles:true}));
      applied++;
    });
    return applied;
  }

  el.apply.addEventListener('click', () => {
    const d = window.__SCENARIO_V2_LAST__;
    if (!d) return;
    const applied = applyTargetsToTable(d.adjTarget);
    if (Array.isArray(window.monthlyTargets) && window.monthlyTargets.length===12){
      for (let i=0;i<12;i++) window.monthlyTargets[i] = d.adjTarget[i];
    }
    console.log('Scenario v2 applied to targets. Rows updated:', applied);
  });

  run();
})();
</script>
<script id="leak-guard">
(function(){
  function looksLikeCode(txt){
    if(!txt) return false;
    txt = String(txt);
    return /<\/script>/i.test(txt) || /(function|const|let|var)/.test(txt) || (/\{[\s\S]*\}/.test(txt) && txt.length > 120);
  }
  // Remove pre/code blocks with script-like content
  document.querySelectorAll('pre, code, .script-dump').forEach(function(el){
    var t = el.textContent || '';
    if(looksLikeCode(t)) el.remove();
  });
  // Remove stray text nodes at end of body
  for(var i=0;i<3;i++){
    var node = document.body.childNodes[document.body.childNodes.length - 1 - i];
    if(!node) break;
    if(node.nodeType === Node.TEXT_NODE && looksLikeCode(node.nodeValue)){
      node.remove();
    } else if(node.nodeType === Node.ELEMENT_NODE){
      var text=node.textContent||'';
      if((/^(<script|\/\*|\*\/|\/\/)/i.test(text) || looksLikeCode(text)) && /^(PRE|CODE|DIV|P)$/i.test(node.nodeName)){
        node.remove();
      }
    }
  }
  // Override innerHTML setter to strip script tags
  var proto = Element.prototype;
  var desc = Object.getOwnPropertyDescriptor(proto, 'innerHTML');
  if(desc && desc.set){
    var origSet=desc.set;
    Object.defineProperty(proto, 'innerHTML', {
      set:function(value){
        var v=String(value);
        if(/<\/script>/i.test(v) || /<script[\s>]/i.test(v)){
          v=v.replace(/<script[\s\S]*?<\/script>/gi, '');
        }
        return origSet.call(this, v);
      }
    });
  }
})();
</script>
<style id="cheque-reminder-align-tweak">
  #kpiLabel_monthlyNeeded{ display:flex !important; align-items:center !important; gap:6px !important; }
  #kpiLabel_monthlyNeeded #cheqMirrorSlot{ margin-left:auto !important; padding-left:8px !important; }
</style>
<style id="clear-all-style">
  /* Match white + fine black border style and hide legacy tiny broom */
  #btnClearAll{
    background:#fff !important; color:#000 !important;
    border:1px solid #000 !important; box-shadow:none !important; filter:none !important;
  }
  #btnClearAll:hover{ opacity:0.95; }
  #btnAppWipe{ display:none !important; visibility:hidden !important; }
</style>
<script id="clear-all-widget">
(function(){
  function addClearAllBtn(){
    var reset = document.getElementById('btnReset');
    if(!reset || reset.__hasClearAll) return;

    var btn = document.createElement('button');
    btn.id = 'btnClearAll';
    btn.className = 'ghost small';
    btn.textContent = 'Clear all my data';
    btn.title = 'Deletes ALL owners & years data saved by this app';
    btn.style.marginLeft = '6px';

    (reset.parentElement || reset).insertBefore(btn, reset.nextSibling);
    reset.__hasClearAll = true;

    btn.addEventListener('click', function(){
      var phrase = 'clear all my data'; // CASE-SENSITIVE
      var typed  = prompt('Type exactly: '+phrase+'\\n\\nThis will permanently delete ALL owners & years data saved by this page.');
      if (typed !== phrase){ alert('Cancelled (text did not match exactly).'); return; }

      var PREFIXES  = [
        'performanceTracker:',
        'ownerLabel:',
        'monthlyNotes:',
        'chequeReminder:'
      ];
      var EXACT_KEYS = [
        'selectedOwnerId',
        '__od_limit__','__od_eod__'
      ];

      var toRemove = [];
      for (var i=0; i<localStorage.length; i++){
        var k = localStorage.key(i); if(!k) continue;
        if (EXACT_KEYS.indexOf(k) !== -1 || PREFIXES.some(function(p){ return k.startsWith(p); })){
          toRemove.push(k);
        }
      }
      ['chequeReminder','cheq:reminder'].forEach(function(k){ toRemove.push(k); });

      toRemove = Array.from(new Set(toRemove));
      toRemove.forEach(function(k){ try{ localStorage.removeItem(k); }catch(e){} });

      var refreshed = false;
      try{ if(window.CHEQ && typeof CHEQ.remove==='function'){ CHEQ.remove(); refreshed = true; } }catch(e){}
      try{ if(window.refreshChequeReminderUI){ window.refreshChequeReminderUI(); refreshed = true; } }catch(e){}
      try{ if(window.renderAll){ window.renderAll(); refreshed = true; } }catch(e){}
      try{ if(window.updateCurrentOwnerData){ window.updateCurrentOwnerData(); refreshed = true; } }catch(e){}
      try{ if(window.refreshNextTargetMain){ window.refreshNextTargetMain(); refreshed = true; } }catch(e){}
      try{ if(window.refreshNextNeededRibbon){ window.refreshNextNeededRibbon(); refreshed = true; } }catch(e){}

      if(!refreshed) location.reload();
      alert('All app data cleared.');
    });
  }

  function removeTinyBroom(){
    try{
      var b = document.getElementById('btnAppWipe');
      if (b && b.parentNode) b.parentNode.removeChild(b);
    }catch(e){}
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', function(){ addClearAllBtn(); removeTinyBroom(); });
  }else{
    setTimeout(function(){ addClearAllBtn(); removeTinyBroom(); }, 0);
  }
})();
</script>
<script id="kpi-gold-fix-script">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll('.progressLabel').forEach(function(el) {
    if (el.textContent.includes("Inflow Achieved") || el.textContent.includes("Remaining to Target")) {
      el.style.color = "gold";
      el.style.fontWeight = "700";
      el.style.
    }
  });
});
</script>
<script id="kpi-gold-resize-script">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll(".progressLabel").forEach(function(el) {
    if (el.textContent.includes("Remaining to Target") || el.textContent.includes("Inflow Achieved")) {
      el.style.fontSize = "115%";
      el.style.color = "gold";
      el.style.fontWeight = "700";
      el.style.textShadow = "0 0 6px rgba(255,215,0,0.6)";
    }
  });
});
</script>
<script id="branding-gold-text-script">
document.addEventListener("DOMContentLoaded", function() {
  function styleIfMatch(el) {
    if (!el) return;
    if (el.textContent.includes("ENBD Performance Tracker") || el.textContent.includes("created by Fuad Al-Taher")) {
      el.style.color = "gold";
      el.style.fontWeight = "700";
      el.style.textShadow = "0 0 6px rgba(255,215,0,0.6)";
    }
  }
  document.querySelectorAll("h1, p, span, div, #branding, .branding-text, .footer-note").forEach(styleIfMatch);
});
</script>
<script id="dark-mode-watchdog">
(function(){
  function ensureDark(){
    if (!document.body.classList.contains('dark')) {
      document.body.classList.add('dark');
    }
  }
  // Force immediately
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureDark);
  } else {
    ensureDark();
  }
  // Keep it enforced against scripts that toggle classes
  const obs = new MutationObserver((mutations) => {
    for (const m of mutations) {
      if (m.type === 'attributes' && m.attributeName === 'class') {
        ensureDark();
      }
    }
  });
  obs.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  // Also re-apply on visibility changes (if SPA code rerenders)
  document.addEventListener('visibilitychange', ensureDark);
})();
</script>
</body>
</html>
<!-- === FINAL PATCH v26: Ribbon = Next Needed (future-only), Circle = Next Target (nearest with target) === -->
<script>
(function(){
  // Helpers
  function monthName(idx){
    const arr = (Array.isArray(window.months) && window.months.length === 12)
      ? window.months
      : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    return arr[idx] || "—";
  }
  function fmt(n){
    try{ return (window.formatNumber ? formatNumber(n) : (Number(n)||0).toLocaleString()); }
    catch(e){ return String(n); }
  }
  function getSelectedYear(){
    var yText = (document.getElementById('yearInput')||{}).value
             || (document.getElementById('yearFancy')||{}).textContent
             || window.currentYear;
    var y = parseInt(yText, 10);
    if (!isFinite(y)) y = (new Date()).getFullYear();
    return y;
  }
  function getLiveNow(){
    // Use local time (Asia/Dubai for the user; JS runs in browser locale)
    return new Date();
  }
  function arrays(){
    const t = window.monthlyTargets
           || (window.owners && window.owners[window.currentOwner] && window.owners[window.currentOwner].monthlyTargets)
           || window.targets || [];
    const a = window.monthlyInflows
           || window.monthlyBankInflow
           || window.actuals
           || (window.owners && window.owners[window.currentOwner] && window.owners[window.currentOwner].monthlyBankInflow)
           || [];
    const kd = window.keyDates
           || (window.owners && window.owners[window.currentOwner] && window.owners[window.currentOwner].keyDates)
           || [];
    return { t, a, kd };
  }
  function getBroughtForward(){
    try{ return Number((window.owners && window.owners[window.currentOwner] && window.owners[window.currentOwner].broughtForward) || 0) || 0; }
    catch(e){ return 0; }
  }

  // --- Override: findNextNeededMonth (future-only) ---
  window.findNextNeededMonth = function(){
    try{
      const now = getLiveNow();
      const liveYear = now.getFullYear();
      const selYear = getSelectedYear();
      // If viewing a past year, there is no future shortage within that year.
      if (selYear < liveYear) return null;

      const startMonth = (selYear === liveYear) ? now.getMonth() : 0;
      const { t, a, kd } = arrays();
      const bf = getBroughtForward();

      function accumAfterMonth(i){
        let acc = bf;
        for (let k=0;k<=i;k++){
          acc += Number(a[k]||0) - Number(t[k]||0);
        }
        return acc;
      }

      // Prefer future key dates that are within the selected year and in/after the start month
      const dated = [];
      for (let i= startMonth; i<12; i++){
        const accAfter = accumAfterMonth(i);
        if (accAfter >= 0) continue; // only if still short after this month
        const dates = kd[i] || [];
        for (const d of dates){
          let dt = null;
          try{ dt = new Date(d); }catch(_){ dt = null; }
          if (!dt) continue;
          // Date must be within the selected year and not in the past relative to "start"
          const baseRef = new Date(selYear, startMonth, 1);
          if (dt >= baseRef && dt.getFullYear() === selYear){
            dated.push({ index:i, needed: Math.max(0, -accAfter), date: dt });
          }
        }
      }
      if (dated.length){
        dated.sort((x,y)=> x.date - y.date);
        const top = dated[0];
        return { index: top.index, needed: top.needed };
      }

      // Fallback: first month at/after startMonth where cumulative remains negative
      for (let i=startMonth; i<12; i++){
        const accAfter = accumAfterMonth(i);
        if (accAfter < 0){
          return { index: i, needed: Math.max(0, -accAfter) };
        }
      }
      return null;
    }catch(e){
      return null;
    }
  };

  // Compute + render the Next Needed ribbon using the override above
  function updateNextRibbon(){
    try{
      const E = (typeof window.elements !== 'undefined') ? window.elements : {};
      const container = E.nextContainer || document.getElementById('nextContainer');
      const pill      = E.nextMonthPill || document.getElementById('nextMonthPill');
      const txt       = E.nextText      || document.getElementById('nextText');
      const daysEl    = E.nextDays      || document.getElementById('nextDays');
      if (!container || !pill || !txt || !daysEl) return;

      const next = window.findNextNeededMonth();
      const { t, a, kd } = arrays();

      if (!next){
        pill.textContent = '—';
        txt.innerHTML = '<span class="muted">All set</span>';
        daysEl.textContent = '-';
        container.classList.remove('shortage');
        return;
      }

      const idx = next.index;
      const targetAmt = Number(t[idx]||0);
      const actualAmt = Number(a[idx]||0);
      // Accumulated variance after this month
      let acc = getBroughtForward();
      for (let k=0;k<=idx;k++){ acc += Number(a[k]||0) - Number(t[k]||0); }
      const shortage = Math.max(0, -acc);
      const surplus  = Math.max(0,  acc);

      // Month & amount
      pill.textContent = monthName(idx);
      // Show the target amount; annotate with shortage/surplus/met
      if (shortage > 0){
        txt.innerHTML = `<strong>${fmt(targetAmt)}</strong> <span style="color:var(--orange-red-flag);">(shortage ${fmt(shortage)})</span>`;
        container.classList.add('shortage');
      } else if (surplus > 0){
        txt.innerHTML = `<strong>${fmt(targetAmt)}</strong> <span style="color:var(--green);">(surplus ${fmt(surplus)})</span>`;
        container.classList.remove('shortage');
      } else {
        txt.innerHTML = `<strong>${fmt(targetAmt)}</strong> <span class="muted">(met)</span>`;
        container.classList.remove('shortage');
      }

      // Days to next
      let dStr = '—';
      if (typeof window.getDaysToNext === 'function'){
        dStr = window.getDaysToNext(kd[idx] || []);
      } else {
        const now = getLiveNow();
        const dates = (kd[idx]||[]).map(d => new Date(d)).filter(Boolean).filter(d => d >= now);
        if (dates.length){
          const ms = dates.sort((x,y)=>x-y)[0] - now;
          const d  = Math.ceil(ms / (1000*60*60*24));
          dStr = (d === 0) ? 'Today' : (d > 0 ? String(d) : '—');
        }
      }
      daysEl.textContent = (dStr === '—' || dStr === 'Past') ? '-' : (dStr === 'Today' ? 'Today' : (dStr + 'd'));
    }catch(e){ /* no-op */ }
  }

  // Ensure circle keeps showing "Next Target" (nearest target by calendar) — already implemented above,
  // we just re-run both updates after renders.
  function wire(){
    try{
      // Wrap renderGauge if exists
      const orig = window.renderGauge;
      if (typeof orig === 'function' && !window.__wrappedGauge){
        window.renderGauge = function(){
          const r = orig.apply(this, arguments);
          try{ updateGaugeInner && updateGaugeInner(); }catch(_){}
          try{ updateNextRibbon(); }catch(_){}
          return r;
        };
        window.__wrappedGauge = true;
      }
    }catch(_){}
    try{ updateGaugeInner && updateGaugeInner(); }catch(_){}
    try{ updateNextRibbon(); }catch(_){}
  }

  // Expose manual refresh
  window.refreshCircleAndRibbonStatus = function(){
    try{ updateGaugeInner && updateGaugeInner(); }catch(_){}
    try{ updateNextRibbon(); }catch(_){}
  };

  // Kick on load and after small delay to allow base app to render
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(wire, 80); });
  } else {
    setTimeout(wire, 80);
  }
})();
</script>
<!-- === Injected: General Notes Share (non-destructive) === -->
<script>
(function(){
  if (window.__attachGeneralNotesShare) return;
  window.__attachGeneralNotesShare = true;

  // Helper to get text content safely
  function _txt(el){ return (el ? (el.textContent || '').trim() : ''); }

  function attachGeneralNotesShare(){
    try{
      var card = document.getElementById('generalNotesCard');
      if (!card) return;
      // Header row is the first div inside the card
      var header = card.querySelector(':scope > div');
      if (!header) return;
      if (header.querySelector('.share-icon')) return; // already attached

      var icon = document.createElement('span');
      icon.className = 'share-icon';
      icon.title = 'Share general notes';
      icon.textContent = '↗';
      icon.setAttribute('aria-label', 'Share general notes');
      icon.style.cursor = 'pointer';
      header.appendChild(icon);

      icon.addEventListener('click', function(e){
        e.stopPropagation();
        try{ document.querySelectorAll('.month-pop').forEach(function(n){ n.remove(); }); }catch(_){}

        // Determine owner using multiple fallbacks
        var ownerEl = document.getElementById('ownerNameDisplay');
        var owner = _txt(ownerEl) || '';
        if (!owner) {
          var ownerSel = document.getElementById('ownerSelect');
          if (ownerSel) {
            var idxSel = ownerSel.selectedIndex;
            owner = (idxSel >= 0 && ownerSel.options[idxSel]) ? ownerSel.options[idxSel].text : ownerSel.value;
          } else if (window.currentOwner && window.owners && window.owners[window.currentOwner]) {
            owner = window.owners[window.currentOwner].name || window.currentOwner;
          } else {
            owner = 'Owner';
          }
        }
        // Determine year using display or input; fallback to current year
        var year = '';
        var yf = document.getElementById('yearFancy');
        var yi = document.getElementById('yearInput');
        var ytxt = '';
        if (yf) ytxt = (yf.textContent || '').trim();
        else if (yi) ytxt = (yi.value || '').trim();
        year = ytxt.replace(/\D+/g,'') || ('' + new Date().getFullYear());
        var title = owner + ' — ' + year + ' • General Notes';

        var notesEl = document.getElementById('generalNotes');
        var notes = notesEl ? (notesEl.value || '').trim() : '';
        var kv = [['Notes', notes || '—']];

        // buildCard / positionPopover / wireActions are already in this file (used by other share widgets)
        try {
          var pop = typeof buildCard === 'function' ? buildCard(title, kv) : null;
          if (!pop) {
            // Fallback minimal pop if buildCard isn't present (very unlikely in this file)
            pop = document.createElement('div');
            pop.className = 'month-pop';
            pop.style.position = 'fixed';
            pop.style.zIndex = 9999;
            pop.style.background = 'var(--card-bg, #fff)';
            pop.style.border = '1px solid rgba(0,0,0,0.1)';
            pop.style.borderRadius = '10px';
            pop.style.boxShadow = '0 6px 24px rgba(0,0,0,0.15)';
            pop.style.padding = '12px';
            pop.textContent = title + '\\n\\n' + (notes || '—');
          }
          document.body.appendChild(pop);
          if (typeof positionPopover === 'function') positionPopover(pop, icon);

          if (typeof wireActions === 'function') {
            wireActions(pop, title, kv);
            // Extend PNG to export the actual Notes card as an image
            var btnPNG = pop.querySelector('.png');
            if (btnPNG) {
              btnPNG.addEventListener('click', async function(){
                try {
                  if (!window.html2canvas){ alert('html2canvas not available'); return; }
                  // Create visible clones for inputs so html2canvas captures values nicely
                  var clones = [];
                  var fields = card.querySelectorAll('input, textarea, select');
                  fields.forEach(function(el){
                    var text = (el.tagName === 'SELECT') ? (el.options[el.selectedIndex] ? el.options[el.selectedIndex].text : '')
                               : (el.type === 'date') ? el.value
                               : el.value;
                    var cs = getComputedStyle(el);
                    var span = document.createElement('span');
                    span.className = 'exportClone';
                    span.textContent = text;
                    span.style.minWidth = el.offsetWidth + 'px';
                    span.style.minHeight = el.offsetHeight + 'px';
                    span.style.padding = cs.padding;
                    span.style.margin = cs.margin;
                    span.style.border = cs.border;
                    span.style.font = cs.font;
                    span.style.lineHeight = cs.lineHeight;
                    span.style.textAlign = cs.textAlign;
                    span.style.background = cs.backgroundColor;
                    span.style.color = cs.color;
                    span.style.borderRadius = cs.borderRadius;
                    el.insertAdjacentElement('afterend', span);
                    clones.push(span);
                  });
                  document.body.classList.add('__exporting');

                  var canvas = await window.html2canvas(card, { backgroundColor:'#ffffff', scale:2 });
                  var link = document.createElement('a');
                  link.download = (title.replace(/\\s+/g,'_') || 'General_Notes') + '.png';
                  link.href = canvas.toDataURL('image/png');
                  link.click();

                  clones.forEach(function(n){ n.remove(); });
                  document.body.classList.remove('__exporting');
                } catch(err){
                  console.warn('PNG export failed', err);
                }
              }, { once:true });
            }
          }
        } catch(err){
          console.warn('General Notes share error', err);
        }
      });
    }catch(err){ /* no-op */ }
  }

  // Run once + keep attached if the card re-renders
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(attachGeneralNotesShare, 0); });
  } else {
    setTimeout(attachGeneralNotesShare, 0);
  }
  if (window.MutationObserver){
    var mo = new MutationObserver(function(){ try{ attachGeneralNotesShare(); }catch(_){ } });
    mo.observe(document.body, { childList:true, subtree:true });
  }
})();
</script>
<!-- === Inject: Ribbon Share Arrow (small) === -->
<script>
(function(){
  if (window.__attachRibbonShare) return;
  window.__attachRibbonShare = true;

  function txt(el){ return (el ? (el.textContent || "").trim() : ""); }

  function ensureIcon(){
    try{
      var rib = document.getElementById('odc-ribbon');
      if (!rib) return;
      // right-side slot (2nd child div)
      var right = rib.children && rib.children.length >= 2 ? rib.children[1] : rib.querySelector(':scope > div:last-child');
      if (!right) right = rib;
      // Avoid duplicates
      if (right.querySelector('.share-icon[data-role="ribbon-share"]')) return;

      var icon = document.createElement('span');
      icon.className = 'share-icon';
      icon.setAttribute('data-role', 'ribbon-share');
      icon.title = 'Share ribbon';
      icon.textContent = '↗';
      icon.style.cursor = 'pointer';
      right.appendChild(icon);

      icon.addEventListener('click', function(e){
        e.stopPropagation();
        try{ document.querySelectorAll('.month-pop').forEach(function(n){ n.remove(); }); }catch(_){}

        var owner = txt(document.getElementById('ownerNameDisplay')) || '—';
        var year  = (txt(document.getElementById('yearFancy')) || txt(document.getElementById('yearInput')) || '').replace(/\D+/g,'') || (new Date()).getFullYear();
        var title = owner + ' — ' + year + ' • Due Ribbon';

        var kv = [
          ['Next due', txt(document.getElementById('odc-next-due')) || '—'],
          ['Label', (txt(document.getElementById('odc-next-label')) || '—').replace(/^•\s*/, '')],
          ['Target', 'AED ' + (txt(document.getElementById('odc-required')) || '—')],
          ['Actual Inflow', 'AED ' + (txt(document.getElementById('odc-cumcr')) || '—')],
          ['Gap to meet', txt(document.getElementById('odc-gap')) || '—']
        ];

        var pop = (typeof buildCard === 'function') ? buildCard(title, kv) : null;
        if (!pop){
          // Minimal fallback popover
          pop = document.createElement('div');
          pop.className = 'month-pop is-fixed';
          var h = document.createElement('h4'); h.textContent = title; pop.appendChild(h);
          var wrap = document.createElement('div'); wrap.className = 'kv'; pop.appendChild(wrap);
          kv.forEach(function(pair){
            var k = document.createElement('div'); k.textContent = pair[0]; wrap.appendChild(k);
            var v = document.createElement('div'); v.textContent = pair[1]; wrap.appendChild(v);
          });
        }
        document.body.appendChild(pop);

        try {
          if (typeof positionPopover === 'function') {
            positionPopover(pop, icon);
          } else {
            // viewport-aware positioning (fixed)
            var ar = icon.getBoundingClientRect();
            pop.style.position = 'fixed';
            var x = Math.max(8, Math.min(window.innerWidth - (pop.offsetWidth||260) - 8, ar.right - (pop.offsetWidth||260)));
            var y = ar.bottom + 8;
            if (y + (pop.offsetHeight||200) > window.innerHeight - 8){
              y = Math.max(8, ar.top - (pop.offsetHeight||200) - 8);
            }
            pop.style.left = x + 'px';
            pop.style.top  = y + 'px';
          }
        } catch(_){}

        try {
          if (typeof wireActions === 'function') wireActions(pop, title, kv);
        } catch(_){}

        // PNG export of the ribbon container
        var btnPNG = pop.querySelector('.png');
        if (btnPNG){
          btnPNG.addEventListener('click', async function(){
            try {
              if (!window.html2canvas){ alert('html2canvas not available'); return; }
              var target = document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon') || rib;
              if (!target){ alert('Ribbon not found'); return; }
              document.body.classList.add('__exporting');
              await new Promise(function(r){ setTimeout(r, 60); });
              var canvas = await window.html2canvas(target, { backgroundColor:'#ffffff', scale:2 });
              var a = document.createElement('a');
              a.download = (title.replace(/\s+/g,'_') + '.png');
              a.href = canvas.toDataURL('image/png');
              a.click();
              setTimeout(function(){ document.body.classList.remove('__exporting'); }, 60);
            } catch(e){ /* no-op */ }
          }, { once: true });
        }
      });
    }catch(_){}
  }

  function init(){
    ensureIcon();
    // Re-attach if ribbon re-renders
    var ribCont = document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon') || document.body;
    if (window.MutationObserver && ribCont){
      var mo = new MutationObserver(function(){ ensureIcon(); });
      mo.observe(ribCont, { childList:true, subtree:true });
    }
    // Also hook into common app events
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','hardRefresh','renderRibbon','renderKPIs','renderTable','refreshCircleAndRibbonStatus']
    .forEach(function(name){
      if (window[name] && typeof window[name] === 'function'){
        var orig = window[name];
        window[name] = function(){
          var r = orig.apply(this, arguments);
          try{ ensureIcon(); }catch(_){}
          return r;
        };
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(init, 0); });
  } else {
    setTimeout(init, 0);
  }
})();
</script>
<!-- === Addon: Ensure Ribbon Share Popover has action bar === -->
<script>
(function(){
  if (window.__ribbonShareAddon) return; window.__ribbonShareAddon = true;

  function textFromKV(title, kv){
    var lines = [title];
    kv.forEach(function(p){ lines.push(p[0] + ": " + p[1]); });
    return lines.join("\n");
  }

  function ensureActions(pop, title, kv, targetEl){
    // If actions already present, skip
    if (pop.querySelector('.actions.ribbon-actions')) return;

    var actions = document.createElement('div');
    actions.className = 'actions ribbon-actions';
    actions.style.display = 'flex';
    actions.style.flexWrap = 'wrap';
    actions.style.gap = '8px';
    actions.style.marginTop = '8px';
    actions.style.borderTop = '1px solid #e5e5e5';
    actions.style.paddingTop = '8px';

    function mkBtn(label, cls){
      var b = document.createElement('button');
      b.type = 'button';
      b.className = 'btn ' + (cls || '');
      b.textContent = label;
      b.style.border = '1px solid #111';
      b.style.background = '#fff';
      b.style.padding = '4px 8px';
      b.style.borderRadius = '6px';
      b.style.fontSize = '12px';
      b.style.cursor = 'pointer';
      return b;
    }

    var btnCopy = mkBtn('Copy');
    var btnWA   = mkBtn('WhatsApp');
    var btnPNG  = mkBtn('PNG');
    var btnPDF  = mkBtn('PDF');
    var btnPrint= mkBtn('Print');
    var btnClose= mkBtn('Close');

    actions.appendChild(btnCopy);
    actions.appendChild(btnWA);
    actions.appendChild(btnPNG);
    actions.appendChild(btnPDF);
    actions.appendChild(btnPrint);
    actions.appendChild(btnClose);

    pop.appendChild(actions);

    var summary = textFromKV(title, kv);

    btnCopy.addEventListener('click', async function(){
      try{
        await navigator.clipboard.writeText(summary);
        var old = btnCopy.textContent; btnCopy.textContent = 'Copied';
        setTimeout(function(){ btnCopy.textContent = old; }, 1200);
      }catch(e){ alert('Copy failed'); }
    });

    btnWA.addEventListener('click', function(){
      var url = 'https://wa.me/?text=' + encodeURIComponent(summary);
      window.open(url, '_blank');
    });

    btnPNG.addEventListener('click', async function(){
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        var target = targetEl || document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon') || document.body;
        document.body.classList.add('__exporting');
        await new Promise(function(r){ setTimeout(r, 60); });
        var canvas = await window.html2canvas(target, { backgroundColor:'#ffffff', scale:2 });
        var a = document.createElement('a');
        a.download = (title.replace(/\s+/g,'_') + '.png');
        a.href = canvas.toDataURL('image/png');
        a.click();
        setTimeout(function(){ document.body.classList.remove('__exporting'); }, 60);
      }catch(e){ alert('PNG export failed'); }
    });

    btnPDF.addEventListener('click', async function(){
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        var target = targetEl || document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon') || document.body;
        var canvas = await window.html2canvas(target, { backgroundColor:'#ffffff', scale:2 });
        var img = canvas.toDataURL('image/png');
        var jsPDFCtor = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : window.jsPDF;
        if (!jsPDFCtor){ alert('jsPDF not available'); return; }
        var pdf = new jsPDFCtor('p', 'pt', 'a4');
        var pageWidth = pdf.internal.pageSize.getWidth();
        var pageHeight = pdf.internal.pageSize.getHeight();
        var imgWidth = pageWidth - 40; // 20pt margins
        var ratio = imgWidth / canvas.width;
        var imgHeight = canvas.height * ratio;
        var y = 20;
        if (imgHeight > pageHeight - 40){
          // scale down to fit height
          var ratioH = (pageHeight - 40) / canvas.height;
          imgWidth = canvas.width * ratioH;
          imgHeight = pageHeight - 40;
        }
        pdf.addImage(img, 'PNG', (pageWidth - imgWidth)/2, y, imgWidth, imgHeight);
        pdf.save(title.replace(/\s+/g,'_') + '.pdf');
      }catch(e){ alert('PDF export failed'); }
    });

    btnPrint.addEventListener('click', function(){
      var target = targetEl || document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon') || document.body;
      var w = window.open('', '_blank');
      if (!w) { alert('Popup blocked'); return; }
      w.document.write('<!DOCTYPE html><html><head><title>'+title+'</title>
<style id="page-background-image-fixed">
  /* Strong override so the wallpaper wins even with kill-all !important rules */
  html, body {
    background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg') !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    background-attachment: fixed !important;
    min-height: 100% !important;
  }

  /* Make sure it also appears in print/PDF */
  @media print {
    html, body::before {
      -webkit-print-color-adjust: exact !important;
      print-color-adjust: exact !important;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
  }
</style>


<style id="page-wallpaper-override">
  :root { --page-wallpaper: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg'); }

  /* Ensure page itself is transparent and tall */
  html, body {
    height: 100% !important;
    min-height: 100% !important;
    background: transparent !important;
  }

  /* Primary method: a fixed pseudo-layer that always covers the viewport */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;            /* sits behind all content */
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Fallback layer in case some browsers ignore ::before due to stacking contexts */
  #page-wallpaper-layer {
    position: fixed;
    inset: 0;
    z-index: -2;
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Ensure print/PDF keeps the wallpaper */
  @media print {
    html, body::before { 
      -webkit-print-color-adjust: exact !important; 
      print-color-adjust: exact !important; 
    }
    body::before {
      position: fixed;
    }
  }
</style>


<style id="chart-background-restore">
  #chartCard,
  #chartWrapper,
  #chartWrapper canvas {
    background: #ffffff !important;
    border-radius: 8px;   /* rounded edges */
    box-shadow: 0 2px 6px rgba(0,0,0,0.1); /* subtle depth */
  }
</style>


<style id="branding-background-restore">
  .branding-text, #branding, .footer-note {
    display: inline-block;
    background: #ffffff !important;
    padding: 4px 8px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  }
</style>


<style id="legend-css-25pct-v4">
/* Force ~25% smaller custom legend UI */
.legend-item { font-size: 10px !important; gap: 6px !important; }
.legend-color { width: 12px !important; height: 12px !important; border-radius: 3px !important; }
/* Chart.js HTML legend (if used) */
.chartjs-legend li { font-size: 9px !important; }
.chartjs-legend li span { width: 9px !important; height: 9px !important; }
</style>

</head><body>






























<style id="cheque-reminder-align-tweak">
  #kpiLabel_monthlyNeeded{ display:flex !important; align-items:center !important; gap:6px !important; }
  #kpiLabel_monthlyNeeded #cheqMirrorSlot{ margin-left:auto !important; padding-left:8px !important; }
</style>

</body></html>');
      var clone = target.cloneNode(true);
      clone.style.position = 'static';
      clone.style.transform = 'none';
      clone.style.boxShadow = 'none';
      w.document.body.appendChild(clone);
      w.focus();
      setTimeout(function(){ w.print(); w.close(); }, 250);
    });

    btnClose.addEventListener('click', function(){
      try{ pop.remove(); }catch(_){}
    });
  }

  // Hook into the existing injected click flow if present
  var _old = window.__attachRibbonShare;
  // If our earlier script stored a flag, we piggyback by listening globally
  document.addEventListener('click', function(ev){
    // When a month-pop is created we try to enhance it
    setTimeout(function(){
      document.querySelectorAll('.month-pop.is-fixed').forEach(function(pop){
        // detect it's our ribbon share pop by looking for h4 title containing 'Due Ribbon' (set earlier) or data-role
        var titleEl = pop.querySelector('h4');
        var title = titleEl ? titleEl.textContent.trim() : 'Ribbon';
        var kv = [];
        pop.querySelectorAll('.kv > div').forEach(function(div, idx){
          if (idx % 2 === 0){
            var key = div.textContent.trim();
            var valDiv = div.nextElementSibling;
            var val = valDiv ? valDiv.textContent.trim() : '';
            kv.push([key, val]);
          }
        });
        if (kv.length){
          ensureActions(pop, title, kv, document.getElementById('odc-ribbon-container') || document.getElementById('odc-ribbon'));
        }
      });
    }, 60);
  }, true);
})();
</script>
<!-- === Inject: General Notes Share Arrow (small) === -->
<script>
(function(){
  if (window.__attachGeneralNotesShare) return;
  window.__attachGeneralNotesShare = true;

  function makeActions(pop, title, summary, targetEl){
    if (pop.querySelector('.actions.gn-actions')) return;
    var actions = document.createElement('div');
    actions.className = 'actions gn-actions';
    actions.style.display = 'flex';
    actions.style.flexWrap = 'wrap';
    actions.style.gap = '8px';
    actions.style.marginTop = '8px';
    actions.style.borderTop = '1px solid #e5e5e5';
    actions.style.paddingTop = '8px';

    function mkBtn(label){
      var b = document.createElement('button');
      b.type = 'button';
      b.textContent = label;
      b.style.border = '1px solid #111';
      b.style.background = '#fff';
      b.style.padding = '4px 8px';
      b.style.borderRadius = '6px';
      b.style.fontSize = '12px';
      b.style.cursor = 'pointer';
      return b;
    }

    var btnCopy = mkBtn('Copy');
    var btnWA   = mkBtn('WhatsApp');
    var btnPNG  = mkBtn('PNG');
    var btnPDF  = mkBtn('PDF');
    var btnPrint= mkBtn('Print');
    var btnClose= mkBtn('Close');

    actions.appendChild(btnCopy);
    actions.appendChild(btnWA);
    actions.appendChild(btnPNG);
    actions.appendChild(btnPDF);
    actions.appendChild(btnPrint);
    actions.appendChild(btnClose);

    pop.appendChild(actions);

    btnCopy.addEventListener('click', async function(){
      try{
        await navigator.clipboard.writeText(summary);
        var old = btnCopy.textContent; btnCopy.textContent = 'Copied';
        setTimeout(function(){ btnCopy.textContent = old; }, 1200);
      }catch(e){ alert('Copy failed'); }
    });

    btnWA.addEventListener('click', function(){
      var url = 'https://wa.me/?text=' + encodeURIComponent(summary);
      window.open(url, '_blank');
    });

    btnPNG.addEventListener('click', async function(){
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        var target = targetEl || document.getElementById('generalNotesCard');
        if (!target){ alert('General Notes card not found'); return; }
        document.body.classList.add('__exporting');
        await new Promise(function(r){ setTimeout(r, 60); });
        var canvas = await window.html2canvas(target, { backgroundColor:'#ffffff', scale:2 });
        var a = document.createElement('a');
        a.download = (title.replace(/\s+/g,'_') + '.png');
        a.href = canvas.toDataURL('image/png');
        a.click();
        setTimeout(function(){ document.body.classList.remove('__exporting'); }, 60);
      }catch(e){ alert('PNG export failed'); }
    });

    btnPDF.addEventListener('click', async function(){
      try{
        if (!window.html2canvas){ alert('html2canvas not available'); return; }
        var target = targetEl || document.getElementById('generalNotesCard');
        if (!target){ alert('General Notes card not found'); return; }
        var canvas = await window.html2canvas(target, { backgroundColor:'#ffffff', scale:2 });
        var img = canvas.toDataURL('image/png');
        var jsPDFCtor = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : window.jsPDF;
        if (!jsPDFCtor){ alert('jsPDF not available'); return; }
        var pdf = new jsPDFCtor('p', 'pt', 'a4');
        var pageWidth = pdf.internal.pageSize.getWidth();
        var pageHeight = pdf.internal.pageSize.getHeight();
        var imgWidth = pageWidth - 40; // margins
        var ratio = imgWidth / canvas.width;
        var imgHeight = canvas.height * ratio;
        if (imgHeight > pageHeight - 40){
          var ratioH = (pageHeight - 40) / canvas.height;
          imgWidth = canvas.width * ratioH;
          imgHeight = pageHeight - 40;
        }
        pdf.addImage(img, 'PNG', (pageWidth - imgWidth)/2, 20, imgWidth, imgHeight);
        pdf.save(title.replace(/\s+/g,'_') + '.pdf');
      }catch(e){ alert('PDF export failed'); }
    });

    btnPrint.addEventListener('click', function(){
      var target = targetEl || document.getElementById('generalNotesCard');
      var w = window.open('', '_blank');
      if (!w) { alert('Popup blocked'); return; }
      w.document.write('<!DOCTYPE html><html><head><title>'+title+'</title>
<style id="page-background-image-fixed">
  /* Strong override so the wallpaper wins even with kill-all !important rules */
  html, body {
    background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg') !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    background-attachment: fixed !important;
    min-height: 100% !important;
  }

  /* Make sure it also appears in print/PDF */
  @media print {
    html, body::before {
      -webkit-print-color-adjust: exact !important;
      print-color-adjust: exact !important;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background-image: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
  }
</style>


<style id="page-wallpaper-override">
  :root { --page-wallpaper: url('https://img.freepik.com/free-vector/paper-style-dynamic-lines-background_23-2149008629.jpg'); }

  /* Ensure page itself is transparent and tall */
  html, body {
    height: 100% !important;
    min-height: 100% !important;
    background: transparent !important;
  }

  /* Primary method: a fixed pseudo-layer that always covers the viewport */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;            /* sits behind all content */
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Fallback layer in case some browsers ignore ::before due to stacking contexts */
  #page-wallpaper-layer {
    position: fixed;
    inset: 0;
    z-index: -2;
    background-image: var(--page-wallpaper);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    pointer-events: none;
  }

  /* Ensure print/PDF keeps the wallpaper */
  @media print {
    html, body::before { 
      -webkit-print-color-adjust: exact !important; 
      print-color-adjust: exact !important; 
    }
    body::before {
      position: fixed;
    }
  }
</style>


<style id="chart-background-restore">
  #chartCard,
  #chartWrapper,
  #chartWrapper canvas {
    background: #ffffff !important;
    border-radius: 8px;   /* rounded edges */
    box-shadow: 0 2px 6px rgba(0,0,0,0.1); /* subtle depth */
  }
</style>


<style id="branding-background-restore">
  .branding-text, #branding, .footer-note {
    display: inline-block;
    background: #ffffff !important;
    padding: 4px 8px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  }
</style>


<style>

/* === Global Dark Styling for Popups / Modals / Reminder === */
.popup, .modal, .reminder-popup {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 6px 24px rgba(0,0,0,0.6) !important;
  padding: 12px 16px !important;
  z-index: 99999;
}
.popup button, .modal button, .reminder-popup button {
  background: #222 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.2) !important;
  border-radius: 6px;
  padding: 6px 10px;
  cursor: pointer;
}
.popup button:hover, .modal button:hover, .reminder-popup button:hover {
  background: #333 !important;
}

</style>

<style>

/* === Targeted Dark Theme for Cheque Reminder === */
#cheqPop, .cheq-pop {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 8px 28px rgba(0,0,0,0.65) !important;
}
#cheqPop label { color: #eaeaea !important; }

#cheqPop input[type="text"],
#cheqPop input[type="number"],
#cheqPop input[type="date"],
#cheqPop input[type="time"],
#cheqPop select, 
#cheqPop textarea {
  background: #111 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 8px !important;
  padding: 6px 8px !important;
}
#cheqPop input::placeholder, #cheqPop textarea::placeholder { color: #bdbdbd !important; }

#cheqPop .cheq-btn {
  background: #222 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.2) !important;
  border-radius: 8px !important;
  padding: 6px 10px !important;
  cursor: pointer;
}
#cheqPop .cheq-btn:hover { background: #333 !important; }
#cheqPop .cheq-btn.danger { background: #3a0d0d !important; border-color: #7f1d1d !important; }

/* Toast used by cheque reminder */
.cheq-toast {
  background: rgba(0,0,0,0.92) !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  border-radius: 10px !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6) !important;
}

</style>

<style>

/* === Dark Theme for Next Targets Panel === */
#nextTargets, .next-targets-card, #nextTargetsCard {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
}
#nextTargets *, .next-targets-card *, #nextTargetsCard * {
  color: #fff !important;
}

</style>

<style>

/* === Next Targets: Highlight target numbers in green === */
#nextTargets .target, .next-targets-card .target, #nextTargetsCard .target {
  color: #16a34a !important; /* Tailwind green-600 */
  font-weight: 600;
}

</style>

<style>

/* === Next Targets: Force 2nd column (Target) text green === */
#nextTargets td:nth-child(2),
#nextTargetsCard td:nth-child(2),
.next-targets-card td:nth-child(2) {
  color: #16a34a !important; /* soft green */
  font-weight: 600;
}

</style>

<style>

/* === Next Targets: make target amount green === */
.next-target-card .ntc-row .amt {
  color: #16a34a !important;
  font-weight: 600;
}

</style>

<style>

/* === CORRECTED: Next Targets panel & amount styling === */
#nextTargetCard {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
}
#nextTargetCard * { color: #fff !important; }
#nextTargetCard .ntc-row .amt { color: #16a34a !important; font-weight: 600; }
#nextTargetCard .ntc-row .acc.neg { color: #ef4444 !important; font-weight: 700; }
#nextTargetCard .ntc-row .acc.pos { color: #16a34a !important; font-weight: 700; }

</style>

<style id="legend-css-25pct-v4">
/* Force ~25% smaller custom legend UI */
.legend-item { font-size: 10px !important; gap: 6px !important; }
.legend-color { width: 12px !important; height: 12px !important; border-radius: 3px !important; }
/* Chart.js HTML legend (if used) */
.chartjs-legend li { font-size: 9px !important; }
.chartjs-legend li span { width: 9px !important; height: 9px !important; }
</style>

</head><body>






























<style id="cheque-reminder-align-tweak">
  #kpiLabel_monthlyNeeded{ display:flex !important; align-items:center !important; gap:6px !important; }
  #kpiLabel_monthlyNeeded #cheqMirrorSlot{ margin-left:auto !important; padding-left:8px !important; }
</style>

</body></html>');
      var clone = target.cloneNode(true);
      clone.style.position = 'static';
      clone.style.transform = 'none';
      clone.style.boxShadow = 'none';
      w.document.body.appendChild(clone);
      w.focus();
      setTimeout(function(){ w.print(); w.close(); }, 250);
    });

    btnClose.addEventListener('click', function(){
      try{ pop.remove(); }catch(_){}
    });
  }

  function attachIcon(){
    var card = document.getElementById('generalNotesCard');
    if (!card) return;
    var header = card.querySelector(':scope > div:first-child');
    if (!header) header = card;
    var right = header.querySelector(':scope > div:last-child') || header;

    if (right.querySelector('.share-icon[data-role="gn-share"]')) return;

    var icon = document.createElement('span');
    icon.className = 'share-icon';
    icon.setAttribute('data-role', 'gn-share');
    icon.title = 'Share general notes';
    icon.textContent = '↗';
    icon.style.cursor = 'pointer';
    right.appendChild(icon);

    icon.addEventListener('click', function(ev){
      ev.stopPropagation();
      try{ document.querySelectorAll('.month-pop').forEach(function(n){ n.remove(); }); }catch(_){}

      // Determine owner using multiple fallbacks
      var ownerNameEl = document.getElementById('ownerNameDisplay');
      var owner = ownerNameEl ? (ownerNameEl.textContent || '').trim() : '';
      if (!owner){
        var ownerSel = document.getElementById('ownerSelect');
        if (ownerSel) {
          var idxSel = ownerSel.selectedIndex;
          owner = (idxSel >= 0 && ownerSel.options[idxSel]) ? ownerSel.options[idxSel].text : ownerSel.value;
        } else if (window.currentOwner && window.owners && window.owners[window.currentOwner]) {
          owner = window.owners[window.currentOwner].name || window.currentOwner;
        } else {
          owner = 'Owner';
        }
      }
      // Determine year using display or input; fallback to current year
      var yf = document.getElementById('yearFancy');
      var yi = document.getElementById('yearInput');
      var ytxt = '';
      if (yf) ytxt = (yf.textContent || '').trim();
      else if (yi) ytxt = (yi.value || '').trim();
      var year = ytxt.replace(/\D+/g,'') || ('' + new Date().getFullYear());
      var title = owner + ' — ' + year + ' • General Notes';

      var txt = (document.getElementById('generalNotes') || {}).value || '';
      var pop = document.createElement('div');
      pop.className = 'month-pop is-fixed';
      var h = document.createElement('h4'); h.textContent = title; pop.appendChild(h);

      var pre = document.createElement('div');
      pre.className = 'note-preview';
      pre.textContent = txt || '—';
      pre.style.whiteSpace = 'pre-wrap';
      pre.style.fontSize = '12px';
      pre.style.lineHeight = '1.4';
      pre.style.maxWidth = '480px';
      pre.style.maxHeight = '40vh';
      pre.style.overflow = 'auto';
      pre.style.padding = '6px 0';
      pop.appendChild(pre);

      document.body.appendChild(pop);

      // position near the icon
      try {
        var ar = icon.getBoundingClientRect();
        pop.style.position = 'fixed';
        var x = Math.max(8, Math.min(window.innerWidth - (pop.offsetWidth||320) - 8, ar.right - (pop.offsetWidth||320)));
        var y = ar.bottom + 8;
        if (y + (pop.offsetHeight||200) > window.innerHeight - 8){
          y = Math.max(8, ar.top - (pop.offsetHeight||200) - 8);
        }
        pop.style.left = x + 'px';
        pop.style.top  = y + 'px';
      } catch(_){}

      var summary = title + "\n\n" + (txt || '—');
      makeActions(pop, title, summary, document.getElementById('generalNotesCard'));
    }, { passive:true });
  }

  function init(){
    attachIcon();
    var card = document.getElementById('generalNotesCard') || document.body;
    if (window.MutationObserver && card){
      var mo = new MutationObserver(function(){ attachIcon(); });
      mo.observe(card, { childList:true, subtree:true });
    }
    ['renderAll','recalcSummary','updateCurrentOwnerData','saveState','hardRefresh','renderKPIs','renderTable']
    .forEach(function(name){
      if (window[name] && typeof window[name] === 'function'){
        var orig = window[name];
        window[name] = function(){
          var r = orig.apply(this, arguments);
          try{ attachIcon(); }catch(_){}
          return r;
        };
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(init, 0); });
  } else {
    setTimeout(init, 0);
  }
})();
</script>
<script>
// ALL YEARS TARGET WIDGET
(function(){
  function formatNumber(num) {
    if (num >= 1000000) return Math.round(num / 1000000) + 'M';
    if (num >= 1000) return Math.round(num / 1000) + 'K';
    return num.toString();
  }

  function getMonthlyTargetsAndBalances() {
    const monthlyData = [];
    
    // Get the main table
    const table = document.querySelector('table tbody');
    if (!table) {
      console.log('Table not found');
      return monthlyData;
    }
    
    const rows = table.querySelectorAll('tr');
    console.log('Found table rows:', rows.length);
    
    rows.forEach((row, index) => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 11) {
        // Column 6 (index 5) = Target
        // Column 11 (index 10) = Balance
        const monthCell = cells[0]; // Month name
        const targetCell = cells[5]; // Target (column 6)
        const balanceCell = cells[10]; // Balance (column 11)
        
        if (monthCell && targetCell && balanceCell) {
          const month = monthCell.textContent.trim();
          const targetText = targetCell.textContent.trim().replace(/[^\d.-]/g, '');
          const balanceText = balanceCell.textContent.trim().replace(/[^\d.-]/g, '');
          
          const target = parseFloat(targetText) || 0;
          const balance = parseFloat(balanceText) || 0;
          
          if (target !== 0 || balance !== 0) {
            monthlyData.push({
              month: month,
              target: target,
              balance: balance
            });
          }
        }
      }
    });
    
    console.log('Monthly targets and balances:', monthlyData);
    return monthlyData;
  }

  function updateAllYearsWidget() {
    const content = document.getElementById('allYearsContent');
    const counter = document.getElementById('targetCounter');
    if (!content) return;
    
    const monthlyData = getMonthlyTargetsAndBalances();
    
    // Count only targets that have actual values (greater than 0)
    const actualTargetCount = monthlyData.filter(function(item) {
      return item.target && item.target > 0;
    }).length;
    
    // Update counter with number of actual targets
    if (counter) {
      counter.textContent = actualTargetCount;
    }
    
    if (monthlyData.length === 0) {
      content.innerHTML = '<div style="color: #666; text-align: center; font-size: 11px; padding: 10px;">No data available</div>';
      return;
    }
    
    content.innerHTML = monthlyData.map(function(data) {
  const month = data.month;
  const target = data.target;
  const balance = data.balance;
  const balanceColor = balance >= 0 ? '#2E8B57' : '#d46b6b';
  const balancePrefix = balance < 0 ? '-' : '';
  return '<div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 12px; line-height: 1.3;">' +
         '<div style="flex: 0 0 30px; font-weight: bold; color: #4a8d85;">' + month + '</div>' +
         '<div style="flex: 1; text-align: center; padding: 0 4px;">Target ' + target.toLocaleString() + '</div>' +
         '<div style="flex: 1; text-align: right; color: ' + balanceColor + ';">Balance ' + (balance < 0 ? '-' : '') + Math.abs(balance).toLocaleString() + '</div>' +
         '</div>';
}).join('');
  }

  // Toggle dropdown function
  window.toggleAllYearsDropdown = function() {
    const content = document.getElementById('allYearsContent');
    const arrow = document.getElementById('dropdownArrow');
    
    if (content.style.display === 'none' || content.style.display === '') {
      content.style.display = 'block';
      arrow.textContent = '▲';
      updateAllYearsWidget(); // Update when opening
    } else {
      content.style.display = 'none';
      arrow.textContent = '▼';
    }
  };

  // Update immediately and set up intervals
  function init() {
    console.log('All Years Widget - Initializing...');
    
    // Initial update (but keep dropdown closed)
    setTimeout(updateAllYearsWidget, 1000);
    
    // Update every 5 seconds if dropdown is open
    setInterval(() => {
      const content = document.getElementById('allYearsContent');
      if (content && content.style.display === 'block') {
        updateAllYearsWidget();
      }
    }, 5000);
    
    // Hook into existing functions if available
    const functionsToHook = ['renderAll', 'updateCurrentOwnerData', 'saveState', 'recalcSummary', 'renderTable', 'hardRefresh'];
    
    functionsToHook.forEach(funcName => {
      if (window[funcName] && typeof window[funcName] === 'function') {
        const original = window[funcName];
        window[funcName] = function() {
          const result = original.apply(this, arguments);
          setTimeout(() => {
            const content = document.getElementById('allYearsContent');
            if (content && content.style.display === 'block') {
              updateAllYearsWidget();
            }
          }, 200);
          return result;
        };
      }
    });
    
    console.log('All Years Widget - Initialization complete');
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    setTimeout(init, 500);
  }
})();
</script>
<!-- Cache bust: 09/01/2025 14:03:15 -->
<!-- partial -->
<style id="cheque-reminder-style">
  .cheque-reminder-wrap{display:inline-flex;align-items:center;gap:6px;margin-left:8px;position:relative;z-index:2147483646;pointer-events:auto}
  .cheq-btn{background:rgba(255,255,255,.9);backdrop-filter:saturate(120%) blur(2px);color:var(--accent,#2a8a7b);border:1px solid rgba(74,141,133,0.25);padding:6px 10px;border-radius:999px;font-size: 13px;cursor:pointer;white-space:nowrap}
  .cheq-btn:hover{box-shadow:0 6px 16px rgba(74,141,133,.2);transform:translateY(-1px)}
  .cheq-btn.danger{border-color:#e57373;color:#b71c1c;background:#fff5f5}
  .cheq-pop{position:fixed;z-index:2147483647;background:var(--card,#fff);border:1px solid rgba(0,0,0,.08);box-shadow:0 16px 38px rgba(10,40,80,.22);border-radius:12px;padding:12px;display:none;width:340px}
  .cheq-pop.visible{display:block}
  .cheq-row{display:grid;grid-template-columns:1fr;gap:8px;margin-top:6px}
  .cheq-pop label{font-size: 13px;color:var(--muted,#666);font-weight:600}
  .cheq-pop input[type="date"],.cheq-pop input[type="time"],.cheq-pop input[type="text"],.cheq-pop input[type="number"]{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #dfe7e4;font-size: 14px;background:rgba(255,255,255,.96)}
  .cheq-actions{display:flex;gap:6px;justify-content:space-between;margin-top:6px;flex-wrap:wrap}
  .cheq-actions .cheq-btn{font-size: 13px;padding:6px 10px}
  .cheq-amt{font-weight:700;color:var(--orange-red-flag,#d65);font-size: 14px}
  .cheq-duebadge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:linear-gradient(90deg,#fff6f6,#fff1f1);border:1px solid rgba(212,107,107,.25);font-size: 12px;color:#a94442;user-select:none}
  .cheq-ring{font-size: 15px}
  .cheq-toast{position:fixed;top:80px;right:20px;z-index:2147483647;background:#0d9488;color:#fff;padding:10px 14px;border-radius:10px;box-shadow:0 10px 26px rgba(0,0,0,.25);display:none}
  .cheq-toast.show{display:block}
  .cheq-fab{position:fixed;right:18px;bottom:20px;z-index:2147483646;pointer-events:auto}
  .cheq-note{font-size: 12px;color:#777}
  .cheq-row .cheq-toggle{display:flex;align-items:center;gap:8px;font-size: 13px}
  .cheq-row .cheq-toggle input{width:auto}
</style>
<script id="cheque-reminder-script">
(function(){
  const CHEQ = {
    key(){
      const owner = (window.currentOwner || document.querySelector('.owner-name')?.textContent || 'Owner');
      const year = (typeof window.getSelectedYear === 'function') ? window.getSelectedYear() : (new Date().getFullYear());
      return `chequeReminder:${owner}:${year}`;
    },
    load(){ try { return JSON.parse(localStorage.getItem(CHEQ.key())||'{}'); } catch(e){ return {}; } },
    save(obj){ try { localStorage.setItem(CHEQ.key(), JSON.stringify(obj||{})); } catch(e){} },
    remove(){ try { localStorage.removeItem(CHEQ.key()); } catch(e){} },
    getNextNeededAmount(){
      try{
        if (typeof window.findNextNeededMonth === 'function'){
          const nn = window.findNextNeededMonth();
          if (nn && typeof nn.needed === 'number') return nn.needed;
        }
      }catch(e){}
      try{
        const el = Array.from(document.querySelectorAll('div,span,p,li,section,article'))
          .find(n=>/Next\s*Needed/i.test(n.textContent) && /\d/.test(n.textContent));
        if (el){
          const m = el.textContent.replace(/[, ]+/g,'').match(/(\d[\d\.]*)/);
          if (m) return Number(m[1]);
        }
      }catch(e){}
      return null;
    },
    fmt(n){ if (n==null || isNaN(n)) return 'AED 0'; try { return 'AED ' + Number(n).toLocaleString(); } catch(e){ return 'AED ' + n; } },
    dmy(date){ try{ const d = new Date(date); return String(d.getDate()).padStart(2,'0')+'/'+String(d.getMonth()+1).padStart(2,'0')+'/'+d.getFullYear(); }catch(e){ return ''; } },
    findAnchor(){
      let el = document.getElementById('nextText') 
            || document.querySelector('[data-role="next-needed-text"]')
            || document.querySelector('.next-needed-text');
      if (el) return el;
      const nodes = Array.from(document.querySelectorAll('h1,h2,h3,h4,p,div,span,button,strong'));
      const cand = nodes.find(n=>/^\s*Next\s*needed/i.test(n.textContent));
      if (cand) return cand;
      const mo = nodes.find(n=>/Mo\.\s*Needed\s*Inflow/i.test(n.textContent));
      if (mo) return mo;
      return null;
    },
    buildUI(root){
      if (!document.getElementById('cheqDueBadge')){
        const slot = document.getElementById('cheqMirrorSlot') || document.getElementById('kpiLabel_monthlyNeeded');
        if (slot){
          const badge = document.createElement('span');
          badge.id = 'cheqDueBadge';
          badge.className = 'cheq-duebadge';
          badge.style.display = 'none';
          badge.title = 'Right‑click to delete reminder';
          slot.appendChild(badge);
          badge.addEventListener('contextmenu', (e)=>{ e.preventDefault(); CHEQ.deleteAction(); });
        }
      }
      if (!document.getElementById('cheqFab')){
        const fab = document.createElement('div');
        fab.id = 'cheqFab'; fab.className='cheq-fab';
        const fbtn = document.createElement('button'); fbtn.className='cheq-btn'; fbtn.textContent='🔔 Cheque';
        fab.appendChild(fbtn); document.body.appendChild(fab);
        fbtn.addEventListener('click', ()=>CHEQ.open('fab'));
      }
      if (!document.getElementById('cheqPop')){
        const pop = document.createElement('div'); pop.className='cheq-pop'; pop.id='cheqPop';
        pop.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
            <strong>Cheque Reminder</strong>
            <button class="cheq-btn" id="cheqClose" aria-label="Close">✕</button>
          </div>
          <div class="cheq-row">
            <div>
              <label>Deposit date & time</label>
              <div style="display:flex;gap:6px;">
                <input type="date" id="cheqDate"/>
                <input type="time" id="cheqTime" value="09:00"/>
              </div>
            </div>
            <div>
              <label>Amount</label>
              <input type="number" id="cheqAmount" min="0" step="1" placeholder="AED amount"/>
              <div class="cheq-amt" id="cheqAmtHint"></div>
            </div>
            <div>
              <label>Note (optional)</label>
              <input type="text" id="cheqNote" placeholder="e.g., Aug deposits at ENBD Mirdif"/>
            </div>
          </div>
          <div class="cheq-actions">
            <button class="cheq-btn" id="cheqSave">Save</button>
            <button class="cheq-btn" id="cheqDone">Done ✅</button>
            <button class="cheq-btn" id="cheqShare">Share</button>
            <button class="cheq-btn" id="cheqCopy">Copy</button>
            <input id="cheqGuests" type="text" placeholder="Guests: name@company.com, other@company.com" style="flex:1;min-width:200px;padding:6px 8px;border:1px solid #ddd;border-radius:8px;" />
<button class="cheq-btn" id="cheqGCal" title="Share via Calendar (opens Google Calendar with guests)">📆 Share via Calendar</button>
<button class="cheq-btn danger" id="cheqDelete">Delete 🗑️</button>
          </div>
        `;
        document.body.appendChild(pop);
        // toast
        let toast = document.getElementById('cheqToast');
        if (!toast){ toast = document.createElement('div'); toast.id='cheqToast'; toast.className='cheq-toast'; document.body.appendChild(toast); }
        // events
        document.getElementById('cheqClose').addEventListener('click', CHEQ.close);
        document.getElementById('cheqSave').addEventListener('click', CHEQ.saveAction);
        document.getElementById('cheqDone').addEventListener('click', CHEQ.markDone);
        document.getElementById('cheqShare').addEventListener('click', CHEQ.shareAction);
        document.getElementById('cheqCopy').addEventListener('click', CHEQ.copyAction);
        document.getElementById('cheqDelete').addEventListener('click', CHEQ.deleteAction);
                            (function(){var g=document.getElementById('cheqGCal'); if(g){ g.addEventListener('click', CHEQ.openGoogleCalendar); }})();
      (function(){var g=document.getElementById('cheqGCal'); if(g){ g.addEventListener('click', CHEQ.openGoogleCalendar); }})();
      (function(){var g=document.getElementById('cheqGCal'); if(g){ g.addEventListener('click', CHEQ.openGoogleCalendar); }})();
      }
      CHEQ.prefill(); CHEQ.refreshBadge(); (function(){try{var slot=document.getElementById('cheqMirrorSlot')||document.getElementById('kpiLabel_monthlyNeeded'); if(slot && !document.getElementById('cheqDueBadge')){var b=document.createElement('span'); b.id='cheqDueBadge'; b.className='cheq-duebadge'; b.style.display='none'; b.title='Right‑click to delete reminder'; slot.appendChild(b); b.addEventListener('contextmenu', function(e){e.preventDefault(); CHEQ.deleteAction();}); CHEQ.refreshBadge(); }}catch(e){}})();
    },
    prefill(){
      const s = CHEQ.load();
      const hint = (CHEQ.getMonthlyNeededAmount ? CHEQ.getMonthlyNeededAmount() : null);
      const hintEl = document.getElementById('cheqAmtHint');
      const amtEl  = document.getElementById('cheqAmount');
      if (hintEl){
        if (hint!=null){ hintEl.textContent = 'Hint from 📊 Mo. Needed Inflow To End of the Year — remains: ' + CHEQ.fmt(hint); if(!s.amount) amtEl.value = Math.round(hint); }
        else { hintEl.textContent = 'Enter cheque amount manually'; }
      }
      if (s.dueISO){
        const [d,t] = s.dueISO.split('T');
        const dEl=document.getElementById('cheqDate'); const tEl=document.getElementById('cheqTime');
        if (dEl) dEl.value = d || ''; if (tEl) tEl.value = (t||'09:00').slice(0,5);
      }
      if (s.amount && amtEl){ amtEl.value = s.amount; } else if (amtEl && (hint!=null)) { amtEl.value = Math.round(hint); }
      const noteEl = document.getElementById('cheqNote'); if (s.note && noteEl) noteEl.value = s.note;
    },
    open(where){
      const pop = document.getElementById('cheqPop'); if (!pop) return;
      let x = window.innerWidth - 380; let y = window.innerHeight - 320;
      if (where === 'anchor'){
        const anc = document.getElementById('cheque-reminder-anchor');
        if (anc){
          const r = anc.getBoundingClientRect();
          x = Math.min(r.left, window.innerWidth-360); y = r.bottom + 8 + window.scrollY;
        }
      } else if (where === 'fab'){
        const fab = document.getElementById('cheqFab');
        if (fab){
          const r = fab.getBoundingClientRect();
          x = Math.min(r.left-350, window.innerWidth-360); y = r.top - 340 + window.scrollY;
        }
      }
      pop.style.left = Math.max(8, x) + 'px'; 
      pop.style.top  = Math.max(8, y) + 'px'; 
      pop.classList.add('visible');
      CHEQ.prefill();
    },
    close(){ const pop = document.getElementById('cheqPop'); if (pop) pop.classList.remove('visible'); },
    refreshBadge(){
      const s = CHEQ.load(); const badge = document.getElementById('cheqDueBadge');
      if (!badge) return;
      if (!s.dueISO){ badge.style.display='none'; return; }
      badge.innerHTML = `<span class="cheq-ring">🔔</span><span>${CHEQ.dmy(new Date(s.dueISO))}</span><span>•</span><span>${CHEQ.fmt(s.amount)}</span>`;
      badge.style.display='inline-flex';
    },
    
    openGoogleCalendar(){
      try {
        const s = CHEQ.load();
        const dateEl = document.getElementById('cheqDate');
        const timeEl = document.getElementById('cheqTime');
        const amtEl  = document.getElementById('cheqAmount');
        const noteEl = document.getElementById('cheqNote');
        const guestsEl = document.getElementById('cheqGuests');
        const d = (dateEl?.value || s.dueISO?.split('T')[0] || '').trim();
        const t = (timeEl?.value || (s.dueISO?.split('T')[1]||'09:00').slice(0,5) || '09:00').trim();
        const amt = Number((amtEl?.value || s.amount || 0));
        const note = (noteEl?.value || s.note || '').trim();
        if (!d){ return CHEQ.toast('Please set a deposit date first'); }
        // Local -> UTC
        const local = new Date(d + 'T' + (t||'09:00') + ':00');
        const startUTC = new Date(local.getTime() - local.getTimezoneOffset()*60000);
        const endUTC   = new Date(startUTC.getTime() + 30*60000);
        function fmt(dt){ const y=dt.getUTCFullYear(); const m=String(dt.getUTCMonth()+1).padStart(2,'0'); const da=String(dt.getUTCDate()).padStart(2,'0'); const h=String(dt.getUTCHours()).padStart(2,'0'); const mi=String(dt.getUTCMinutes()).padStart(2,'0'); const s=String(dt.getUTCSeconds()).padStart(2,'0'); return `${y}${m}${da}T${h}${mi}${s}Z`; }
        const dtstart = fmt(startUTC), dtend = fmt(endUTC);
        const text = encodeURIComponent(`Cheque deposit ${isFinite(amt)&&amt>0 ? '– '+CHEQ.fmt(amt)+' AED' : ''}`.trim());
        const details = encodeURIComponent(note || 'Cheque deposit reminder');
        let addParam = '';
        if (guestsEl && guestsEl.value.trim()){
          const emails = guestsEl.value.split(/[,\s;]+/).map(e=>e.trim()).filter(e=>e && e.includes('@'));
          if (emails.length){ addParam = '&add=' + emails.map(encodeURIComponent).join(','); }
        }
        const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${text}&dates=${dtstart}/${dtend}&details=${details}${addParam}`;
        let w = window.open(url, '_blank');
        if(!w){
          const a=document.createElement('a'); a.href=url; a.target='_blank'; a.rel='noopener';
          document.body.appendChild(a); a.click(); a.remove();
        }
        CHEQ.toast('Opening Google Calendar...');
      } catch(e){
        console.error(e); CHEQ.toast('Could not open Google Calendar');
      }
    },
    saveAction(){
      const dateEl = document.getElementById('cheqDate'), timeEl=document.getElementById('cheqTime'), amtEl=document.getElementById('cheqAmount'), noteEl=document.getElementById('cheqNote');
      const date = dateEl?.value, time = (timeEl?.value||'09:00'); const amount = Number(amtEl?.value||0); const note=(noteEl?.value||'').trim();
      if (!date){ return CHEQ.toast('Please set a deposit date'); }
      if (isNaN(amount) || amount<=0){ return CHEQ.toast('Please set a positive amount'); }
      CHEQ.save({ dueISO: `${date}T${time}`, amount, note, done:false, savedAt: new Date().toISOString() });
      CHEQ.refreshBadge(); CHEQ.close(); CHEQ.toast('Cheque reminder saved.');
    },
    markDone(){ const s = CHEQ.load()||{}; s.done=true; s.completedAt=new Date().toISOString(); CHEQ.save(s); CHEQ.refreshBadge(); CHEQ.toast('Marked as done. Notifications stopped.'); CHEQ.close(); },
    deleteAction(){
      CHEQ.remove(); CHEQ.refreshBadge(); CHEQ.close(); CHEQ.toast('Cheque reminder deleted.');
    },
    shareText(){ const s = CHEQ.load()||{}; const owner = (window.currentOwner || 'Owner'); const year = (typeof window.getSelectedYear === 'function')? window.getSelectedYear(): (new Date().getFullYear()); const dueStr = s.dueISO? CHEQ.dmy(new Date(s.dueISO)) : '(unset)'; const note = s.note? `\nNote: ${s.note}` : ''; return `Cheque deposit reminder — ${owner} — ${year}\nDue: ${dueStr}\nAmount: ${CHEQ.fmt(s.amount)}${note}`; },
    shareAction(){ const text = CHEQ.shareText(); if (navigator.share){ navigator.share({text}).catch(()=>{}); } else { window.open('https://wa.me/?text='+encodeURIComponent(text),'_blank','noopener'); } },
    copyAction(){
      const text = CHEQ.shareText();
      if (navigator.clipboard){ navigator.clipboard.writeText(text).then(()=>CHEQ.toast('Copied to clipboard.')).catch(()=>{}); }
      else { const ta = document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); CHEQ.toast('Copied to clipboard.'); }catch(e){} document.body.removeChild(ta); }
    },
    toast(msg){ let t=document.getElementById('cheqToast'); if(!t){ t=document.createElement('div'); t.id='cheqToast'; t.className='cheq-toast'; document.body.appendChild(t);} t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2300); },
    notifyLoop(){
      const s = CHEQ.load()||{}; if (!s.dueISO || s.done) return;
      const due = new Date(s.dueISO).getTime(); const now = Date.now();
      if (now >= due){
        const last = Number(s._lastN||0);
        if (now - last > 120000){
          CHEQ.toast('🔔 Cheque deposit due now');
          if ('Notification' in window && Notification.permission==='granted'){ try{ new Notification('Cheque deposit due now', { body: CHEQ.shareText() }); }catch(e){} }
          s._lastN = Date.now(); CHEQ.save(s);
        }
      }
    }
  };
  document.addEventListener('DOMContentLoaded', function(){
    try{
      const root = CHEQ.findAnchor();
      CHEQ.buildUI(root);
      // Retry a few times in case the app renders late
      let tries = 0; const anch = setInterval(()=>{ if (document.getElementById('cheque-reminder-anchor')){ clearInterval(anch); } else if (tries++ < 40){ const r = CHEQ.findAnchor(); if (r) CHEQ.buildUI(r); } else { clearInterval(anch); } }, 500);
      setInterval(CHEQ.notifyLoop, 30000);
      window.refreshChequeReminderUI = ()=>{ const r = CHEQ.findAnchor(); CHEQ.buildUI(r); CHEQ.refreshBadge(); };
    }catch(e){}
  });
})();
</script>
<style id="cheque-reminder-align-tweak">
  #kpiLabel_monthlyNeeded{ display:flex !important; align-items:center !important; gap:6px !important; }
  #kpiLabel_monthlyNeeded #cheqMirrorSlot{ margin-left:auto !important; padding-left:8px !important; }
</style>
<!-- BEGIN: Cheque Reminder — HARD ISOLATION PATCH (owner/year scoped) -->
<script>
(function () {
  function getOwnerId(){
    try {
      const sel = document.getElementById('ownerSelect');
      if (sel && sel.value !== undefined && sel.value !== null && sel.value !== '') return String(sel.value);
      if (typeof window.currentOwner !== 'undefined') return String(window.currentOwner);
    } catch(e){}
    return 'owner0';
  }
  function getYearVal(){
    try {
      if (typeof window.getSelectedYear === 'function') return Number(window.getSelectedYear());
      const y = document.getElementById('yearInput');
      if (y && y.value) return Number(y.value);
      if (typeof window.currentYear !== 'undefined') return Number(window.currentYear);
    } catch(e){}
    return (new Date()).getFullYear();
  }

  // ✅ New canonical key (matches your app’s namespace)
  function storageKey(){
    return `performanceTracker:${getOwnerId()}:year_${getYearVal()}:reminders`;
  }
  window.__CHEQ_storageKey = storageKey; // handy for debugging

  // 🔁 Migration: move any old keys into the new per-owner/year bucket
  (function migrateOld(){
    try {
      const oldKey = `chequeReminder:${getOwnerId()}:${getYearVal()}`;
      const legacy1 = localStorage.getItem(oldKey);
      const legacy2 = localStorage.getItem('chequeReminder');   // very old
      const legacy3 = localStorage.getItem('cheq:reminder');    // very old

      const targetKey = storageKey();

      if (legacy1 && !localStorage.getItem(targetKey)) {
        localStorage.setItem(targetKey, legacy1);
      } else if (legacy2 && !localStorage.getItem(targetKey)) {
        localStorage.setItem(targetKey, legacy2);
      } else if (legacy3 && !localStorage.getItem(targetKey)) {
        localStorage.setItem(targetKey, legacy3);
      }

      // Clean up legacy keys to avoid future confusion
      localStorage.removeItem(oldKey);
      localStorage.removeItem('chequeReminder');
      localStorage.removeItem('cheq:reminder');
    } catch(e){}
  })();

  // Ensure CHEQ namespace exists
  window.CHEQ = window.CHEQ || {};

  // 🔒 Override persistence helpers to use the new isolated key
  window.CHEQ.load = function(){
    try { const raw = localStorage.getItem(storageKey()); return raw ? JSON.parse(raw) : null; }
    catch(e){ return null; }
  };
  window.CHEQ.save = function(state){
    try { localStorage.setItem(storageKey(), JSON.stringify(state || {})); } catch(e){}
    try {
      if (typeof window.CHEQ.refreshBadge === 'function') setTimeout(window.CHEQ.refreshBadge, 0);
      if (typeof window.refreshChequeReminderUI === 'function') setTimeout(window.refreshChequeReminderUI, 0);
    } catch(e){}
  };
  window.CHEQ.remove = function(){
    try { localStorage.removeItem(storageKey()); } catch(e){}
    try {
      if (typeof window.CHEQ.refreshBadge === 'function') setTimeout(window.CHEQ.refreshBadge, 0);
      if (typeof window.refreshChequeReminderUI === 'function') setTimeout(window.refreshChequeReminderUI, 0);
    } catch(e){}
  };

  // Ensure UI refreshes when owner/year changes
  (function hookRefreshers(){
    try {
      const sel = document.getElementById('ownerSelect');
      if (sel && !sel.__cheqHooked){
        sel.__cheqHooked = true;
        sel.addEventListener('change', () => {
          setTimeout(() => {
            if (typeof window.CHEQ.refreshBadge === 'function') window.CHEQ.refreshBadge();
            if (typeof window.refreshChequeReminderUI === 'function') window.refreshChequeReminderUI();
          }, 0);
        });
      }
      const y = document.getElementById('yearInput');
      if (y && !y.__cheqHooked){
        y.__cheqHooked = true;
        y.addEventListener('change', () => {
          setTimeout(() => {
            if (typeof window.CHEQ.refreshBadge === 'function') window.CHEQ.refreshBadge();
            if (typeof window.refreshChequeReminderUI === 'function') window.refreshChequeReminderUI();
          }, 0);
        });
      }
    } catch(e){}
  })();
})();
</script>
<!-- END: Cheque Reminder — HARD ISOLATION PATCH -->
<!-- BEGIN: Cheque Dark Enforcer (CSS + JS) -->
<style id="cheqDarkPatch">
/* Put this at the very end to win the cascade */
:is(#cheqPop, .cheq-pop) {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 34px rgba(0,0,0,0.7) !important;
}
:is(#cheqPop, .cheq-pop) * { color: #fff !important; }

/* Inputs inside popup */
:is(#cheqPop, .cheq-pop) input[type="text"],
:is(#cheqPop, .cheq-pop) input[type="number"],
:is(#cheqPop, .cheq-pop) input[type="date"],
:is(#cheqPop, .cheq-pop) input[type="time"],
:is(#cheqPop, .cheq-pop) select,
:is(#cheqPop, .cheq-pop) textarea {
  background: #111 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.28) !important;
  border-radius: 8px !important;
}
:is(#cheqPop, .cheq-pop) input::placeholder,
:is(#cheqPop, .cheq-pop) textarea::placeholder { color: #cfcfcf !important; }

/* Buttons */
:is(#cheqPop, .cheq-pop) .cheq-btn {
  background: #222 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 8px !important;
}
:is(#cheqPop, .cheq-pop) .cheq-btn:hover { background: #333 !important; }
:is(#cheqPop, .cheq-pop) .cheq-btn.danger { background: #3a0d0d !important; border-color: #7f1d1d !important; }

/* Toast */
.cheq-toast {
  background: rgba(0,0,0,0.94) !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  border-radius: 10px !important;
}
</style>
<script>
(function enforceChequeDark(){
  function apply(el){
    if(!el) return;
    el.style.background = '#000';
    el.style.color = '#fff';
    el.style.border = '1px solid rgba(255,255,255,0.25)';
    el.style.borderRadius = '12px';
    el.style.boxShadow = '0 10px 34px rgba(0,0,0,0.7)';
    // inputs/buttons inside
    el.querySelectorAll('input, select, textarea').forEach(function(inp){
      inp.style.background = '#111';
      inp.style.color = '#fff';
      inp.style.border = '1px solid rgba(255,255,255,0.28)';
      inp.style.borderRadius = '8px';
    });
    el.querySelectorAll('.cheq-btn').forEach(function(btn){
      btn.style.background = '#222';
      btn.style.color = '#fff';
      btn.style.border = '1px solid rgba(255,255,255,0.25)';
      btn.style.borderRadius = '8px';
    });
  }
  function run(){
    var el = document.getElementById('cheqPop') || document.querySelector('.cheq-pop');
    if (el) apply(el);
  }
  // Run now, on open, and on mutations
  document.addEventListener('DOMContentLoaded', run);
  window.addEventListener('load', run);
  setInterval(run, 300); // very light; stops itself when closed
  // Also observe body to catch creation
  try {
    var obs = new MutationObserver(run);
    obs.observe(document.body, {childList:true, subtree:true});
  } catch(e){}
})();
</script>
<!-- END: Cheque Dark Enforcer (CSS + JS) -->
<!-- BEGIN: Next Target Dark Enforcer (CSS + JS) -->
<style id="nextTargetDarkPatch">
#nextTargetModal, .next-target-modal, #projectModal {
  background: #000 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 34px rgba(0,0,0,0.7) !important;
}
#nextTargetModal *, .next-target-modal *, #projectModal * {
  color: #fff !important;
}
#nextTargetModal input, .next-target-modal input, #projectModal input,
#nextTargetModal select, .next-target-modal select, #projectModal select,
#nextTargetModal textarea, .next-target-modal textarea, #projectModal textarea {
  background: #111 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 8px !important;
}
#nextTargetModal button, .next-target-modal button, #projectModal button {
  background: #222 !important;
  color: #fff !important;
  border: 1px solid rgba(255,255,255,0.25) !important;
  border-radius: 8px !important;
}
#nextTargetModal button:hover, .next-target-modal button:hover, #projectModal button:hover {
  background: #333 !important;
}
</style>
<script>
(function enforceNextTargetDark(){
  function apply(el){
    if(!el) return;
    el.style.background = '#000';
    el.style.color = '#fff';
    el.style.border = '1px solid rgba(255,255,255,0.25)';
    el.style.borderRadius = '12px';
    el.style.boxShadow = '0 10px 34px rgba(0,0,0,0.7)';
    el.querySelectorAll('input, select, textarea').forEach(function(inp){
      inp.style.background = '#111';
      inp.style.color = '#fff';
      inp.style.border = '1px solid rgba(255,255,255,0.25)';
      inp.style.borderRadius = '8px';
    });
    el.querySelectorAll('button').forEach(function(btn){
      btn.style.background = '#222';
      btn.style.color = '#fff';
      btn.style.border = '1px solid rgba(255,255,255,0.25)';
      btn.style.borderRadius = '8px';
    });
  }
  function run(){
    var el = document.getElementById('nextTargetModal') ||
             document.querySelector('.next-target-modal') ||
             document.getElementById('projectModal');
    if(el) apply(el);
  }
  document.addEventListener('DOMContentLoaded', run);
  window.addEventListener('load', run);
  setInterval(run, 300);
  try {
    var obs = new MutationObserver(run);
    obs.observe(document.body, {childList:true, subtree:true});
  } catch(e){}
})();
</script>
<!-- END: Next Target Dark Enforcer -->
<!-- BEGIN: Next Targets Amount Green — Runtime Enforcer -->
<script>
(function nextTargetsAmtGreen(){
  function paint(root){
    try {
      var scope = root || document;
      scope.querySelectorAll('.next-target-card .ntc-row .amt').forEach(function(el){
        el.style.color = '#16a34a';
        el.style.fontWeight = '600';
      });
      // fallback: if next-target-card not present, try any card under #nextTargets
      var cont = document.getElementById('nextTargets') || document.getElementById('nextTargetsCard');
      if (cont){
        cont.querySelectorAll('.ntc-row .amt, .amt').forEach(function(el){
          el.style.color = '#16a34a';
          el.style.fontWeight = '600';
        });
      }
    } catch(e){}
  }
  function run(){ paint(); }
  document.addEventListener('DOMContentLoaded', run);
  window.addEventListener('load', run);
  // Observe mutations in case the list re-renders
  try {
    var target = document.getElementById('nextTargets') || document.body;
    var obs = new MutationObserver(function(mutations){
      for (var m of mutations){
        if (m.addedNodes && m.addedNodes.length) paint(m.target || document);
      }
    });
    obs.observe(target, {childList:true, subtree:true});
  } catch(e){}
  // Also repaint a few times as a safety net
  var n=0, t=setInterval(function(){ paint(); if(++n>8) clearInterval(t); }, 200);
})();
</script>
<!-- END: Next Targets Amount Green — Runtime Enforcer -->
<!-- BEGIN: Next Targets Corrector -->
<script>
(function nextTargetsCorrector(){
  function paint(){
    try{
      var card = document.getElementById('nextTargetCard');
      if (card){
        card.style.background = '#000';
        card.style.color = '#fff';
        card.style.border = '1px solid rgba(255,255,255,0.25)';
        card.style.borderRadius = '12px';
        card.querySelectorAll('.ntc-row .amt').forEach(function(el){
          el.style.color = '#16a34a';
          el.style.fontWeight = '600';
        });
        card.querySelectorAll('.ntc-row .acc').forEach(function(el){
          var v = (el.textContent||'').trim();
          if (v.startsWith('-')) { el.style.color = '#ef4444'; el.style.fontWeight = '700'; }
          else if (v==='0' || v==='0.00' || v==='' ) { el.style.color = '#aaa'; el.style.fontWeight = '600'; }
          else { el.style.color = '#16a34a'; el.style.fontWeight = '700'; }
        });
      }
    }catch(e){}
  }
  // Wrap the render function so our styles always re-apply after re-render
  try {
    var _orig = window.renderNextTargetMain;
    if (typeof _orig === 'function'){
      window.renderNextTargetMain = function(){
        try { _orig.apply(this, arguments); } finally { paint(); }
      };
      window.refreshNextTargetMain = window.renderNextTargetMain;
    }
  } catch(e){}
  document.addEventListener('DOMContentLoaded', paint);
  window.addEventListener('load', paint);
  // observe changes
  try {
    var obs = new MutationObserver(paint);
    obs.observe(document.body, {childList:true, subtree:true});
  } catch(e){}
  // retry loop
  (function loop(n){
    paint(); if(n<10) setTimeout(function(){ loop(n+1); }, 200);
  })(0);
})();
</script>
<!-- END: Next Targets Corrector -->
<style id="balance-override-strong-2025-09-14">
/* === FINAL OVERRIDE: Balance sign colouring === */
#kpiVal_rem.kpi-pos { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; font-weight:700 !important; }
#kpiVal_rem.kpi-neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; font-weight:700 !important; }
#kpiVal_rem.kpi-zero{ color: #6b7a7a !important; -webkit-text-fill-color: #6b7a7a !important; font-weight:700 !important; }

/* Next Targets list "Balance AED ..." (span.bal [+ .neg]) */
.ntc-row .bal { color: #1a7f37 !important; -webkit-text-fill-color: #1a7f37 !important; }
.ntc-row .bal.neg { color: #c62828 !important; -webkit-text-fill-color: #c62828 !important; }
</style><script id="allYears_clickaway_close_2025_09_14">
// Close the All Targets dropdown when clicking outside it
(function(){
  function isOpen(el){
    if (!el) return false;
    const disp = (el.style && el.style.display) || '';
    // treat empty or 'block' as possibly open (we toggle from '' -> 'block')
    return disp === 'block' || (disp === '' && el.offsetParent !== null);
  }
  function closeDropdown(){
    var content = document.getElementById('allYearsContent');
    var arrow = document.getElementById('dropdownArrow');
    if (!content) return;
    content.style.display = 'none';
    if (arrow) arrow.textContent = '▼';
  }
  function setup(){
    var content = document.getElementById('allYearsContent');
    if (!content) return;
    // Prevent clicks inside the dropdown from bubbling to document
    try{ content.addEventListener('click', function(e){ e.stopPropagation(); }, {capture:false}); }catch(_){}
    // Click-away on document
    try{
      document.addEventListener('click', function(e){
        var content = document.getElementById('allYearsContent');
        if (!content) return;
        // If not open, ignore
        if (!isOpen(content)) return;
        var container = content.parentElement || null;
        var header = container ? container.firstElementChild : null; // the chip row with 🎯 2 ▼
        // If click target is inside dropdown OR header, do nothing
        if ((content.contains(e.target)) || (header && header.contains(e.target))) return;
        // Otherwise, close
        closeDropdown();
      }, {capture:false});
    }catch(_){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setup);
  else setup();
})();
</script><script id="observer-kill-duplicates">
(function(){
  function norm(t){ return (t||'').replace(/\s+/g,' ').trim().toLowerCase(); }
  function looksLikeAction(el){
    const t = norm(el.textContent);
    return t === 'pdf' || t === 'print' || t === 'report' || t === 'generate report';
  }
  function inToolbar(el){
    const tb = document.getElementById('topToolbar');
    return !!(tb && tb.contains(el));
  }
  function purge(){
    const chartAreas = document.querySelectorAll('#chartCard, #chartWrapper, .headerTop, .headerTopFull, header');
    chartAreas.forEach(area=>{
      if(!area) return;
      area.querySelectorAll('button, a').forEach(el=>{
        const id = (el.id||'').toLowerCase();
        if (id === 'btnexportpdf' || id === 'btngeneratereport' || id === 'btnprint'){
          if (!inToolbar(el)){ try{ el.remove(); }catch(_){} }
          return;
        }
        if (looksLikeAction(el) && !inToolbar(el)){ try{ el.remove(); }catch(_){} }
      });
    });
    ['btnExportPDF','btnGenerateReport','btnPrint'].forEach(id=>{
      const nodes = Array.from(document.querySelectorAll('#'+id));
      if (nodes.length <= 1) return;
      const tb = document.getElementById('topToolbar');
      nodes.forEach(n=>{ if (!(tb && tb.contains(n))) { try{ n.remove(); }catch(_){}} });
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', purge);
  } else {
    purge();
  }
  try{
    const mo = new MutationObserver(()=> purge());
    mo.observe(document.documentElement, {childList:true, subtree:true});
  }catch(_){}
})();
</script><script id="kill-nextcards">
(function(){
  function nuke(){
    try{ var a = document.getElementById('nextTargetCard'); if (a) a.remove(); }catch(_){}
    try{ var b = document.getElementById('nextYearTargetCard'); if (b) b.remove(); }catch(_){}
    try{ document.querySelectorAll('.next-target-card').forEach(function(n){ n.remove(); }); }catch(_){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', nuke);
  } else { nuke(); }
  try{
    var mo = new MutationObserver(nuke);
    mo.observe(document.documentElement, {childList:true, subtree:true});
  }catch(_){}
})();
</script><script id="kill-inserted-color-ui">
(function(){
  function purge(){
    try{
      var ids = ['btnColorPlay','colorPlayBtn','colorPop'];
      ids.forEach(function(id){
        var n = document.getElementById(id);
        if (n) n.remove();
      });
      document.querySelectorAll('.color-pop,[aria-label*="Color" i],input[type="color"]').forEach(function(n){
        try{ n.remove(); }catch(_){}
      });
    }catch(_){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', purge);
  } else { purge(); }
  try{
    var mo = new MutationObserver(purge);
    mo.observe(document.documentElement, {childList:true, subtree:true});
  }catch(_){}
})();
</script><script id="wire-hard-refresh">
(function(){
  function hardReload(){ try{ location.reload(); }catch(_){ location.href = location.href; } }
  function softRefresh(){ try{ if (window.refreshUI) { window.refreshUI(); return true; } }catch(_){ } return false; }
  document.addEventListener('click', function(e){
    var btn = e.target.closest && e.target.closest('#btnHardRefresh');
    if (!btn) return;
    if (!softRefresh()) { hardReload(); }
  });
})();
</script><script id="share-icon-robust-injector">
(function(){
  function ensureShareIcon(){
    try{
      var card = document.getElementById('generalNotesCard');
      if (!card) return;
      // The header is the first flex row inside the card
      var header = card.querySelector('div');
      if (!header) return;
      // If an icon already exists, normalize its classes/title/text and return
      var existing = header.querySelector('.share-icon');
      if (!existing){
        var icon = document.createElement('span');
        icon.className = 'share-icon';
        icon.title = 'Share general notes';
        icon.textContent = '↗';
        icon.style.cursor = 'pointer';
        // Place it at the far right of the header row
        header.appendChild(icon);
        existing = icon;
      }
      // Wire click (idempotent)
      if (!existing.__wired){
        existing.addEventListener('click', function(){
          try{
            var txt = (document.getElementById('generalNotes')?.value || '').trim();
            var owner = (document.getElementById('ownerSelect')?.value || '—');
            var year  = (document.getElementById('yearInput')?.value || '—');
            var prefix = 'General Notes ('+owner+' • '+year+'): ';
            var payload = (txt ? prefix + txt : prefix + '(empty)');
            if (navigator.share){
              navigator.share({ text: payload }).catch(function(){});
            } else {
              navigator.clipboard && navigator.clipboard.writeText(payload).catch(function(){});
              alert('Copied notes to clipboard.');
            }
          }catch(_){}
        });
        existing.__wired = true;
      }
    }catch(_){}
  }
  // Run now
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureShareIcon);
  } else { ensureShareIcon(); }
  // Re-run when the card subtree changes (e.g., after any "refreshUI")
  if (window.MutationObserver){
    var cardMo = new MutationObserver(ensureShareIcon);
    var card = document.getElementById('generalNotesCard');
    if (card) cardMo.observe(card, {childList:true, subtree:true});
    // Also observe body in case the card is re-rendered
    var bodyMo = new MutationObserver(ensureShareIcon);
    bodyMo.observe(document.documentElement, {childList:true, subtree:true});
  }
  // Re-run after a short delay (covers async renderers)
  setTimeout(ensureShareIcon, 300);
  setTimeout(ensureShareIcon, 800);
})();
</script><script id="share-normalize-and-popover-black">
(function(){
  function isShareBtn(el){
    if (!el) return false;
    var label = (el.getAttribute('aria-label')||'').toLowerCase();
    var title = (el.getAttribute('title')||'').toLowerCase();
    var txt = (el.textContent||'').trim().toLowerCase();
    return label.includes('share') || title.includes('share') || txt === 'share';
  }
  function normalizeShare(){
    try{
      var tb = document.getElementById('topToolbar');
      if (!tb) return;
      var btn = tb.querySelector('#btnShare, .btn-share, [aria-label*="Share" i], [title*="Share" i]');
      if (!btn) return;
      // Remove accent/green classes and inline fills
      ['accent','success','green','primary'].forEach(function(c){ try{ btn.classList.remove(c); }catch(_){} });
      btn.style.color = 'var(--text)';
      // normalize icon colors
      btn.querySelectorAll('svg').forEach(function(svg){
        svg.style.fill = 'currentColor';
        svg.style.stroke = 'currentColor';
      });
      btn.dataset.role = btn.dataset.role || 'toolbar-share';
      // When clicked, re-style any resulting popover to black
      btn.addEventListener('click', function(){
        setTimeout(styleOpenMenus, 30);
        setTimeout(styleOpenMenus, 150);
        setTimeout(styleOpenMenus, 500);
      });
    }catch(_){}
  }
  function styleOpenMenus(){
    try{
      var candidates = Array.from(document.querySelectorAll('#shareActionPicker, .shareMenuWrapper, .shareMenu, .share-menu, .share-menu-wrapper'));
      candidates.forEach(function(c){
        if (!c) return;
        c.style.background = '#000';
        c.style.color = '#fff';
        c.style.border = '1px solid rgba(255,255,255,0.2)';
        // inner panel
        var inner = c.firstElementChild || c;
        if (inner && inner !== c){
          inner.style.background = '#000';
          inner.style.color = '#fff';
          inner.style.border = '1px solid rgba(255,255,255,0.2)';
          inner.style.boxShadow = '0 10px 28px rgba(0,0,0,0.7)';
        }
        // Buttons
        c.querySelectorAll('button, a').forEach(function(b){
          b.style.color = '#fff';
          b.style.background = 'transparent';
          b.style.borderColor = 'rgba(255,255,255,0.25)';
        });
      });
    }catch(_){}
  }
  function init(){
    normalizeShare();
    // Observe toolbar and body for re-renders
    if (window.MutationObserver){
      var mo1 = new MutationObserver(normalizeShare);
      var mo2 = new MutationObserver(styleOpenMenus);
      mo1.observe(document.getElementById('topToolbar')||document.documentElement, {childList:true, subtree:true});
      mo2.observe(document.documentElement, {childList:true, subtree:true});
    }
    // Safety retries
    setTimeout(normalizeShare, 200);
    setTimeout(normalizeShare, 600);
    setTimeout(styleOpenMenus, 400);
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script></body>
</html>
<!-- === Cheque Reminder: HARD ISOLATION PATCH (owner + year) === -->
<script id="cheq-hard-isolation-patch">
(function(){
  function getOwnerId(){
    try {
      var sel = document.getElementById('ownerSelect');
      if (sel && sel.value !== undefined && sel.value !== null && sel.value !== '') return String(sel.value);
      if (typeof window.currentOwner !== 'undefined') return String(window.currentOwner);
    } catch(e){}
    return 'owner0';
  }
  function getYearVal(){
    try {
      if (typeof window.getSelectedYear === 'function') return Number(window.getSelectedYear());
      var y = document.getElementById('yearInput');
      if (y && y.value) return Number(y.value);
      if (typeof window.currentYear !== 'undefined') return Number(window.currentYear);
    } catch(e){}
    return (new Date()).getFullYear();
  }
  function storageKey(){
    return "chequeReminder:" + getOwnerId() + ":" + getYearVal();
  }
  // expose for debugging
  window.__CHEQ_storageKey = storageKey;

  // Migrate/clean any legacy generic keys that could leak across owners/years
  try { localStorage.removeItem('chequeReminder'); } catch(e){}
  try { localStorage.removeItem('cheq:reminder'); } catch(e){}

  // Ensure CHEQ namespace exists
  window.CHEQ = window.CHEQ || {};

  // Override load/save/remove to be strictly owner+year scoped
  window.CHEQ.load = function(){
    try {
      var raw = localStorage.getItem(storageKey());
      return raw ? JSON.parse(raw) : null;
    } catch(e){ return null; }
  };
  window.CHEQ.save = function(state){
    try {
      localStorage.setItem(storageKey(), JSON.stringify(state || {}));
    } catch(e){}
    // Update UI if helper exists
    try {
      if (typeof window.CHEQ.refreshBadge === 'function') setTimeout(window.CHEQ.refreshBadge, 0);
      if (typeof window.refreshChequeReminderUI === 'function') setTimeout(window.refreshChequeReminderUI, 0);
    } catch(e){}
  };
  window.CHEQ.remove = function(){
    try { localStorage.removeItem(storageKey()); } catch(e){}
    try {
      if (typeof window.CHEQ.refreshBadge === 'function') setTimeout(window.CHEQ.refreshBadge, 0);
      if (typeof window.refreshChequeReminderUI === 'function') setTimeout(window.refreshChequeReminderUI, 0);
    } catch(e){}
  };

  // Refresh the reminder UI whenever owner or year changes
  function hookRefreshers(){
    try {
      var sel = document.getElementById('ownerSelect');
      if (sel && !sel.__cheqHooked){
        sel.addEventListener('change', function(){
          setTimeout(function(){
            if (typeof window.CHEQ.refreshBadge === 'function') window.CHEQ.refreshBadge();
            if (typeof window.refreshChequeReminderUI === 'function') window.refreshChequeReminderUI();
          }, 0);
        });
        sel.__cheqHooked = true;
      }
      var y = document.getElementById('yearInput');
      if (y && !y.__cheqHooked){
        y.addEventListener('change', function(){
          setTimeout(function(){
            if (typeof window.CHEQ.refreshBadge === 'function') window.CHEQ.refreshBadge();
            if (typeof window.refreshChequeReminderUI === 'function') window.refreshChequeReminderUI();
          }, 0);
        });
        y.__cheqHooked = true;
      }
      // Also observe global year/owner programmatic changes
      var tryRefresh = function(){
        try {
          if (typeof window.CHEQ.refreshBadge === 'function') window.CHEQ.refreshBadge();
          if (typeof window.refreshChequeReminderUI === 'function') window.refreshChequeReminderUI();
        } catch(e){}
      };
      if (!window.__cheqPatchedSaveState && typeof window.saveState === 'function'){
        var __oldSave = window.saveState;
        window.saveState = function(){
          var r = __oldSave.apply(this, arguments);
          setTimeout(tryRefresh, 0);
          return r;
        };
        window.__cheqPatchedSaveState = true;
      }
    } catch(e){}
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', hookRefreshers);
  } else {
    hookRefreshers();
  }
})();
</script>
<!-- === Cheque Reminder — YEAR LOCK (owner+year isolation & UI guard) === -->
<script id="cheque-reminder-year-lock">
(function(){
  function slug(s){ return (s||'unknown').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g,'-'); }
  function getOwnerId(){
    try{
      if (typeof getSelectedOwnerId === 'function'){ const id = getSelectedOwnerId(); if (id) return slug(id); }
      const sel = document.getElementById('ownerSelect'); if (sel && (sel.value||sel.selectedOptions?.[0]?.value)) return slug(sel.value||sel.selectedOptions[0].value);
      const stored = localStorage.getItem('selectedOwnerId'); if (stored) return slug(stored);
      const nameEl = document.getElementById('ownerNameDisplay'); if (nameEl?.textContent) return slug(nameEl.textContent);
    }catch(e){}
    return 'owner-unknown';
  }
  function getYear(){
    try{
      if (typeof getCurrentYear === 'function'){ const y = Number(getCurrentYear()); if (Number.isFinite(y)) return y; }
      const yEl = document.getElementById('yearInput') || document.getElementById('yearSelect');
      if (yEl?.value){ const n = parseInt(yEl.value,10); if (!isNaN(n)) return n; }
      const fancy = document.getElementById('yearFancy'); if (fancy?.textContent){ const n = parseInt(fancy.textContent.replace(/[^\d]/g,''),10); if (!isNaN(n)) return n; }
    }catch(e){}
    return (new Date()).getFullYear();
  }
  function key(){ return "chequeReminder:" + getOwnerId() + ":" + getYear(); }
  function readStrict(){
    try{
      // one-time migrate legacy generic key if present (to current scope only)
      const legacy = localStorage.getItem("chequeReminder");
      if (legacy && !localStorage.getItem(key())){
        localStorage.setItem(key(), legacy);
        localStorage.removeItem("chequeReminder");
      }
      const raw = localStorage.getItem(key());
      if (!raw) return {};
      const st = JSON.parse(raw);
      if (st && st._owner === getOwnerId() && st._year === getYear()) return st;
      return {}; // reject mismatched scope
    }catch(e){ return {}; }
  }
  function writeStrict(st){
    try{
      const obj = Object.assign({}, st||{}, {_owner:getOwnerId(), _year:getYear()});
      localStorage.setItem(key(), JSON.stringify(obj));
    }catch(e){}
  }
  function clearTimers(){ try{
    if (window.__cheqOneShot){ clearTimeout(window.__cheqOneShot); window.__cheqOneShot = null; }
    if (window.__cheqRepeat){ clearInterval(window.__cheqRepeat); window.__cheqRepeat = null; }
  }catch(e){} }

  function refreshUI(){
    const due = document.getElementById('cheqDueAt');
    const setBtn = document.getElementById('cheqSetBtn');
    const st = readStrict();
    if (due) due.value = st.ts ? new Date(st.ts).toISOString().slice(0,16) : "";
    if (setBtn){
      if (st.ts && !st.done){
        setBtn.classList.add('active');
      }else{
        setBtn.classList.remove('active'); clearTimers();
      }
    }
  }

  // Guard: keep the due field consistent with scoped storage
  function guardDueField(){
    const due = document.getElementById('cheqDueAt');
    if (!due) return;
    try{
      if (due.__cheqGuarded) return;
      const obs = new MutationObserver(()=>{
        const st = readStrict();
        const expect = st.ts ? new Date(st.ts).toISOString().slice(0,16) : "";
        if (due.value !== expect){ due.value = expect; }
      });
      obs.observe(due, {attributes:true, attributeFilter:['value']});
      due.addEventListener('change', ()=>{
        // Save only to current scope
        const ts = Date.parse(due.value);
        if (Number.isFinite(ts)){ writeStrict({ ts, done:false }); refreshUI(); }
      });
      due.__cheqGuarded = true;
    }catch(e){}
  }

  // Hook owner/year changes
  function hookScopeChanges(){
    const ownerSel = document.getElementById('ownerSelect');
    const yearSel  = document.getElementById('yearInput') || document.getElementById('yearSelect');
    function onScope(){ clearTimers(); refreshUI(); }
    ownerSel && ownerSel.addEventListener('change', onScope);
    yearSel  && yearSel.addEventListener('change',  onScope);
    // Observe programmatic changes
    try{
      const t = ownerSel || document.getElementById('ownerNameDisplay') || document.body;
      const mo = new MutationObserver(onScope);
      mo.observe(t, {subtree:true, childList:true, characterData:true, attributes:true});
    }catch(e){}
  }

  // Expose helpers for other scripts
  window.__CHEQ_YEAR_LOCK__ = { key, readStrict, writeStrict, refreshUI };

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ hookScopeChanges(); guardDueField(); refreshUI(); });
  }else{
    hookScopeChanges(); guardDueField(); refreshUI();
  }

  // Mark page as loaded after initialization
  function markPageLoaded() {
    document.body.classList.add('loaded');
  }

  // Add loaded class immediately to prevent flicker
  document.body.classList.add('loaded');

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', markPageLoaded);
  } else {
    markPageLoaded();
  }
  window.addEventListener('load', markPageLoaded);
})();
</script>
